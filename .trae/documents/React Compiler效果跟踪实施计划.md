# React Compiler效果跟踪实施计划

## 1. 目标与范围

### 目标

* 以可重复的测试流程量化React Compiler的收益与风险

* 在典型页面与交互场景下比较开启/关闭Compiler的渲染次数与响应时间

### 评估范围

* **组件级**：使用React DevTools Profiler记录Commit次数与渲染耗时

* **页面级**：使用Lighthouse测量LCP/TBT/CLS/TTI等核心指标

* **稳定性**：验证无逻辑回归、无新增错误

### 基准测试页面

1. **仪表盘**：`/dashboard`（虚拟列表与多卡片）
2. **订单状态页**：`/orders/status/all`（复杂表格与操作区）
3. **线索看板**：`/leads/kanban`（拖拽与乐观更新）
4. **通知页**：`/notifications`（多Tab与列表）

## 2. 实施步骤

### 2.1 准备工作

* ✅ 确认项目已配置React Compiler开关（通过`REACT_COMPILER`环境变量）

* ✅ 确认性能测试脚本已存在（`scripts/run-performance-test.js`）

* ✅ 确认LHCI配置已就绪（`package.json`中的`lhci:*`脚本）

### 2.2 A/B测试配置

1. **关闭React Compiler（A组）**：

   ```bash
   REACT_COMPILER=false npm run build
   REACT_COMPILER=false npm run start
   ```

2. **开启React Compiler（B组）**：

   ```bash
   REACT_COMPILER=true npm run build
   REACT_COMPILER=true npm run start
   ```

### 2.3 组件级渲染测试

#### 测试工具

* React DevTools Profiler

#### 测试场景

1. **仪表盘**：

   * 切换卡片筛选

   * 滚动虚拟列表1000项

2. **订单状态页**：

   * 筛选条件切换

   * 分页翻页

3. **线索看板**：

   * 拖拽10次跨列

   * 撤销一次（乐观更新回滚）

4. **通知页**：

   * Tab切换

   * 列表滚动与“标记已读”一次

#### 数据采集

* 每次交互记录：

  * Commit次数

  * 总渲染耗时

  * 主要组件渲染次数

### 2.4 页面级性能测试

#### 测试工具

* Lighthouse CI

* 自定义性能测试脚本

#### 测试流程

1. **启动测试服务器**：确保应用在`http://localhost:3000`运行
2. **执行Lighthouse测试**：

   ```bash
   npm run lhci:autorun
   ```
3. **执行自定义性能测试**：

   ```bash
   npm run performance:test
   ```

#### 数据采集

* 核心Web指标：LCP、TBT、CLS、TTI

* 资源加载时间

* 首次内容绘制（FCP）

* 首次交互时间（FID）

### 2.5 稳定性验证

#### 测试方法

1. **功能回归测试**：运行现有测试套件

   ```bash
   npm run test:ci
   ```
2. **E2E测试**：使用Playwright进行端到端测试

   ```bash
   npm run e2e
   ```
3. **手动交互测试**：验证关键用户流程
4. **错误日志监控**：检查控制台与Sentry错误

## 3. 验收标准

### 3.1 性能收益

* **组件级**：目标交互的Commit次数平均下降≥15%，或渲染耗时平均下降≥10%

* **页面级**：Lighthouse的TBT/LCP至少一项有显著改善（≥5%），且无显著退化

### 3.2 稳定性

* 无逻辑回归（事件处理、状态一致性、UI不抖动）

* 错误日志无新增

* 所有现有测试通过

## 4. 结果汇总与分析

### 4.1 数据整理

* 生成对比表（开启vs关闭）：

  | 页面  | 配置  | Commit次数 | 渲染耗时 | LCP | TBT | CLS | TTI |
  | --- | --- | -------- | ---- | --- | --- | --- | --- |
  | 仪表盘 | A组  | -        | -    | -   | -   | -   | -   |
  | 仪表盘 | B组  | -        | -    | -   | -   | -   | -   |
  | ... | ... | ...      | ...  | ... | ... | ... | ... |

### 4.2 结论生成

* 性能收益分析

* 稳定性评估

* 风险识别

* 建议与决策

## 5. 风险与回滚策略

### 5.1 潜在风险

* **行为差异**：Compiler对副作用、可变对象、未声明依赖的闭包有约束

* **性能退化**：某些场景下Compiler可能导致性能下降

* **兼容性问题**：与某些库或模式不兼容

### 5.2 回滚策略

* 保留A/B配置切换（通过环境变量）

* 若发现问题，默认关闭Compiler

* 记录问题场景与修复建议

* 持续监控与迭代优化

## 6. 实施时间线

1. **准备阶段**：已完成
2. **测试执行**：2-3天
3. **结果分析**：1天
4. **报告生成**：1天

## 7. 输出文档

* 《React Compiler效果跟踪报告》

  * 测试环境与配置

  * 测试结果与对比

  * 性能收益分析

  * 稳定性评估

  * 风险识别

  * 建议与决策

## 8. 后续优化

* 针对性能收益不明显的页面，优化组件结构以更好地利用Compiler

* 修复发现的兼容性问题

* 持续监控生产环境性能

* 定期重新评估Compiler效果

***

**注意事项**：

* 测试过程中保持环境一致性（相同设备、网络条件、测试数据）

* 每项测试至少重复3次，取平均值

* 详细记录测试过程与结果，确保可重现性

* 重点关注用户高频交互场景

