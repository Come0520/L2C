# 流式首屏优化实施计划 (Next.js 15)

## 优化目标
通过实现Streaming SSR + Suspense，减少首屏渲染时间，提升TTFB和感知性能，最终提高Lighthouse性能分数。充分利用Next.js 15和React 19的新特性。

## 分析当前实现

### 1. Notifications Page (`notifications/page.tsx`)
- **当前状态**：标准Server Component，并行获取所有数据后渲染
- **问题**：需要等待所有数据（通知+审批）加载完成才渲染，TTFB较长
- **优化点**：使用Suspense分离关键与非关键数据，实现流式渲染

### 2. Leads Kanban Page (`leads/kanban/page.tsx`)
- **当前状态**：Client Component，使用React Query获取数据
- **问题**：无Server Component优势，加载状态简单
- **优化点**：改为RSC/RCC混合渲染，实现分层加载

## Next.js 15特性利用

### 1. React 19并发特性
- **并发渲染**：利用`startTransition`优化渲染优先级
- **改进的Suspense**：更好的流式渲染支持
- **React Cache**：优化数据获取缓存

### 2. Next.js 15 Streaming增强
- **Streamable Components**：更简单的流式组件实现
- **改进的Suspense边界**：更好的加载状态管理
- **优化的Server Actions**：可用于数据更新

## 实施步骤

### 1. 重构Notifications Page
- **将Server Component拆分为多层**：
  - 保留外层为Server Component
  - 将通知列表和审批列表拆分为独立的Suspense边界
  - 为每个Suspense边界添加loading状态
- **实现流式数据获取**：
  - 将`getNotifications()`和`getApprovals()`改为独立的异步函数
  - 使用Suspense包裹每个数据组件
  - 实现loading.tsx作为加载占位符
- **优化数据加载顺序**：
  - 优先加载高优先级数据（如未读通知）
  - 延迟加载低优先级数据
  - 利用React 19的`startTransition`优化渲染优先级

### 2. 重构Leads Kanban Page
- **改为RSC/RCC混合渲染**：
  - 外层使用Server Component渲染基本布局和初始数据
  - 看板交互使用Client Component实现
  - 使用Suspense分离数据加载
- **实现分层加载**：
  - 首屏渲染核心看板结构和关键数据
  - 延迟加载次要数据和交互功能
  - 为数据加载添加骨架屏
- **优化状态管理**：
  - 结合React Query和Suspense
  - 实现乐观更新和缓存策略
  - 利用Next.js 15的缓存优化

### 3. 通用优化
- **添加loading.tsx模板**：为每个异步组件添加合适的加载占位符
- **利用Next.js 15 Streaming配置**：确保正确配置Streaming功能
- **优化数据获取逻辑**：
  - 减少首屏数据量
  - 实现数据预取和缓存
  - 优化API响应时间
  - 使用React 19的`cache`函数优化数据获取
- **添加性能监控**：
  - 集成Lighthouse CI
  - 添加Performance API监控
  - 实现用户体验指标收集

## 预期效果

### 性能提升
- TTFB降低：首屏渲染时间减少
- FCP提升：首次内容绘制更快
- 感知性能提升：用户更早看到可用内容
- Lighthouse性能分提升

### 用户体验
- 渐进式内容加载：先显示核心内容，再显示次要内容
- 流畅的加载状态：骨架屏替代简单的加载提示
- 更快的交互可用性：核心功能更早可用

## 技术要点

### 1. Next.js 15 RSC/RCC混合渲染
```tsx
// Server Component (page.tsx)
export default async function Page() {
  return (
    <Layout>
      <Suspense fallback={<LoadingComponent />}>
        <AsyncDataComponent />
      </Suspense>
      <Suspense fallback={<LoadingComponent />}>
        <AnotherAsyncDataComponent />
      </Suspense>
    </Layout>
  );
}

// Async Server Component
async function AsyncDataComponent() {
  const data = await fetchData();
  return <ClientComponent data={data} />;
}

// Client Component
'use client';
export function ClientComponent({ data }) {
  // 客户端交互逻辑
}
```

### 2. React 19 Suspense优化
- 为每个数据区块创建独立的Suspense边界
- 利用改进的Suspense实现更好的流式渲染
- 使用`startTransition`优化渲染优先级

### 3. 数据获取优化
```tsx
// 使用React 19 cache优化数据获取
import { cache } from 'react';

const getData = cache(async () => {
  // 数据获取逻辑
});
```

### 4. Loading状态优化
- 实现骨架屏替代简单加载提示
- 为不同组件设计合适的loading状态
- 确保loading状态与最终内容尺寸一致

## 验收标准

### 1. 性能指标
- TTFB降低30%以上
- FCP时间缩短50%以上
- Lighthouse性能分达到90+分

### 2. 用户体验
- 首屏核心内容在1秒内可见
- 加载状态流畅自然
- 交互功能在核心内容加载后立即可用

### 3. 代码质量
- 符合Next.js 15和React 19最佳实践
- 正确使用Suspense边界
- 代码结构清晰，易于维护

## 实施顺序

1. 重构Notifications Page，实现Streaming SSR + Suspense
2. 重构Leads Kanban Page，实现RSC/RCC混合渲染
3. 添加通用loading组件和骨架屏
4. 配置Performance API监控
5. 运行Lighthouse测试，验证优化效果
6. 迭代优化，解决潜在问题