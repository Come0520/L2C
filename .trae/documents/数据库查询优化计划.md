# 数据库查询优化计划（基于现有技术栈）

## 1. 当前技术栈确认

根据 `package.json` 分析，项目当前使用：
- ✅ **Supabase 客户端库**（`@supabase/supabase-js`）：直接数据库查询
- ✅ **React Query**（`react-query`）：客户端数据管理和缓存
- ❌ **无 Redis**：未使用 Redis 作为缓存
- ❌ **无 Prisma**：未使用 Prisma ORM

## 2. 查询优化方案（基于现有技术栈）

### 2.1 核心优化策略

#### 2.1.1 利用 React Query 缓存机制

| 优化点 | 具体方案 | 实现文件 |
|-------|---------|---------|
| **启用查询缓存** | 为所有服务查询添加 React Query 支持 | 所有 `.client.ts` 服务文件 |
| **优化缓存策略** | 为不同查询类型设置合理的缓存时间和失效策略 | `src/hooks/` 目录下的自定义 hooks |
| **实现预加载** | 对热门查询和关联数据实现预加载 | 关键页面组件 |
| **缓存失效管理** | 实现缓存标签系统，确保数据一致性 | 查询函数和 mutation 操作 |

#### 2.1.2 Supabase 查询优化

| 优化点 | 具体方案 | 实现文件 |
|-------|---------|---------|
| **减少数据传输** | 移除 `select('*')`，只选择必要字段 | 所有查询方法 |
| **优化关联查询** | 使用嵌套查询语法，一次获取所有关联数据 | 所有列表和详情查询 |
| **分页查询优化** | 实现基于游标的高效分页，替代 `range()` | 所有列表查询 |
| **索引优化** | 为查询条件添加合适索引 | 数据库迁移文件 |
| **避免全表扫描** | 确保筛选条件使用索引字段 | 所有筛选查询 |

#### 2.1.3 代码层面优化

| 优化点 | 具体方案 | 实现文件 |
|-------|---------|---------|
| **查询复用** | 提取公共查询逻辑，避免重复代码 | `src/services/base.client.ts` |
| **批量操作优化** | 使用 Supabase RPC 函数处理批量操作 | 批量更新方法 |
| **异步查询并行化** | 使用 `Promise.all()` 优化关联查询 | 详情查询方法 |
| **查询参数验证** | 提前验证查询参数，避免无效查询 | 所有查询方法 |

## 3. 具体实现计划

### 3.1 阶段 1：基础优化（1-2 天）

1. **优化查询字段选择**
   - 修改 `leads.client.ts` 中的 `getLeads` 方法，明确选择字段
   - 优化 `salesOrders.client.ts` 中的关联查询，减少数据传输
   - 移除所有不必要的 `select('*')` 用法

2. **增强 React Query 缓存**
   - 为 `useLeads`、`useSalesOrders` 等自定义 hooks 添加缓存配置
   - 设置合理的缓存时间（如列表查询 5 分钟，详情查询 10 分钟）
   - 实现缓存标签系统，用于批量失效

3. **添加索引优化**
   - 为 `leads` 表添加 `idx_leads_status_created_at` 索引
   - 为 `orders` 表添加 `idx_orders_status_created_at` 索引
   - 为 `leads` 表添加 `idx_leads_name_phone` 索引

### 3.2 阶段 2：高级优化（2-3 天）

1. **实现高效分页**
   - 替换 `range()` 分页为基于游标的分页
   - 实现 `getCursor` 和 `getNextPage` 方法
   - 优化大数据量下的分页性能

2. **优化复杂查询**
   - 重构 `leadService.getLeads` 中的复杂筛选逻辑
   - 优化多表关联查询，减少 JOIN 操作
   - 实现查询条件的智能组合

3. **实现查询预加载**
   - 为热门查询添加预加载逻辑
   - 实现关联数据的自动预加载
   - 优化用户体验

### 3.3 阶段 3：监控与持续优化（长期）

1. **实现查询性能监控**
   - 利用 React Query 的内置监控功能
   - 添加查询执行时间统计
   - 实现慢查询日志

2. **持续索引优化**
   - 根据查询日志优化索引
   - 定期审查索引使用情况
   - 移除无效索引

3. **查询模式分析**
   - 分析查询模式，优化热门查询
   - 实现查询结果的智能缓存
   - 优化数据模型设计

## 4. 优化效果预期

| 指标 | 优化前 | 优化后 | 提升比例 |
|------|-------|-------|---------|
| 列表查询响应时间 | 200-500ms | 50-100ms | 60-80% |
| 详情查询响应时间 | 100-300ms | 30-80ms | 50-70% |
| 重复查询响应时间 | 同首次查询 | <10ms（缓存命中） | >90% |
| 数据库查询次数 | 高 | 低 | 减少 70% |
| 用户等待时间 | 长 | 短 | 提升用户体验 |

## 5. 风险与缓解措施

| 风险 | 缓解措施 |
|------|---------|
| **缓存一致性问题** | 实现合理的缓存失效策略，使用缓存标签系统 |
| **索引膨胀** | 定期审核和清理索引，只保留必要索引 |
| **查询复杂度增加** | 保持查询代码的可读性，添加适当注释 |
| **迁移影响** | 逐步实施优化，每个优化点单独测试 |
| **性能测试覆盖不足** | 增加性能测试用例，模拟真实负载 |

## 6. 最佳实践

### 6.1 查询代码规范
- 明确注释查询目的和优化点
- 避免在循环中执行查询
- 统一查询构建方式
- 错误处理标准化

### 6.2 React Query 最佳实践
- 为所有查询添加唯一键
- 合理设置 `staleTime` 和 `cacheTime`
- 使用 `queryClient.invalidateQueries()` 管理缓存失效
- 利用 `prefetchQuery` 实现预加载

### 6.3 Supabase 查询最佳实践
- 使用 `select()` 明确指定字段
- 利用嵌套查询语法减少 N+1 查询
- 优先使用 `eq()`、`in()` 等索引友好的筛选条件
- 避免在 `ilike` 开头使用 `%`（如 `ilike.%term%` 可以使用索引，`ilike.%term` 不行）

## 7. 验证计划

### 7.1 性能测试
- 模拟 1000+ 并发用户
- 测试不同数据量下的查询性能
- 对比优化前后的响应时间

### 7.2 监控指标
- 查询执行时间
- 缓存命中率
- 数据库查询次数
- 用户体验指标

### 7.3 A/B 测试
- 部分用户使用优化后的查询
- 对比两组用户的体验指标

通过以上优化计划，我们可以充分利用现有技术栈的优势，显著提升数据库查询性能，减少响应时间，降低资源消耗，为用户提供更流畅的体验。