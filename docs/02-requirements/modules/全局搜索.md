# 全局搜索模块需求与规范

## 1. 业务目标
提供全平台一致化、快速定位业务实体的全局入口，提升操作直达体验。当前搜索范围覆盖客户分析(`customers`)、商业线索(`leads`)与订单管理(`orders`)。

## 2. 核心能力

### 2.1 搜索对象及可见域
- **Customers**: 客户名称(`name`)、客户手机(`phone`)
- **Leads**: 线索的客户名称(`customerName`)、线索手机号(`customerPhone`)
- **Orders**: 订单号(`orderNo`)
> **多租户隔离**：所有查询底层均受到严格的 `tenantId` (租户ID) 数据级隔离，无法越界搜索。

### 2.2 搜索范围控制 (Scope Control)
当前服务端允许传入 `scope` 过滤只查询特定板块，减轻深层多表联合搜索负载：
- `all` (默认): 全域搜索
- `customers` / `orders` / `leads`: 分项垂直搜索

### 2.3 自动格式化与高亮
后端会将击中 `query` 的原文段落包裹在 HTML `<mark>` 标签中回抛 (以 `highlight` 字段承载）。前端在展示结果列表时可通过富文本形式将该段高亮，提升用户搜检效率。

### 2.4 性能处理与历史留痕
- **防抖机制 (Debounce)**：由于前端按键极其高频，规定发包到后端的行为必须受限（建议 `500ms` 防抖），配合 Server 端接口通过 `unstable_cache` 所赋予的 `60s` 结果缓存策略减轻数据库查询冲击。
- **缓存策略**：底层利用 Next.js API `unstable_cache` 进行细粒度控制。Cache Key 为 `[search-{tenantId}, query, scope, limit]`，确保完全按租户隔离，缓存生效时间 60 秒。针对租户维度的无效化使用 tags `[search-{tenantId}]`。
- **历史记录 (History)**：服务端利用 Redis `List` 结构存放单一用户的最新的最多 10 条搜索。该机制在 Redis 未配置或抛出异常时自动无损降级（不留历史静默降级，不阻断正常搜索链路）。

## 3. 系统架构与底层数据检索
- **检索算法**：借助 Drizzle ORM 的 `ilike` 实现全量模糊匹配 `%{query}%`，结合 `or()` 操作符进行多列比对。
- **查询隔离**：所有查询的顶层前置条件必然是 `eq(xxx.tenantId, tenantId)`，由 Session 自动剥离出当前 `tenantId`，防止任意情况下的租户越权。

## 4. 错误预防与限制
- **字数**：搜索词最小不做限制（`query=""` 以抓取历史记录），最长支持不超过 `100` 个字符截断。由于后端处理了特殊正则表达式字符的字面量转义，系统免疫任意特殊符号带来的正则报错崩溃。
- **返回包体控制**：通过 `limit` 参数(最大50条)防止极端大批量的命中造成带宽与响应压力。

## 5. 测试覆盖
全局搜索模块共包含 `1` 个核心测试套件 (`actions.test.ts`)，覆盖 `8` 个核心边界场景：
1. **认证拦截**：未登录拦截、入参超长 101 字被 Zod 拒绝。
2. **逻辑穿透**：带/不带关键词的精准调用差异，空搜必定降级取历史且不去 DB 施压。
3. **架构稳健**：特殊字符正则不抛错，Redis 失联静默降级不阻断主链路。
4. **范围控制**：`scope` 参数准确阻击非相关数据表查询。
