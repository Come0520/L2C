这是一个非常关键的深度化需求。在 L2C 系统中，角色（Role）决定了数据的**边界**（谁能看毛利，谁只能看单号）和**操作权限**（谁能改价格，谁只能确认安装）。

为了让 Vibe Coding 工具精准实现，我们需要将“角色管理”设计为一套**可扩展的 RBAC（基于角色的访问控制）模型**。

---

### 🚀 深化需求：L2C 动态角色权限系统

#### 1. 核心逻辑设计

我们将权限分为两个维度：

* **功能权限 (Functional Permissions)**：能不能点开这个按钮（如：删除订单、查看财务报表）。
* **数据范围 (Data Scoping)**：能看到谁的数据（如：本人、本部门、全公司）。

#### 2. 角色分类

* **预设角色 (System Presets - 不可删除/修改核心逻辑)**：
* **超级管理员 (Super Admin)**：拥有所有权限。
* **销售经理 (Sales Manager)**：查看部门全员线索、审批折扣、查看毛利分析。
* **一线销售 (Sales Representative)**：仅处理分配给自己的线索和订单，不能查看后台毛利。
* **财务 (Finance)**：专注于回款确认、供应商对账、开票管理。
* **供应链/内勤 (Supply Chain Manager)**：管理工厂下单、物流跟踪，无权改动订单单价。
* **派单员（Dispatcher）**：连接"前端销售"与"后端交付"的桥梁，负责资源的统筹调度与成本管控。
* **服务师傅 (Worker)**：仅在移动端查看任务详情、上传完工图、确认工费。

* **师傅类型 (Worker Type)**：
  师傅类型是服务师傅角色的细分，用于标识师傅的能力范围：
  * **测量师 (MEASURER)**：仅具备测量技能，可接测量单
  * **安装师 (INSTALLER)**：仅具备安装技能，可接安装单
  * **全能师傅 (BOTH)**：同时具备测量和安装技能，可接测量单和安装单
  * **非师傅 (null)**：非师傅角色（如销售、客服）

  *注：师傅类型通过 `users.worker_type` 字段标识，与角色权限系统配合使用。*

* **自定义角色 (Custom Roles)**：
* 用户可以基于现有权限点，自由组合。例如：为一个“圣都驻点助理”创建一个只能录单、不能看价格的角色。



---

### 3. 数据库 Schema 设计 (给 Vibe Coding 的技术指令)

我们将使用 **Drizzle ORM** 构建四张核心表：

```typescript
// 1. 权限表 (Permissions) - 定义系统中有哪些权限点
// 如: 'order:create', 'order:edit_price', 'finance:view_margin'
export const permissions = pgTable('permissions', {
  id: serial('id').primaryKey(),
  code: varchar('code').unique().notNull(), // 唯一编码
  description: text('description'), // 权限描述
  module: varchar('module'), // 所属模块: 订单/财务/线索
});

// 2. 角色表 (Roles)
export const roles = pgTable('roles', {
  id: serial('id').primaryKey(),
  name: varchar('name').notNull(),
  isSystem: boolean('is_system').default(false), // 是否为系统预设角色
  dataScope: varchar('data_scope'), // 数据范围: 'personal', 'department', 'all'
});

// 3. 角色-权限关联表 (Role_Permissions)
export const rolePermissions = pgTable('role_permissions', {
  roleId: integer('role_id').references(() => roles.id),
  permissionId: integer('permission_id').references(() => permissions.id),
});

// 4. 用户-角色关联表 (User_Roles)
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: varchar('name').notNull(),
  roleId: integer('role_id').references(() => roles.id),
  // 其他字段...
});

```

---

### 4. 功能需求要点 (总分加分项)

#### 🛡️ 加分项 A：权限颗粒度控制

* **按钮级控制**：前端根据用户 Permission Code 决定是否渲染“审核”按钮。
* **字段级脱敏**：非财务/经理角色，订单列表中的“毛利”和“进货价”字段直接隐藏或打码。

#### 📊 加分项 B：动态数据权限切换

* 当用户是“销售经理”时，数据库查询自动加上 `WHERE salesperson_id IN (subordinates)`。
* 当用户是“普通销售”时，自动加上 `WHERE salesperson_id = current_user_id`。

#### 🛠️ 加分项 C：角色管理配置界面

* **角色列表**：展示预设与自定义角色。
* **权限配置矩阵**：一个横竖交错的表格，勾选即可赋予角色特定权限。
* **一键克隆**：支持基于“销售经理”角色克隆一个新角色，微调后保存。

---

### 5. 给 Vibe Coding 的下一步指令 (Prompt)

> “现在请根据我的角色管理方案，开始实现后端逻辑：
> 1. **定义 Schema**：使用 Drizzle ORM 创建 `roles`, `permissions`, `role_permissions` 表。
> 2. **初始化预设数据**：编写一个 Seed 脚本，自动插入‘超级管理员’、‘销售经理’、‘销售员’、‘财务’等预设角色，并分配好对应的权限编码。
> 3. **编写权限校验逻辑**：创建一个中间件（Middleware）或辅助函数 `checkPermission(userId, permissionCode)`，用于在 Server Action 或 API 中拦截非法操作。
> 4. **注意安全**：所有逻辑必须基于数据库权限表，严禁在前端代码中硬编码 `if(role === 'admin')`。”
> 
> 

---

### 💡 建议

既然你要重新设计，我们可以在角色中加入一个 **“部门属性”**。这样你之前提到的“圣都组”、“北京供应链”就可以通过部门来隔离数据，实现更精细的管理。

**需要我帮你把“预设角色”对应的详细权限编码（Permission Codes）列出来吗？这能让 AI 生成的代码直接可用。**