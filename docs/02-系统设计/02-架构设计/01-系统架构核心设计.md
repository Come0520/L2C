# 系统架构核心设计 (System Architecture Core Design)

## 1. 系统概览

本系统（L2C - Leads to Cash）采用现代化的**模块化单体 (Modular Monolith)** 架构，基于 **Next.js 15+** 和 **Supabase** 构建。设计目标是结合单体架构的开发效率与微服务架构的模块化优势，利用 Serverless 和 BaaS 技术降低运维成本，实现快速交付与高可维护性。

### 1.1 核心设计理念
*   **BaaS 优先 (Backend as a Service)**：利用 Supabase 提供的 Auth, Database, Storage, Realtime 能力，减少后端重复造轮子。
*   **全栈 TypeScript**：从数据库到前端 UI，实现端到端的类型安全。
*   **模块化单体**：逻辑上模块化隔离，物理上统一部署，避免分布式系统的复杂性。
*   **实用主义整洁架构**：适配 Next.js 框架特性的六边形架构变体，强调业务逻辑与框架细节的分离，但不强求过度抽象。

## 2. 技术栈选择

| 领域 | 技术/库 | 说明 |
| :--- | :--- | :--- |
| **Framework** | **Next.js 15+ (App Router)** | React 服务器组件 (RSC), Server Actions, Partial Prerendering |
| **BaaS** | **Supabase** | PostgreSQL, Auth, Realtime, Storage, Edge Functions |
| **Language** | **TypeScript 5.x** | 严格模式，Zod 运行时校验 |
| **Styling** | **TailwindCSS + Shadcn/ui** | 实用优先 CSS 框架，可访问性组件库 |
| **State** | **Zustand + React Query** | 轻量级客户端状态管理 + 服务端数据缓存与同步 |
| **Validation** | **Zod** | Schema 声明与校验 |
| **Hosting** | **Vercel / Self-Hosted** | 边缘计算网络部署或 Docker 容器化部署 |

## 3. 架构模式

### 3.1 目录结构 (Feature-Sliced Design)

采用基于功能的目录结构，每个功能模块包含自己的 UI、逻辑和数据访问代码。

```bash
src/
├── app/                  # Next.js App Router (路由层 - 适配器)
│   ├── (auth)/           # 认证路由组
│   ├── (dashboard)/      # 仪表板路由组
│   └── api/              # 开放接口 (Webhooks 等)
├── features/             # 核心业务模块 (领域层)
│   ├── auth/             # 认证模块
│   ├── leads/            # 线索管理
│   ├── customers/        # 客户管理
│   ├── orders/           # 订单管理
│   └── products/         # 产品管理
├── shared/               # 共享内核 (基础设施层)
│   ├── components/       # 通用 UI 组件
│   ├── hooks/            # 通用 Hooks
│   ├── lib/              # 工具库 (supabase client, utils)
│   └── types/            # 全局类型
└── services/             # 外部服务集成 (SMS, Payment)
```

### 3.2 模块内部结构

每个 `features/<module>` 目录应自包含，遵循统一结构：

*   `components/`: 模块私有 UI 组件
*   `actions.ts`: Server Actions (对外暴露的写操作，充当 Controller/Application Service)
*   `queries.ts`: Data Fetching (对外暴露的读操作)
*   `schemas.ts`: Zod 数据验证 Schema (领域模型验证)
*   `types.ts`: 模块特定类型定义
*   `utils.ts`: 纯业务逻辑函数 (领域逻辑)

### 3.3 实用主义六边形架构 (Pragmatic Hexagonal)

在 Next.js 背景下，我们对传统六边形架构进行了适配：

*   **用户接口层 (Driving Adapter)**: Next.js Pages (`app/**/page.tsx`), Route Handlers (`app/api/**/route.ts`).
*   **应用服务层 (Application Layer)**: Server Actions (`actions.ts`). 负责编排业务流程，验证输入，调用领域逻辑。
*   **领域层 (Domain Layer)**: 纯 TypeScript 函数 (`utils.ts`) 和 Zod Schemas (`schemas.ts`). 不依赖 Next.js 或 Supabase 特定 API。
*   **基础设施层 (Driven Adapter)**: Supabase Client, 外部 API 客户端 (`services/`).

#### 代码示例：纯业务逻辑 (领域层)
```typescript
// features/leads/utils.ts
export function calculateLeadScore(lead: Lead, interactionsCount: number): number {
  let score = lead.score;
  if (lead.estimated_value && lead.estimated_value > 10000) {
    score += 20;
  }
  score += interactionsCount * 5;
  return Math.min(score, 100);
}
```

#### 代码示例：Server Action (应用服务层)
```typescript
// features/leads/actions.ts
'use server'
import { createClient } from '@/shared/lib/supabase/server';
import { leadSchema } from './schemas';

export async function createLead(formData: FormData) {
  const supabase = createClient();
  
  // 1. 输入验证
  const rawData = Object.fromEntries(formData);
  const validatedData = leadSchema.parse(rawData);
  
  // 2. 数据持久化 (通过 Supabase SDK)
  const { error } = await supabase.from('leads').insert({
    ...validatedData,
    status: 'new'
  });

  if (error) throw error;
  
  // 3. 刷新缓存
  revalidatePath('/leads');
}
```

## 4. 模块边界与通信

### 4.1 核心模块划分

| 模块 | 职责 | 核心实体 | 依赖模块 |
|:---|:---|:---|:---|
| **Auth** | 用户认证、权限管理、团队管理 | User, Profile, Team | None |
| **Leads** | 线索采集、分配、跟进、转化 | Lead, Activity | Auth, Customers |
| **Customers** | 客户档案、联系人、公海池 | Customer, Contact | Auth |
| **Orders** | 订单创建、支付、履约 | Order, OrderItem | Auth, Customers, Products |
| **Products** | 商品管理、库存、价格 | Product, SKU, Price | Auth |

### 4.2 模块间通信

由于是单体应用，模块间通信主要通过**函数调用**实现。

*   **同步调用 (Direct Call)**: 当一个模块需要另一个模块的数据时，直接导入其 Server Action 或 Query 函数。
    ```typescript
    import { getCustomer } from '@/features/customers/queries';
    // 在 Orders 模块中调用
    const customer = await getCustomer(customerId);
    ```
*   **异步通信 (Event/Webhook)**: 对于解耦逻辑（如订单创建后发送通知），使用 Supabase Database Webhooks 或 PostgreSQL 触发器。

### 4.3 数据边界

*   **物理统一**：所有模块共享同一个 PostgreSQL 数据库实例。
*   **逻辑隔离**：通过命名规范（如 `leads_`, `orders_` 前缀）或 Schema 区分表归属。
*   **外键约束**：允许跨模块外键引用，保证数据强一致性。

## 5. 安全设计

*   **RLS (Row Level Security)**: 在数据库层强制执行访问控制策略。所有数据访问必须经过 RLS。
*   **Server Components**: 敏感逻辑（如 API 密钥调用）在服务端组件运行，不在客户端暴露。
*   **Zod Validation**: 所有输入数据（表单、API请求）必须经过 Zod Schema 严格验证。

## 6. 演进策略

当前架构设计为单体，但保持了良好的模块化边界。如果未来需要拆分（如某模块负载极高）：
1.  **代码拆分**：模块代码已独立 (`features/xxx`)。
2.  **数据拆分**：将相关表迁移至独立库。
3.  **服务化**：将 Server Actions 包装为 API Route。
4.  **独立部署**：将模块部署为独立应用。

**当前阶段严禁过早拆分微服务。**
