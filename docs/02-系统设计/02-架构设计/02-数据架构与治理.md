# 数据架构与治理设计 (Data Architecture & Governance)

## 1. 架构概览

本系统基于 **PostgreSQL 15+ (Supabase)** 构建统一的数据存储与处理平台。摒弃传统的中间件堆叠模式，充分利用现代数据库的原生能力（如 RLS, Extensions, Webhooks, Partitioning）来简化架构，提升性能与可维护性。

### 1.1 核心原则
*   **单一数据源 (Single Source of Truth)**: 所有业务数据统一存储于 Postgres，避免数据孤岛。
*   **数据库即后端 (Database as Backend)**: 利用 Supabase 提供的 API 层和 Auth 层，减少传统应用服务器的胶水代码。
*   **原生治理 (Native Governance)**: 优先使用数据库约束 (Constraints) 和类型系统保证数据质量。

### 1.2 架构拓扑
```mermaid
graph TD
    Client[客户端 App/Web] --> NextJS[Next.js Server Actions]
    NextJS --> Supavisor[Supavisor 连接池]
    Supavisor --> PrimaryDB[PostgreSQL 主库]
    
    subgraph "Supabase Cluster"
        PrimaryDB
        ReadReplica[只读副本 (可选)]
        Storage[Object Storage]
        Auth[GoTrue Auth]
    end
    
    PrimaryDB -- "Webhooks" --> Edge[Edge Functions]
    Edge -- "Sync" --> External[外部系统 CRM/ERP]
    
    NextJS -- "Cache" --> Vercel[Vercel Data Cache]
```

## 2. 核心数据模型

遵循 `snake_case` 命名规范，使用 UUID 作为主键。

### 2.1 用户与权限 (Auth)
基于 `auth.users` 扩展业务属性：
```sql
create table public.profiles (
  id uuid references auth.users(id) on delete cascade primary key,
  username text unique,
  full_name text,
  role user_role default 'customer', -- enum type
  created_at timestamptz default now()
);
```

### 2.2 核心业务表
*   **Leads (线索)**: 记录潜在客户信息、来源、状态及分配情况。
*   **Customers (客户)**: 正式客户档案，包含企业信息、联系人、公海池标记。
*   **Orders (订单)**: 包含订单主表及 `order_items` 明细表，关联产品库。
*   **Products (产品)**: SKU 管理、价格体系、库存状态。

### 2.3 索引策略
针对高频查询场景建立复合索引：
*   **订单查询**: `CREATE INDEX idx_orders_status_created ON orders(status, created_at DESC);`
*   **线索搜索**: 使用 `pg_trgm` 或 `pgvector` 进行模糊/语义搜索。
*   **JSONB 索引**: 对非结构化数据（如产品规格）使用 GIN 索引。

## 3. 数据治理体系

采用 "数据库原生约束 + 应用层校验 + 异步清洗" 的三层治理架构。

### 3.1 数据库层 (Hard Constraints)
*   **类型约束**: 使用 Enum 管理状态 (e.g., `lead_status`, `order_type`)。
*   **检查约束**: `CHECK (price >= 0)`, `CHECK (email ~* '^.+@.+\..+$')`。
*   **引用完整性**: 严格的外键约束 (`ON DELETE CASCADE/SET NULL`)。
*   **行级安全 (RLS)**: 强制开启 RLS，策略示例：
    ```sql
    create policy "Sales can view own leads" on leads
    for select using (auth.uid() = assigned_to);
    ```

### 3.2 应用层 (Validation)
使用 **Zod** 在数据进入数据库前进行预处理：
```typescript
export const leadSchema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
  score: z.number().min(0).max(100).optional()
});
```

### 3.3 异步清洗 (Maintenance)
利用 `pg_cron` 执行定期维护任务：
*   清理临时文件/过期 Token。
*   定期更新统计报表视图 (Materialized Views)。
*   数据归档（将冷数据迁移至分区表）。

## 4. 性能优化方案

### 4.1 查询优化
*   **连接池**: 使用 Supavisor (Transaction Mode) 管理 Serverless 环境下的数据库连接。
*   **读写分离**: 在报表分析场景下，配置只读副本以分担主库压力。
*   **分区表**: 对 `orders`, `logs` 等大表按时间 (`created_at`) 进行 Range Partitioning。

### 4.2 缓存策略
*   **服务端缓存**: 利用 Next.js `unstable_cache` 缓存高频读请求（如产品目录、配置项）。
*   **客户端缓存**: React Query (TanStack Query) 管理前端状态与服务端同步。
*   **边缘缓存**: Vercel CDN 缓存静态资源和 ISR 页面。

## 5. 数据同步与集成

### 5.1 实时出站 (Outbound)
利用 **Database Webhooks** 监听变更，触发 Edge Function 推送数据至外部 CRM/ERP。
```sql
create trigger "sync-order-to-erp"
after insert on "orders"
for each row execute function supabase_functions.http_request(...);
```

### 5.2 批量入站 (Inbound)
*   **FDW (Foreign Data Wrappers)**: 直接挂载外部数据库表进行查询/同步。
*   **Scheduled Sync**: 使用 `pg_cron` 定时拉取外部 API 更新本地数据。

## 6. 数据迁移与上线策略

### 6.1 迁移流程
1.  **Schema 部署**: 使用 `supabase migration` 部署表结构和 RLS。
2.  **静态数据导入**: 使用 `COPY` 命令高速导入客户/产品数据 (CSV)。
3.  **动态数据割接**: 停机窗口内同步订单/跟进记录，重置 Sequence。
4.  **文件迁移**: 脚本遍历旧文件服务器上传至 Supabase Storage。

### 6.2 容灾与回滚
*   **PITR**: 开启 Supabase Point-in-Time Recovery，支持秒级回滚。
*   **双写期**: 上线初期（可选）保留旧系统写入，通过队列异步双写，确保可随时回退。
