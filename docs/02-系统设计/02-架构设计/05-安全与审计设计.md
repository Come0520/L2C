# 安全与审计设计

## 1. 设计目标

本方案旨在构建全方位的安全防护体系，重点解决敏感数据保护、操作审计追踪、合规性要求等核心安全问题。基于 Supabase 原生安全能力（RLS, Vault）结合 PostgreSQL 扩展（pgcrypto, pgAudit），实现深度防御。

### 核心原则
- **数据隐私**：敏感字段落库加密，密钥与数据分离。
- **可追溯性**：关键操作全量审计，日志防篡改。
- **最小权限**：基于 RLS 的行级访问控制。
- **合规性**：满足 GDPR、等保等数据安全规范。

---

## 2. 敏感数据加密方案

### 2.1 加密策略
采用应用层透明加密与数据库层加密相结合的方式。

| 数据级别 | 定义 | 加密方式 | 示例 |
| :--- | :--- | :--- | :--- |
| **L4 绝密** | 系统密钥、支付凭证 | Supabase Vault | API Keys, Service Role Secrets |
| **L3 机密** | 身份证、银行卡号 | pgcrypto (AES-256) | `identity_card`, `bank_account` |
| **L2 敏感** | 手机号、邮箱 | 数据库掩码 / 哈希 | `phone`, `email` (用于登录需哈希索引) |
| **L1 内部** | 用户ID、订单号 | 明文存储 | `user_id`, `order_no` |

### 2.2 数据库加密实现
利用 `pgcrypto` 扩展进行字段级加密。

```sql
-- 启用扩展
create extension if not exists pgcrypto;

-- 创建包含加密字段的表
create table user_documents (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references auth.users(id),
  doc_type text not null,
  -- 存储加密后的二进制数据
  encrypted_id_number bytea not null,
  created_at timestamptz default now()
);

-- 插入数据示例 (使用应用层密钥或数据库托管密钥)
insert into user_documents (user_id, doc_type, encrypted_id_number)
values (
  auth.uid(), 
  'passport', 
  pgp_sym_encrypt('G12345678', current_setting('app.encryption_key'))
);

-- 读取解密示例
select 
  doc_type,
  pgp_sym_decrypt(encrypted_id_number, current_setting('app.encryption_key')) as id_number
from user_documents
where user_id = auth.uid();
```

### 2.3 密钥管理 (KMS)
- **Master Key**: 存储于 Supabase Vault 或环境变量 `SUPABASE_SERVICE_KEY`。
- **Data Keys**: 动态生成，定期轮换。
- **密钥访问**: 仅通过 Server Actions 在服务端获取，严禁暴露给客户端。

### 2.4 数据脱敏
前端展示时进行数据掩码处理。

```typescript
/**
 * 身份证号脱敏: 1101******1234
 */
export function maskIDCard(id: string): string {
  if (!id) return '';
  return id.replace(/^(.{4})(?:\d+)(.{4})$/, "$1******$2");
}

/**
 * 手机号脱敏: 138****1234
 */
export function maskPhone(phone: string): string {
  if (!phone) return '';
  return phone.replace(/^(\d{3})\d{4}(\d{4})$/, "$1****$2");
}
```

---

## 3. 审计日志系统

### 3.1 日志模型设计
采用 PostgreSQL 分区表存储海量审计日志，按时间自动分区。

```sql
create table audit_logs (
  id bigint generated always as identity,
  event_time timestamptz not null default now(),
  event_type text not null,       -- CREATE, UPDATE, DELETE, LOGIN, EXPORT
  category text not null,         -- ORDER, USER, SYSTEM
  user_id uuid references auth.users(id),
  ip_address inet,
  user_agent text,
  resource_type text,             -- 表名或资源类
  resource_id text,               -- 业务主键
  action text not null,           -- 具体动作描述
  old_data jsonb,                 -- 变更前数据 (仅关键字段)
  new_data jsonb,                 -- 变更后数据
  status text not null default 'success',
  error_message text,
  metadata jsonb,                 -- 请求ID、耗时等
  primary key (event_time, id)
) partition by range (event_time);

-- 自动创建分区 (使用 pg_partman 或 pg_cron 定期执行)
-- 示例：按月分区
create table audit_logs_2024_01 partition of audit_logs
for values from ('2024-01-01') to ('2024-02-01');
```

### 3.2 日志采集机制
支持 **应用层采集** (Server Actions) 和 **数据库层采集** (Triggers) 双重保障。

#### 方式一：应用层采集 (业务语义更强)
```typescript
'use server'
import { createClient } from '@/utils/supabase/server';
import { headers } from 'next/headers';

export async function logAuditEvent(params: {
  eventType: string;
  category: string;
  action: string;
  resourceType?: string;
  resourceId?: string;
  newData?: any;
  status?: 'success' | 'failure';
  errorMessage?: string;
}) {
  const supabase = createClient();
  const headersList = headers();
  const ip = headersList.get('x-forwarded-for') || 'unknown';
  const userAgent = headersList.get('user-agent');

  // 异步写入，不阻塞主流程
  const { error } = await supabase.from('audit_logs').insert({
    event_type: params.eventType,
    category: params.category,
    action: params.action,
    resource_type: params.resourceType,
    resource_id: params.resourceId,
    new_data: params.newData,
    status: params.status || 'success',
    error_message: params.errorMessage,
    ip_address: ip,
    user_agent: userAgent
  });

  if (error) console.error('Failed to log audit event:', error);
}
```

#### 方式二：数据库触发器 (数据兜底)
适用于直接操作数据库的场景，确保无遗漏。

```sql
create or replace function audit_trigger_func() returns trigger as $$
declare
  v_user_id uuid;
begin
  v_user_id := auth.uid();
  
  insert into audit_logs (
    event_type, category, user_id, resource_type, resource_id, old_data, new_data, action
  ) values (
    TG_OP, 
    TG_TABLE_NAME, 
    v_user_id, 
    TG_TABLE_NAME, 
    new.id::text, 
    case when TG_OP = 'DELETE' or TG_OP = 'UPDATE' then row_to_json(old)::jsonb else null end,
    case when TG_OP = 'INSERT' or TG_OP = 'UPDATE' then row_to_json(new)::jsonb else null end,
    TG_OP || ' on ' || TG_TABLE_NAME
  );
  return new;
end;
$$ language plpgsql security definer;

-- 绑定触发器
create trigger audit_orders
after insert or update or delete on orders
for each row execute function audit_trigger_func();
```

### 3.3 访问控制与防篡改
- **RLS 策略**：仅允许管理员 (`role: admin`) 查看审计日志，普通用户不可见。
- **WORM (Write Once Read Many)**：通过 RLS 禁止 `UPDATE` 和 `DELETE` 操作，仅允许 `INSERT` 和 `SELECT`。
- **归档策略**：利用 `pg_cron` 定期将 6 个月前的日志导出到对象存储 (Cold Storage) 并从数据库删除。

```sql
-- 仅允许插入，禁止修改删除
create policy "Enable insert for authenticated users only" on audit_logs for insert to authenticated with check (true);
create policy "Enable select for admins only" on audit_logs for select using (
  exists (select 1 from profiles where id = auth.uid() and role = 'admin')
);
-- 无 update/delete 策略，即默认禁止
```

## 4. 安全防护体系

### 4.1 网络安全
- **SSL/TLS**: 全站 HTTPS 强制传输。
- **Edge Security**: Vercel Edge Network 提供 DDoS 防护和 IP 黑名单。
- **Rate Limiting**: 关键接口 (登录、短信) 实施限流。

### 4.2 身份认证
- **MFA**: 管理员账户强制开启多因素认证。
- **Session Management**: 短效 Access Token + Refresh Token 机制。
- **Password Policy**: 强密码策略 (长度、复杂度) 由 Supabase Auth 托管。

### 4.3 漏洞扫描
- **CI/CD 集成**: 提交代码时自动运行 `npm audit` 检查依赖漏洞。
- **定期扫描**: 使用 OWASP ZAP 等工具定期扫描应用漏洞。
