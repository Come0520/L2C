# 积分系统在途积分功能 - 数据库迁移方案

## 1. 迁移概述

本迁移方案旨在为现有的积分系统添加"在途积分"功能，确保与现有系统的兼容性和数据完整性。

## 2. 现有系统分析

### 2.1 现有 Prisma Schema 结构

**PointAccount 模型：**
```prisma
model PointAccount {
  id               Int      @id @default(autoincrement())
  user_id          Int      @unique @map("user_id")
  total_points     Int      @default(0) @map("total_points")
  available_points Int      @default(0) @map("available_points")
  frozen_points    Int      @default(0) @map("frozen_points")
  lifetime_earned  Int      @default(0) @map("lifetime_earned")
  lifetime_spent   Int      @default(0) @map("lifetime_spent")
  level            Int      @default(1)
  created_at       DateTime @default(now()) @map("created_at")
  updated_at       DateTime @updatedAt @map("updated_at")
  
  @@map("point_accounts")
}
```

**PointTransaction 模型：**
```prisma
model PointTransaction {
  id               Int       @id @default(autoincrement())
  user_id          Int       @map("user_id")
  transaction_type String    @map("transaction_type") // EARN, SPEND, EXPIRE, REFUND
  points           Int
  balance_after    Int       @map("balance_after")
  source_type      String?   @map("source_type")
  source_id        Int?      @map("source_id")
  rule_id          Int?      @map("rule_id")
  description      String?
  status           String    @default("SUCCESS") @map("status") // PENDING, SUCCESS, FAILED, CANCELLED
  trigger_condition String?  @map("trigger_condition")
  expires_at       DateTime? @map("expires_at")
  created_at       DateTime  @default(now()) @map("created_at")
  updated_at       DateTime  @updatedAt @map("updated_at")
  
  @@map("point_transactions")
}
```

## 3. 迁移需求

### 3.1 PointAccount 表需要添加的字段

```sql
ALTER TABLE point_accounts 
ADD COLUMN pending_points INT DEFAULT 0 COMMENT '在途积分';
```

### 3.2 PointTransaction 表需要扩展的事务类型

现有的 `transaction_type` 字段需要支持新的类型：
- `PENDING_EARN` - 在途积分创建
- `PENDING_CONFIRM` - 在途积分确认
- `PENDING_CANCEL` - 在途积分取消

### 3.3 新增字段用于在途积分管理

```sql
ALTER TABLE point_transactions 
ADD COLUMN expected_confirm_time TIMESTAMP NULL COMMENT '预期确认时间',
ADD COLUMN business_status VARCHAR(50) NULL COMMENT '业务状态',
ADD COLUMN pending_reason VARCHAR(255) NULL COMMENT '在途原因';
```

## 4. Prisma Schema 更新

### 4.1 更新 PointAccount 模型

```prisma
model PointAccount {
  id               Int      @id @default(autoincrement())
  user_id          Int      @unique @map("user_id")
  total_points     Int      @default(0) @map("total_points")
  available_points Int      @default(0) @map("available_points")
  pending_points   Int      @default(0) @map("pending_points")  // 新增字段
  frozen_points    Int      @default(0) @map("frozen_points")
  lifetime_earned  Int      @default(0) @map("lifetime_earned")
  lifetime_spent   Int      @default(0) @map("lifetime_spent")
  level            Int      @default(1)
  created_at       DateTime @default(now()) @map("created_at")
  updated_at       DateTime @updatedAt @map("updated_at")

  user         User               @relation(fields: [user_id], references: [id], onDelete: Cascade)
  transactions PointTransaction[]
  
  @@map("point_accounts")
}
```

### 4.2 更新 PointTransaction 模型

```prisma
model PointTransaction {
  id                    Int       @id @default(autoincrement())
  user_id               Int       @map("user_id")
  transaction_type      String    @map("transaction_type") // EARN, SPEND, EXPIRE, REFUND, PENDING_EARN, PENDING_CONFIRM, PENDING_CANCEL
  points                Int
  balance_after         Int       @map("balance_after")
  source_type           String?   @map("source_type")
  source_id             Int?      @map("source_id")
  rule_id               Int?      @map("rule_id")
  description           String?
  status                String    @default("SUCCESS") @map("status") // PENDING, SUCCESS, FAILED, CANCELLED
  trigger_condition     String?   @map("trigger_condition")
  expected_confirm_time DateTime? @map("expected_confirm_time")  // 新增字段
  business_status       String?   @map("business_status")        // 新增字段
  pending_reason        String?   @map("pending_reason")         // 新增字段
  expires_at            DateTime? @map("expires_at")
  created_at            DateTime  @default(now()) @map("created_at")
  updated_at            DateTime  @updatedAt @map("updated_at")

  user User       @relation(fields: [user_id], references: [id], onDelete: Cascade)
  rule PointRule? @relation(fields: [rule_id], references: [id])
  
  @@map("point_transactions")
}
```

## 5. 迁移步骤

### 5.1 第一步：备份数据库

```bash
# 备份当前数据库
pg_dump -h localhost -U username -d database_name > backup_before_migration.sql
```

### 5.2 第二步：更新 Prisma Schema

1. 更新 `schema.prisma` 文件，添加新字段
2. 生成迁移文件：
   ```bash
   npx prisma migrate dev --name add_pending_points_support
   ```

### 5.3 第三步：更新 PointsEngine 枚举

```typescript
// 更新 pointsEngine.ts 中的枚举
export enum PointTransactionType {
  EARN = 'EARN',
  SPEND = 'SPEND',
  EXPIRE = 'EXPIRE',
  REFUND = 'REFUND',
  MANUAL_ADJUST = 'MANUAL_ADJUST',
  PENDING_EARN = 'PENDING_EARN',      // 新增
  PENDING_CONFIRM = 'PENDING_CONFIRM', // 新增
  PENDING_CANCEL = 'PENDING_CANCEL'    // 新增
}
```

### 5.4 第四步：数据迁移脚本

```typescript
// 数据迁移脚本：确保现有数据的完整性
async function migrateExistingData() {
  // 1. 为所有现有账户添加 pending_points 字段（默认为0）
  await prisma.pointAccount.updateMany({
    data: {
      pending_points: 0
    }
  });

  // 2. 检查并修复数据一致性
  const accounts = await prisma.pointAccount.findMany();
  for (const account of accounts) {
    const transactions = await prisma.pointTransaction.findMany({
      where: { user_id: account.user_id }
    });
    
    // 重新计算总积分确保一致性
    const totalEarned = transactions
      .filter(t => ['EARN', 'REFUND'].includes(t.transaction_type))
      .reduce((sum, t) => sum + t.points, 0);
    
    const totalSpent = transactions
      .filter(t => ['SPEND', 'EXPIRE'].includes(t.transaction_type))
      .reduce((sum, t) => sum + t.points, 0);
    
    await prisma.pointAccount.update({
      where: { id: account.id },
      data: {
        lifetime_earned: totalEarned,
        lifetime_spent: totalSpent,
        available_points: totalEarned - totalSpent
      }
    });
  }
}
```

## 6. 兼容性保证

### 6.1 向后兼容性

- 现有的 API 接口保持不变
- 现有的积分计算逻辑不受影响
- 新增的字段都有默认值，不影响现有数据

### 6.2 渐进式升级

- 在途积分功能可以逐步启用
- 可以通过配置开关控制功能启用
- 支持回滚到原有逻辑

## 7. 测试计划

### 7.1 迁移测试

1. 在测试环境执行完整迁移流程
2. 验证数据完整性和一致性
3. 测试现有功能是否正常工作

### 7.2 功能测试

1. 测试在途积分的创建、确认、取消流程
2. 测试与现有积分系统的集成
3. 测试边界条件和异常情况

## 8. 回滚方案

如果迁移出现问题，可以通过以下步骤回滚：

```sql
-- 移除新增字段
ALTER TABLE point_accounts DROP COLUMN pending_points;
ALTER TABLE point_transactions DROP COLUMN expected_confirm_time;
ALTER TABLE point_transactions DROP COLUMN business_status;
ALTER TABLE point_transactions DROP COLUMN pending_reason;

-- 恢复备份数据
-- psql -h localhost -U username -d database_name < backup_before_migration.sql
```

## 9. 监控和验证

### 9.1 迁移后验证

- 检查所有表的数据完整性
- 验证积分计算的准确性
- 确认新功能正常工作

### 9.2 性能监控

- 监控数据库查询性能
- 检查新增字段对查询的影响
- 优化必要的索引

## 10. 部署建议

1. **分阶段部署**：先在测试环境验证，再部署到生产环境
2. **维护窗口**：选择业务低峰期进行迁移
3. **监控告警**：设置相关监控指标，及时发现问题
4. **团队协调**：确保开发、测试、运维团队协调配合
