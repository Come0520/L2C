# ç½—è±L2Cé”€å”®ç®¡ç†ç³»ç»Ÿ - æ•°æ®åº“è®¾è®¡æ–‡æ¡£

## ğŸ—„ï¸ æ•°æ®åº“æ¶æ„æ€»è§ˆ

### æ•°æ®åº“é€‰å‹ä¸æ¶æ„

#### æŠ€æœ¯æ ˆé€‰æ‹©
```
Supabase (PostgreSQL 15+) - ä¸»æ•°æ®åº“ï¼Œæ‰˜ç®¡ä¸è®¤è¯ã€RLS
Redis 7.x                 - ç¼“å­˜æ•°æ®åº“ï¼Œå­˜å‚¨çƒ­ç‚¹æ•°æ®å’Œä¼šè¯
```

#### æ•°æ®åº“è®¾è®¡åŸåˆ™
1. **ä¸šåŠ¡æ¨¡å—åŒ–**ï¼šæŒ‰ä¸šåŠ¡é¢†åŸŸè¿›è¡Œè¡¨ç»“æ„è®¾è®¡
2. **æ•°æ®ä¸€è‡´æ€§**ï¼šé€šè¿‡äº‹åŠ¡å’Œçº¦æŸä¿è¯æ•°æ®å®Œæ•´æ€§
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šåˆç†çš„ç´¢å¼•è®¾è®¡å’ŒæŸ¥è¯¢ä¼˜åŒ–
4. **æ‰©å±•æ€§**ï¼šé¢„ç•™æ‰©å±•å­—æ®µï¼Œæ”¯æŒä¸šåŠ¡æ¼”è¿›
5. **å®‰å…¨æ€§**ï¼šæ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨ï¼Œè®¿é—®æƒé™æ§åˆ¶

#### è¯­è¨€ä½¿ç”¨è§„èŒƒ
1. **è¡¨å**ï¼šå¿…é¡»ä½¿ç”¨è‹±æ–‡ï¼Œé‡‡ç”¨å¤æ•°å½¢å¼ï¼Œå¦‚ sales_orders, leads, customers
2. **å­—æ®µå**ï¼šå¿…é¡»ä½¿ç”¨è‹±æ–‡ï¼Œé‡‡ç”¨ä¸‹åˆ’çº¿å‘½åæ³•ï¼Œå¦‚ customer_name, phone_number, created_at
3. **ç´¢å¼•å**ï¼šå¿…é¡»ä½¿ç”¨è‹±æ–‡ï¼Œæ ¼å¼ä¸º idx_è¡¨å_å­—æ®µåï¼Œå¦‚ idx_sales_orders_status
4. **çº¦æŸå**ï¼šå¿…é¡»ä½¿ç”¨è‹±æ–‡ï¼Œæ ¼å¼ä¸º çº¦æŸç±»å‹_è¡¨å_å­—æ®µåï¼Œå¦‚ fk_sales_orders_customer_id
5. **æ³¨é‡Šè¯´æ˜**ï¼šè¡¨æ³¨é‡Šå’Œå­—æ®µæ³¨é‡Šä½¿ç”¨ä¸­æ–‡ï¼Œä¾¿äºå¼€å‘äººå‘˜ç†è§£ä¸šåŠ¡å«ä¹‰

#### æ•°æ®åº“åˆ†å±‚æ¶æ„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ä¸šåŠ¡æ•°æ®å±‚ï¼ˆBusiness Layerï¼‰ â”‚
â”‚  ç”¨æˆ·ã€çº¿ç´¢ã€è®¢å•ã€ç§¯åˆ†ç­‰æ ¸å¿ƒä¸šåŠ¡è¡¨    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         é…ç½®æ•°æ®å±‚ï¼ˆConfig Layerï¼‰   â”‚
â”‚  ç³»ç»Ÿé…ç½®ã€ä¸šåŠ¡è§„åˆ™ã€æšä¸¾å€¼ç­‰é…ç½®è¡¨     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         æ—¥å¿—æ•°æ®å±‚ï¼ˆLog Layerï¼‰      â”‚
â”‚  æ“ä½œæ—¥å¿—ã€ç™»å½•æ—¥å¿—ã€ç§¯åˆ†æµæ°´ç­‰æ—¥å¿—è¡¨    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 â”‚         ç»Ÿè®¡æ•°æ®å±‚ï¼ˆStats Layerï¼‰    â”‚
 â”‚  ä¸šåŠ¡ç»Ÿè®¡ã€æ’è¡Œæ¦œã€æŠ¥è¡¨æ•°æ®ç­‰ç»Ÿè®¡è¡¨      â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”’ æ•°æ®åº“å®‰å…¨ä¸RLSç­–ç•¥

### å®‰å…¨ç­–ç•¥åŸºçº¿
- **é»˜è®¤æ‹’ç»**ï¼šæ‰€æœ‰ä¸šåŠ¡è¡¨åœ¨å¼€å¯RLSåé»˜è®¤æ‹’ç»è®¿é—®
- **ç®¡ç†å‘˜æ”¾é€š**ï¼šä¸šåŠ¡ç®¡ç†å‘˜ä¸è¶…ç®¡å…·å¤‡å…¨è¡¨è®¿é—®æƒé™
- **æœ¬äººå¯è¯»**ï¼šæ™®é€šç”¨æˆ·ä»…å¯è®¿é—®ä¸è‡ªå·±ç›¸å…³çš„æ•°æ®åŸŸï¼ˆåˆ›å»ºäºº/åˆ†é…äºº/æ‰€å±è´¦æˆ·ï¼‰
- **æ•°æ®åŠ å¯†**ï¼šæ•æ„Ÿæ•°æ®é‡‡ç”¨AES-256åŠ å¯†å­˜å‚¨ï¼Œå¯†é’¥æ‰˜ç®¡äºSupabase Vault
- **å®¡è®¡æ—¥å¿—**ï¼šæ‰€æœ‰æ•°æ®å˜æ›´æ“ä½œè®°å½•å®¡è®¡æ—¥å¿—ï¼Œä¿ç•™90å¤©

### RLSç­–ç•¥è®¾è®¡
#### ç”¨æˆ·æ•°æ®éš”ç¦»
```sql
-- ç”¨æˆ·è¡¨ç­–ç•¥ï¼šç”¨æˆ·åªèƒ½æŸ¥çœ‹å’Œæ›´æ–°è‡ªå·±çš„ä¿¡æ¯
CREATE POLICY users_self_manage ON users FOR ALL TO authenticated USING (
  auth.uid() = auth_user_id
);
```

#### ç»„ç»‡æ•°æ®éš”ç¦»
```sql
-- çº¿ç´¢è¡¨ç­–ç•¥ï¼šåŸºäºç»„ç»‡æ¶æ„çš„æ•°æ®è®¿é—®æ§åˆ¶
CREATE POLICY leads_org_access ON leads FOR ALL TO authenticated USING (
  EXISTS (
    SELECT 1 FROM public.users u
    JOIN public.departments d ON u.department_id = d.id
    WHERE u.auth_user_id = auth.uid()
      AND (
        -- åŒéƒ¨é—¨å¯è§
        leads.department_id = u.department_id
        -- ä¸Šçº§éƒ¨é—¨å¯è§ä¸‹çº§
        OR d.path @> (SELECT path FROM departments WHERE id = leads.department_id)
        -- åˆ†é…ç»™è‡ªå·±çš„çº¿ç´¢
        OR leads.assigned_to_id = u.id
      )
  )
);
```

#### è§’è‰²æƒé™æ§åˆ¶
```sql
-- é”€å”®è®¢å•ç­–ç•¥ï¼šåŸºäºè§’è‰²çš„æ•°æ®è®¿é—®
CREATE POLICY orders_role_based ON orders FOR ALL TO authenticated USING (
  CASE
    WHEN public.has_role('SALES_MANAGER') THEN
      -- é”€å”®ç»ç†æŸ¥çœ‹æœ¬éƒ¨é—¨è®¢å•
      EXISTS (
        SELECT 1 FROM users u
        WHERE u.auth_user_id = auth.uid()
          AND u.department_id = orders.department_id
      )
    WHEN public.has_role('SALES_REP') THEN
      -- é”€å”®ä»£è¡¨åªèƒ½æŸ¥çœ‹è‡ªå·±çš„è®¢å•
      EXISTS (
        SELECT 1 FROM users u
        WHERE u.auth_user_id = auth.uid()
          AND u.id = orders.sales_user_id
      )
    ELSE public.is_admin()
  END
);
```

#### æ—¶é—´çª—å£æ§åˆ¶
```sql
-- æ•°æ®ä¿ç•™ç­–ç•¥ï¼šè‡ªåŠ¨æ¸…ç†è¿‡æœŸæ•°æ®
CREATE POLICY data_retention_policy ON audit_logs FOR DELETE TO authenticated USING (
  created_at < CURRENT_TIMESTAMP - INTERVAL '90 days'
);
```

### ç”¨æˆ·æ˜ å°„ä¸è®¤è¯é›†æˆ
```sql
-- Supabaseè®¤è¯ç”¨æˆ·ä¸ä¸šåŠ¡ç”¨æˆ·æ˜ å°„
ALTER TABLE users ADD COLUMN IF NOT EXISTS auth_user_id uuid UNIQUE;
ALTER TABLE users ADD COLUMN IF NOT EXISTS role VARCHAR(50) DEFAULT 'USER';

-- ç®¡ç†å‘˜æƒé™æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION public.is_admin() RETURNS boolean LANGUAGE sql STABLE AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.users u
    WHERE u.auth_user_id = auth.uid() AND u.role IN ('ADMIN', 'SUPER_ADMIN')
  );
$$;

-- è§’è‰²æƒé™æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION public.has_role(role_name TEXT) RETURNS boolean LANGUAGE sql STABLE AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.users u
    WHERE u.auth_user_id = auth.uid() AND u.role = role_name
  );
$$;
```

## ğŸ“Š æ•°æ®åº“æ¶æ„æ¼”è¿›

### MVPé˜¶æ®µï¼ˆæ¨¡å—åŒ–å•ä½“æ¶æ„ï¼‰
**æ—¶é—´èŒƒå›´**ï¼šé¡¹ç›®å¯åŠ¨-ç¬¬6ä¸ªæœˆ  
**æ¶æ„ç‰¹ç‚¹**ï¼š
- å•ä¸€PostgreSQLå®ä¾‹ï¼Œç®€åŒ–éƒ¨ç½²å’Œç»´æŠ¤
- æ¨¡å—åŒ–è¡¨è®¾è®¡ï¼ŒæŒ‰ä¸šåŠ¡åŸŸåˆ†ç»„ç®¡ç†
- åŸºç¡€RLSç­–ç•¥ï¼Œä¿éšœæ•°æ®å®‰å…¨
- æ ‡å‡†ç´¢å¼•ä¼˜åŒ–ï¼Œæ»¡è¶³åŸºæœ¬æ€§èƒ½éœ€æ±‚

**é€‚ç”¨åœºæ™¯**ï¼šå¿«é€ŸéªŒè¯ä¸šåŠ¡ï¼Œå°è§„æ¨¡ç”¨æˆ·å’Œæ•°æ®é‡  
**ä¼˜åŠ¿**ï¼šå¼€å‘ç®€å•ï¼Œè¿ç»´æˆæœ¬ä½ï¼Œå¿«é€Ÿä¸Šçº¿  
**é™åˆ¶**ï¼šå•ç‚¹æ•…éšœï¼Œæ€§èƒ½ç“¶é¢ˆï¼Œæ‰©å±•æ€§æœ‰é™

### æ‰©å±•é˜¶æ®µï¼ˆæ··åˆæ¶æ„ï¼‰
**æ—¶é—´èŒƒå›´**ï¼šç¬¬7-18ä¸ªæœˆ  
**æ¶æ„ç‰¹ç‚¹**ï¼š
- è¯»å†™åˆ†ç¦» + Redisç¼“å­˜å±‚
- åˆ†åŒºè¡¨ä¼˜åŒ–ï¼Œæå‡æŸ¥è¯¢æ€§èƒ½
- å¼ºåŒ–RLSç­–ç•¥ï¼Œæ”¯æŒç»„ç»‡æ¶æ„
- å¼•å…¥è¿æ¥æ± ï¼Œæé«˜å¹¶å‘å¤„ç†èƒ½åŠ›

**é€‚ç”¨åœºæ™¯**ï¼šç”¨æˆ·é‡å¢é•¿ï¼Œè¯»å¤šå†™å°‘åœºæ™¯  
**ä¼˜åŠ¿**ï¼šæé«˜è¯»å–æ€§èƒ½ï¼Œé™ä½ä¸»åº“å‹åŠ›  
**å®ç°æ–¹å¼**ï¼šä¸»ä»å¤åˆ¶ + è¯»å†™ä¸­é—´ä»¶ + è¿æ¥æ± 

### æˆç†ŸæœŸï¼ˆæ¨¡å—åŒ–æœåŠ¡æ¶æ„ï¼‰
**æ—¶é—´èŒƒå›´**ï¼šç¬¬19ä¸ªæœˆåŠä»¥å  
**æ¶æ„ç‰¹ç‚¹**ï¼š
- åˆ†åº“åˆ†è¡¨ + å¾®æœåŠ¡æ•°æ®åº“
- å¤šç§Ÿæˆ·æ¶æ„æ”¯æŒï¼Œæ•°æ®ç‰©ç†éš”ç¦»
- åˆ†å¸ƒå¼äº‹åŠ¡ï¼Œä¿è¯æ•°æ®ä¸€è‡´æ€§
- å®æ—¶æ•°æ®åŒæ­¥ï¼Œæ”¯æŒåˆ†æåœºæ™¯

**é€‚ç”¨åœºæ™¯**ï¼šå¤§è§„æ¨¡ç”¨æˆ·å’Œæ•°æ®é‡  
**ä¼˜åŠ¿**ï¼šæ°´å¹³æ‰©å±•ï¼Œé«˜å¯ç”¨ï¼Œæ€§èƒ½çº¿æ€§å¢é•¿  
**å®ç°æ–¹å¼**ï¼šæŒ‰ä¸šåŠ¡åŸŸåˆ†åº“ï¼ŒæŒ‰æ•°æ®ç‰¹å¾åˆ†è¡¨ï¼Œåˆ†å¸ƒå¼ç¼“å­˜

## ğŸ“Š æ ¸å¿ƒå®ä½“å…³ç³»å›¾

### å®ä½“å…³ç³»æ€»è§ˆ
```mermaid
erDiagram
    USERS ||--o{ LEADS : creates
    USERS ||--o{ SALES_ORDERS : manages
    USERS ||--o{ POINT_LOGS : earns
    USERS }o--o{ USER_ROLES : has
    ROLES ||--o{ USER_ROLES : assigned_to
    ROLES ||--o{ ROLE_PERMISSIONS : has
    PERMISSIONS ||--o{ ROLE_PERMISSIONS : assigned_to
    LEADS ||--o{ LEAD_FOLLOW_UPS : has
    LEADS ||--|| SALES_ORDERS : converts_to
    SALES_ORDERS ||--o{ ORDER_PRODUCTS : contains
    SALES_ORDERS ||--o{ ORDER_SERVICES : requires
    SALES_ORDERS ||--o{ ORDER_PAYMENTS : has
    SALES_ORDERS ||--o{ ORDER_STATUS_LOGS : tracks
    SALES_ORDERS }o--o{ SERVICE_PROVIDERS : assigned_to
    CUSTOMERS ||--o{ LEADS : has
    CUSTOMERS ||--o{ SALES_ORDERS : places
    CUSTOMERS ||--o{ CUSTOMER_ADDRESSES : has
    CUSTOMERS }o--o{ CUSTOMER_TAGS : tagged_with
    TAGS ||--o{ CUSTOMER_TAGS : assigned_to
    DEPARTMENTS ||--o{ USERS : contains
    SERVICE_PROVIDERS ||--o{ SERVICE_PROVIDER_TYPES : categorized_by
```

## ğŸ‘¥ ç”¨æˆ·ç®¡ç†æ¨¡å—

### ç”¨æˆ·è¡¨ï¼ˆusersï¼‰
```sql
CREATE TABLE users (
  id BIGSERIAL PRIMARY KEY,
  username VARCHAR(50) NOT NULL UNIQUE,
  password VARCHAR(255) NOT NULL,
  nickname VARCHAR(50) NOT NULL,
  email VARCHAR(100) UNIQUE,
  phone VARCHAR(15) UNIQUE,
  avatar VARCHAR(500),
  department_id BIGINT REFERENCES departments(id),
  status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive')),
  last_login_time TIMESTAMP,
  last_login_ip VARCHAR(50),
  login_count INTEGER NOT NULL DEFAULT 0,
  created_by BIGINT REFERENCES users(id),
  updated_by BIGINT REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  deleted_at TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_users_department_id ON users(department_id);
CREATE INDEX idx_users_status ON users(status);
CREATE INDEX idx_users_created_at ON users(created_at);
CREATE INDEX idx_users_deleted_at ON users(deleted_at);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE users IS 'ç”¨æˆ·è¡¨';
COMMENT ON COLUMN users.id IS 'ç”¨æˆ·ID';
COMMENT ON COLUMN users.username IS 'ç”¨æˆ·å';
COMMENT ON COLUMN users.password IS 'å¯†ç ï¼ˆåŠ å¯†å­˜å‚¨ï¼‰';
COMMENT ON COLUMN users.nickname IS 'å§“å';
COMMENT ON COLUMN users.email IS 'é‚®ç®±';
COMMENT ON COLUMN users.phone IS 'æ‰‹æœºå·';
COMMENT ON COLUMN users.avatar IS 'å¤´åƒURL';
COMMENT ON COLUMN users.department_id IS 'éƒ¨é—¨ID';
COMMENT ON COLUMN users.status IS 'çŠ¶æ€ï¼šactive,inactive';
COMMENT ON COLUMN users.last_login_time IS 'æœ€åç™»å½•æ—¶é—´';
COMMENT ON COLUMN users.last_login_ip IS 'æœ€åç™»å½•IP';
COMMENT ON COLUMN users.login_count IS 'ç™»å½•æ¬¡æ•°';
COMMENT ON COLUMN users.created_by IS 'åˆ›å»ºäººID';
COMMENT ON COLUMN users.updated_by IS 'æ›´æ–°äººID';
COMMENT ON COLUMN users.created_at IS 'åˆ›å»ºæ—¶é—´';
COMMENT ON COLUMN users.updated_at IS 'æ›´æ–°æ—¶é—´';
COMMENT ON COLUMN users.deleted_at IS 'åˆ é™¤æ—¶é—´ï¼ˆè½¯åˆ é™¤ï¼‰';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### éƒ¨é—¨è¡¨ï¼ˆdepartmentsï¼‰
```sql
CREATE TABLE departments (
  id BIGSERIAL PRIMARY KEY,
  name VARCHAR(50) NOT NULL,
  code VARCHAR(50) NOT NULL UNIQUE,
  parent_id BIGINT DEFAULT 0 REFERENCES departments(id),
  manager_id BIGINT REFERENCES users(id),
  sort INTEGER NOT NULL DEFAULT 0,
  status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive')),
  description TEXT,
  created_by BIGINT REFERENCES users(id),
  updated_by BIGINT REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_departments_parent_id ON departments(parent_id);
CREATE INDEX idx_departments_manager_id ON departments(manager_id);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE departments IS 'éƒ¨é—¨è¡¨';
COMMENT ON COLUMN departments.id IS 'éƒ¨é—¨ID';
COMMENT ON COLUMN departments.name IS 'éƒ¨é—¨åç§°';
COMMENT ON COLUMN departments.code IS 'éƒ¨é—¨ç¼–ç ';
COMMENT ON COLUMN departments.parent_id IS 'çˆ¶éƒ¨é—¨ID';
COMMENT ON COLUMN departments.manager_id IS 'éƒ¨é—¨è´Ÿè´£äººID';
COMMENT ON COLUMN departments.sort IS 'æ’åº';
COMMENT ON COLUMN departments.status IS 'çŠ¶æ€ï¼šactive,inactive';
COMMENT ON COLUMN departments.description IS 'æè¿°';
COMMENT ON COLUMN departments.created_by IS 'åˆ›å»ºäººID';
COMMENT ON COLUMN departments.updated_by IS 'æ›´æ–°äººID';
COMMENT ON COLUMN departments.created_at IS 'åˆ›å»ºæ—¶é—´';
COMMENT ON COLUMN departments.updated_at IS 'æ›´æ–°æ—¶é—´';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_departments_updated_at BEFORE UPDATE ON departments
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### è§’è‰²è¡¨ï¼ˆrolesï¼‰
```sql
CREATE TABLE roles (
  id BIGSERIAL PRIMARY KEY,
  name VARCHAR(50) NOT NULL,
  code VARCHAR(50) NOT NULL UNIQUE,
  description TEXT,
  status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive')),
  created_by BIGINT REFERENCES users(id),
  updated_by BIGINT REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_roles_status ON roles(status);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE roles IS 'è§’è‰²è¡¨';
COMMENT ON COLUMN roles.id IS 'è§’è‰²ID';
COMMENT ON COLUMN roles.name IS 'è§’è‰²åç§°';
COMMENT ON COLUMN roles.code IS 'è§’è‰²ç¼–ç ';
COMMENT ON COLUMN roles.description IS 'æè¿°';
COMMENT ON COLUMN roles.status IS 'çŠ¶æ€ï¼šactive,inactive';
COMMENT ON COLUMN roles.created_by IS 'åˆ›å»ºäººID';
COMMENT ON COLUMN roles.updated_by IS 'æ›´æ–°äººID';
COMMENT ON COLUMN roles.created_at IS 'åˆ›å»ºæ—¶é—´';
COMMENT ON COLUMN roles.updated_at IS 'æ›´æ–°æ—¶é—´';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_roles_updated_at BEFORE UPDATE ON roles
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### æƒé™è¡¨ï¼ˆpermissionsï¼‰
```sql
CREATE TABLE permissions (
  id BIGSERIAL PRIMARY KEY,
  name VARCHAR(50) NOT NULL,
  code VARCHAR(100) NOT NULL UNIQUE,
  module VARCHAR(50) NOT NULL,
  action VARCHAR(50) NOT NULL,
  description TEXT,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_permissions_module ON permissions(module);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE permissions IS 'æƒé™è¡¨';
COMMENT ON COLUMN permissions.id IS 'æƒé™ID';
COMMENT ON COLUMN permissions.name IS 'æƒé™åç§°';
COMMENT ON COLUMN permissions.code IS 'æƒé™ç¼–ç ';
COMMENT ON COLUMN permissions.module IS 'æ‰€å±æ¨¡å—';
COMMENT ON COLUMN permissions.action IS 'æ“ä½œç±»å‹';
COMMENT ON COLUMN permissions.description IS 'æè¿°';
COMMENT ON COLUMN permissions.created_at IS 'åˆ›å»ºæ—¶é—´';
COMMENT ON COLUMN permissions.updated_at IS 'æ›´æ–°æ—¶é—´';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_permissions_updated_at BEFORE UPDATE ON permissions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### ç”¨æˆ·è§’è‰²å…³è”è¡¨ï¼ˆuser_rolesï¼‰
```sql
CREATE TABLE user_roles (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  role_id BIGINT NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(user_id, role_id)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_user_roles_user_id ON user_roles(user_id);
CREATE INDEX idx_user_roles_role_id ON user_roles(role_id);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE user_roles IS 'ç”¨æˆ·è§’è‰²å…³è”è¡¨';
COMMENT ON COLUMN user_roles.id IS 'å…³è”ID';
COMMENT ON COLUMN user_roles.user_id IS 'ç”¨æˆ·ID';
COMMENT ON COLUMN user_roles.role_id IS 'è§’è‰²ID';
COMMENT ON COLUMN user_roles.created_at IS 'åˆ›å»ºæ—¶é—´';
```

### è§’è‰²æƒé™å…³è”è¡¨ï¼ˆrole_permissionsï¼‰
```sql
CREATE TABLE role_permissions (
  id BIGSERIAL PRIMARY KEY,
  role_id BIGINT NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
  permission_id BIGINT NOT NULL REFERENCES permissions(id) ON DELETE CASCADE,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(role_id, permission_id)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_role_permissions_role_id ON role_permissions(role_id);
CREATE INDEX idx_role_permissions_permission_id ON role_permissions(permission_id);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE role_permissions IS 'è§’è‰²æƒé™å…³è”è¡¨';
COMMENT ON COLUMN role_permissions.id IS 'å…³è”ID';
COMMENT ON COLUMN role_permissions.role_id IS 'è§’è‰²ID';
COMMENT ON COLUMN role_permissions.permission_id IS 'æƒé™ID';
COMMENT ON COLUMN role_permissions.created_at IS 'åˆ›å»ºæ—¶é—´';
```

## ğŸ“‹ çº¿ç´¢ç®¡ç†æ¨¡å—

### çº¿ç´¢è¡¨ï¼ˆleadsï¼‰
```sql
CREATE TABLE leads (
  id BIGSERIAL PRIMARY KEY,
  lead_no VARCHAR(20) NOT NULL UNIQUE DEFAULT generate_business_number('lead'),
  customer_name VARCHAR(50) NOT NULL,
  customer_phone VARCHAR(15) NOT NULL,
  customer_address TEXT,
  customer_city VARCHAR(50),
  customer_district VARCHAR(50),
  status VARCHAR(20) NOT NULL DEFAULT 'new' CHECK (status IN ('new', 'assigned', 'following', 'converted', 'invalid')),
  source VARCHAR(20) NOT NULL CHECK (source IN ('wechat', 'website', 'referral', 'offline')),
  intention VARCHAR(20) CHECK (intention IN ('strong', 'medium', 'weak')),
  budget DECIMAL(10,2) CHECK (budget >= 0),
  requirement TEXT,
  assigned_to BIGINT REFERENCES users(id),
  created_by BIGINT NOT NULL REFERENCES users(id),
  next_follow_time TIMESTAMP,
  follow_count INTEGER NOT NULL DEFAULT 0,
  last_follow_time TIMESTAMP,
  remark TEXT,
  converted_at TIMESTAMP,
  converted_to_order_id BIGINT REFERENCES sales_orders(id),
  lost_reason VARCHAR(500),
  lost_at TIMESTAMP,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  deleted_at TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_leads_customer_phone ON leads(customer_phone);
CREATE INDEX idx_leads_status ON leads(status);
CREATE INDEX idx_leads_source ON leads(source);
CREATE INDEX idx_leads_assigned_to ON leads(assigned_to);
CREATE INDEX idx_leads_created_by ON leads(created_by);
CREATE INDEX idx_leads_next_follow_time ON leads(next_follow_time);
CREATE INDEX idx_leads_created_at ON leads(created_at);
CREATE INDEX idx_leads_deleted_at ON leads(deleted_at);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE leads IS 'çº¿ç´¢è¡¨';
COMMENT ON COLUMN leads.id IS 'çº¿ç´¢ID';
COMMENT ON COLUMN leads.lead_no IS 'çº¿ç´¢ç¼–å·';
COMMENT ON COLUMN leads.customer_name IS 'å®¢æˆ·å§“å';
COMMENT ON COLUMN leads.customer_phone IS 'å®¢æˆ·æ‰‹æœºå·';
COMMENT ON COLUMN leads.customer_address IS 'å®¢æˆ·åœ°å€';
COMMENT ON COLUMN leads.customer_city IS 'å®¢æˆ·åŸå¸‚';
COMMENT ON COLUMN leads.customer_district IS 'å®¢æˆ·åŒºåŸŸ';
COMMENT ON COLUMN leads.status IS 'çŠ¶æ€ï¼šnew(æ–°å»º),assigned(å·²åˆ†é…),following(è·Ÿè¿›ä¸­),converted(å·²è½¬åŒ–),invalid(å·²å¤±æ•ˆ)';
COMMENT ON COLUMN leads.source IS 'æ¥æºï¼šwechat,website,referral,offline';
COMMENT ON COLUMN leads.intention IS 'æ„å‘ï¼šstrong,medium,weak';
COMMENT ON COLUMN leads.budget IS 'é¢„ç®—';
COMMENT ON COLUMN leads.requirement IS 'éœ€æ±‚æè¿°';
COMMENT ON COLUMN leads.assigned_to IS 'åˆ†é…ç»™çš„ç”¨æˆ·ID';
COMMENT ON COLUMN leads.created_by IS 'åˆ›å»ºäººID';
COMMENT ON COLUMN leads.next_follow_time IS 'ä¸‹æ¬¡è·Ÿè¿›æ—¶é—´';
COMMENT ON COLUMN leads.follow_count IS 'è·Ÿè¿›æ¬¡æ•°';
COMMENT ON COLUMN leads.last_follow_time IS 'æœ€åè·Ÿè¿›æ—¶é—´';
COMMENT ON COLUMN leads.remark IS 'å¤‡æ³¨';
COMMENT ON COLUMN leads.converted_at IS 'è½¬åŒ–æ—¶é—´';
COMMENT ON COLUMN leads.converted_to_order_id IS 'è½¬åŒ–æˆçš„è®¢å•ID';
COMMENT ON COLUMN leads.lost_reason IS 'æµå¤±åŸå› ';
COMMENT ON COLUMN leads.lost_at IS 'æµå¤±æ—¶é—´';
COMMENT ON COLUMN leads.created_at IS 'åˆ›å»ºæ—¶é—´';
COMMENT ON COLUMN leads.updated_at IS 'æ›´æ–°æ—¶é—´';
COMMENT ON COLUMN leads.deleted_at IS 'åˆ é™¤æ—¶é—´ï¼ˆè½¯åˆ é™¤ï¼‰';

-- æ·»åŠ ä¸šåŠ¡é€»è¾‘éªŒè¯çº¦æŸ
ALTER TABLE leads ADD CONSTRAINT chk_leads_budget_positive
  CHECK (budget IS NULL OR budget > 0);

ALTER TABLE leads ADD CONSTRAINT chk_leads_follow_count_non_negative
  CHECK (follow_count >= 0);

ALTER TABLE leads ADD CONSTRAINT chk_leads_conversion_logic
  CHECK (
    (status = 'converted' AND converted_at IS NOT NULL AND converted_to_order_id IS NOT NULL) OR
    (status != 'converted' AND converted_at IS NULL AND converted_to_order_id IS NULL)
  );

ALTER TABLE leads ADD CONSTRAINT chk_leads_lost_logic
  CHECK (
    (status = 'invalid' AND lost_reason IS NOT NULL AND lost_at IS NOT NULL) OR
    (status != 'invalid' AND lost_reason IS NULL AND lost_at IS NULL)
  );

ALTER TABLE leads ADD CONSTRAINT chk_leads_follow_time_logic
  CHECK (last_follow_time IS NULL OR next_follow_time IS NULL OR next_follow_time >= last_follow_time);

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_leads_updated_at BEFORE UPDATE ON leads
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### çº¿ç´¢è·Ÿè¿›è®°å½•è¡¨ï¼ˆlead_follow_upsï¼‰
```sql
CREATE TABLE lead_follow_ups (
  id BIGSERIAL PRIMARY KEY,
  lead_id BIGINT NOT NULL REFERENCES leads(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  type VARCHAR(20) NOT NULL CHECK (type IN ('phone', 'wechat', 'visit', 'message')),
  next_follow_time TIMESTAMP,
  attachment_urls JSONB,
  created_by BIGINT NOT NULL REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_lead_follow_ups_lead_id ON lead_follow_ups(lead_id);
CREATE INDEX idx_lead_follow_ups_created_by ON lead_follow_ups(created_by);
CREATE INDEX idx_lead_follow_ups_next_follow_time ON lead_follow_ups(next_follow_time);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE lead_follow_ups IS 'çº¿ç´¢è·Ÿè¿›è®°å½•è¡¨';
COMMENT ON COLUMN lead_follow_ups.id IS 'è·Ÿè¿›è®°å½•ID';
COMMENT ON COLUMN lead_follow_ups.lead_id IS 'çº¿ç´¢ID';
COMMENT ON COLUMN lead_follow_ups.content IS 'è·Ÿè¿›å†…å®¹';
COMMENT ON COLUMN lead_follow_ups.type IS 'è·Ÿè¿›æ–¹å¼ï¼šphone,wechat,visit,message';
COMMENT ON COLUMN lead_follow_ups.next_follow_time IS 'ä¸‹æ¬¡è·Ÿè¿›æ—¶é—´';
COMMENT ON COLUMN lead_follow_ups.attachment_urls IS 'é™„ä»¶URLæ•°ç»„';
COMMENT ON COLUMN lead_follow_ups.created_by IS 'åˆ›å»ºäººID';
COMMENT ON COLUMN lead_follow_ups.created_at IS 'åˆ›å»ºæ—¶é—´';
```

### çº¿ç´¢æ ‡ç­¾å…³è”è¡¨ï¼ˆlead_tagsï¼‰
```sql
CREATE TABLE lead_tags (
  id BIGSERIAL PRIMARY KEY,
  lead_id BIGINT NOT NULL REFERENCES leads(id) ON DELETE CASCADE,
  tag_id BIGINT NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(lead_id, tag_id)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_lead_tags_lead_id ON lead_tags(lead_id);
CREATE INDEX idx_lead_tags_tag_id ON lead_tags(tag_id);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE lead_tags IS 'çº¿ç´¢æ ‡ç­¾å…³è”è¡¨';
COMMENT ON COLUMN lead_tags.id IS 'å…³è”ID';
COMMENT ON COLUMN lead_tags.lead_id IS 'çº¿ç´¢ID';
COMMENT ON COLUMN lead_tags.tag_id IS 'æ ‡ç­¾ID';
COMMENT ON COLUMN lead_tags.created_at IS 'åˆ›å»ºæ—¶é—´';
```

### é¢„æŠ¥ä»·è¡¨ï¼ˆlead_quotesï¼‰
```sql
CREATE TABLE lead_quotes (
  id BIGSERIAL PRIMARY KEY,
  lead_id BIGINT NOT NULL REFERENCES leads(id) ON DELETE CASCADE,
  quote_no VARCHAR(50) NOT NULL UNIQUE,
  file_name VARCHAR(255) NOT NULL,
  file_path VARCHAR(500) NOT NULL,
  file_size INTEGER NOT NULL,
  total_amount DECIMAL(10,2) CHECK (total_amount >= 0),
  product_count INTEGER DEFAULT 0,
  quoted_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  expires_at TIMESTAMP NOT NULL,
  is_expired BOOLEAN NOT NULL DEFAULT FALSE,
  needs_maintenance BOOLEAN NOT NULL DEFAULT FALSE,
  maintenance_added_at TIMESTAMP,
  created_by BIGINT NOT NULL REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_lead_quotes_lead_id ON lead_quotes(lead_id);
CREATE INDEX idx_lead_quotes_quote_no ON lead_quotes(quote_no);
CREATE INDEX idx_lead_quotes_expires_at ON lead_quotes(expires_at);
CREATE INDEX idx_lead_quotes_needs_maintenance ON lead_quotes(needs_maintenance);
CREATE INDEX idx_lead_quotes_created_by ON lead_quotes(created_by);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE lead_quotes IS 'çº¿ç´¢é¢„æŠ¥ä»·è¡¨';
COMMENT ON COLUMN lead_quotes.id IS 'é¢„æŠ¥ä»·ID';
COMMENT ON COLUMN lead_quotes.lead_id IS 'çº¿ç´¢ID';
COMMENT ON COLUMN lead_quotes.quote_no IS 'é¢„æŠ¥ä»·ç¼–å·';
COMMENT ON COLUMN lead_quotes.file_name IS 'ä¸Šä¼ æ–‡ä»¶å';
COMMENT ON COLUMN lead_quotes.file_path IS 'æ–‡ä»¶å­˜å‚¨è·¯å¾„';
COMMENT ON COLUMN lead_quotes.file_size IS 'æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰';
COMMENT ON COLUMN lead_quotes.total_amount IS 'é¢„æŠ¥ä»·æ€»é‡‘é¢';
COMMENT ON COLUMN lead_quotes.product_count IS 'äº§å“æ•°é‡';
COMMENT ON COLUMN lead_quotes.quoted_at IS 'æŠ¥ä»·æ—¶é—´';
COMMENT ON COLUMN lead_quotes.expires_at IS 'è¿‡æœŸæ—¶é—´ï¼ˆ90å¤©åï¼‰';
COMMENT ON COLUMN lead_quotes.is_expired IS 'æ˜¯å¦å·²è¿‡æœŸ';
COMMENT ON COLUMN lead_quotes.needs_maintenance IS 'æ˜¯å¦éœ€è¦ç»´æŠ¤ï¼ˆ10å¤©åè‡ªåŠ¨æ ‡è®°ï¼‰';
COMMENT ON COLUMN lead_quotes.maintenance_added_at IS 'æ·»åŠ ç»´æŠ¤æ ‡è®°æ—¶é—´';
COMMENT ON COLUMN lead_quotes.created_by IS 'åˆ›å»ºäººID';
COMMENT ON COLUMN lead_quotes.created_at IS 'åˆ›å»ºæ—¶é—´';
COMMENT ON COLUMN lead_quotes.updated_at IS 'æ›´æ–°æ—¶é—´';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_lead_quotes_updated_at BEFORE UPDATE ON lead_quotes
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### é¢„æŠ¥ä»·æ˜ç»†è¡¨ï¼ˆlead_quote_itemsï¼‰
```sql
CREATE TABLE lead_quote_items (
  id BIGSERIAL PRIMARY KEY,
  quote_id BIGINT NOT NULL REFERENCES lead_quotes(id) ON DELETE CASCADE,
  product_category VARCHAR(50) NOT NULL,
  product_name VARCHAR(100) NOT NULL,
  specifications VARCHAR(200),
  quantity DECIMAL(10,2) NOT NULL CHECK (quantity >= 0),
  unit VARCHAR(20),
  unit_price DECIMAL(10,2) NOT NULL CHECK (unit_price >= 0),
  total_price DECIMAL(10,2) NOT NULL CHECK (total_price >= 0),
  discount_rate DECIMAL(5,2) DEFAULT 0.00 CHECK (discount_rate >= 0 AND discount_rate <= 100),
  discount_amount DECIMAL(10,2) DEFAULT 0.00 CHECK (discount_amount >= 0),
  final_price DECIMAL(10,2) NOT NULL CHECK (final_price >= 0),
  remark TEXT,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_lead_quote_items_quote_id ON lead_quote_items(quote_id);
CREATE INDEX idx_lead_quote_items_category ON lead_quote_items(product_category);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE lead_quote_items IS 'é¢„æŠ¥ä»·æ˜ç»†è¡¨';
COMMENT ON COLUMN lead_quote_items.id IS 'æ˜ç»†ID';
COMMENT ON COLUMN lead_quote_items.quote_id IS 'é¢„æŠ¥ä»·ID';
COMMENT ON COLUMN lead_quote_items.product_category IS 'äº§å“ç±»åˆ«';
COMMENT ON COLUMN lead_quote_items.product_name IS 'äº§å“åç§°';
COMMENT ON COLUMN lead_quote_items.specifications IS 'è§„æ ¼å‹å·';
COMMENT ON COLUMN lead_quote_items.quantity IS 'æ•°é‡';
COMMENT ON COLUMN lead_quote_items.unit IS 'å•ä½';
COMMENT ON COLUMN lead_quote_items.unit_price IS 'å•ä»·';
COMMENT ON COLUMN lead_quote_items.total_price IS 'å°è®¡';
COMMENT ON COLUMN lead_quote_items.discount_rate IS 'æŠ˜æ‰£ç‡';
COMMENT ON COLUMN lead_quote_items.discount_amount IS 'æŠ˜æ‰£é‡‘é¢';
COMMENT ON COLUMN lead_quote_items.final_price IS 'æœ€ç»ˆä»·æ ¼';
COMMENT ON COLUMN lead_quote_items.remark IS 'å¤‡æ³¨';
COMMENT ON COLUMN lead_quote_items.created_at IS 'åˆ›å»ºæ—¶é—´';
```

### çº¿ç´¢çŠ¶æ€å˜æ›´æ—¥å¿—è¡¨ï¼ˆlead_status_logsï¼‰
```sql
CREATE TABLE lead_status_logs (
  id BIGSERIAL PRIMARY KEY,
  lead_id BIGINT NOT NULL REFERENCES leads(id) ON DELETE CASCADE,
  previous_status VARCHAR(20),
  current_status VARCHAR(20) NOT NULL,
  change_reason VARCHAR(200),
  operator_id BIGINT NOT NULL REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_lead_status_logs_lead_id ON lead_status_logs(lead_id);
CREATE INDEX idx_lead_status_logs_operator_id ON lead_status_logs(operator_id);
CREATE INDEX idx_lead_status_logs_created_at ON lead_status_logs(created_at);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE lead_status_logs IS 'çº¿ç´¢çŠ¶æ€å˜æ›´æ—¥å¿—è¡¨';
COMMENT ON COLUMN lead_status_logs.id IS 'æ—¥å¿—ID';
COMMENT ON COLUMN lead_status_logs.lead_id IS 'çº¿ç´¢ID';
COMMENT ON COLUMN lead_status_logs.previous_status IS 'å˜æ›´å‰çŠ¶æ€';
COMMENT ON COLUMN lead_status_logs.current_status IS 'å˜æ›´åçŠ¶æ€';
COMMENT ON COLUMN lead_status_logs.change_reason IS 'å˜æ›´åŸå› ';
COMMENT ON COLUMN lead_status_logs.operator_id IS 'æ“ä½œäººID';
COMMENT ON COLUMN lead_status_logs.created_at IS 'åˆ›å»ºæ—¶é—´';
```

## ğŸ“¦ é”€å”®å•ç®¡ç†æ¨¡å—

### é”€å”®è®¢å•è¡¨ï¼ˆsales_ordersï¼‰
```sql
CREATE TABLE sales_orders (
  id BIGSERIAL PRIMARY KEY,
  order_no VARCHAR(20) NOT NULL UNIQUE DEFAULT generate_business_number('order'),
  customer_name VARCHAR(50) NOT NULL,
  customer_phone VARCHAR(15) NOT NULL,
  customer_address TEXT,
  customer_id BIGINT REFERENCES customers(id),
  lead_id BIGINT REFERENCES leads(id),
  status VARCHAR(50) NOT NULL DEFAULT 'INITIAL',
  total_amount DECIMAL(10,2) NOT NULL DEFAULT 0.00 CHECK (total_amount >= 0),
  paid_amount DECIMAL(10,2) NOT NULL DEFAULT 0.00 CHECK (paid_amount >= 0),
  sales_id BIGINT NOT NULL REFERENCES users(id),
  measure_provider_id BIGINT REFERENCES providers(id),
  install_provider_id BIGINT REFERENCES providers(id),
  expected_install_date DATE,
  actual_install_date DATE,
  remark TEXT,
  created_by BIGINT NOT NULL REFERENCES users(id),
  updated_by BIGINT REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  deleted_at TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_sales_orders_customer_phone ON sales_orders(customer_phone);
CREATE INDEX idx_sales_orders_status ON sales_orders(status);
CREATE INDEX idx_sales_orders_sales_id ON sales_orders(sales_id);
CREATE INDEX idx_sales_orders_lead_id ON sales_orders(lead_id);
CREATE INDEX idx_sales_orders_created_at ON sales_orders(created_at);
CREATE INDEX idx_sales_orders_deleted_at ON sales_orders(deleted_at);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE sales_orders IS 'é”€å”®è®¢å•è¡¨';
COMMENT ON COLUMN sales_orders.id IS 'è®¢å•ID';
COMMENT ON COLUMN sales_orders.order_no IS 'è®¢å•ç¼–å·';
COMMENT ON COLUMN sales_orders.customer_name IS 'å®¢æˆ·å§“å';
COMMENT ON COLUMN sales_orders.customer_phone IS 'å®¢æˆ·æ‰‹æœºå·';
COMMENT ON COLUMN sales_orders.customer_address IS 'å®¢æˆ·åœ°å€';
COMMENT ON COLUMN sales_orders.customer_id IS 'å®¢æˆ·ID';
COMMENT ON COLUMN sales_orders.lead_id IS 'å…³è”çº¿ç´¢ID';
COMMENT ON COLUMN sales_orders.status IS 'çŠ¶æ€';
COMMENT ON COLUMN sales_orders.total_amount IS 'è®¢å•æ€»é‡‘é¢';
COMMENT ON COLUMN sales_orders.paid_amount IS 'å·²æ”¯ä»˜é‡‘é¢';
COMMENT ON COLUMN sales_orders.sales_id IS 'é”€å”®å‘˜ID';
COMMENT ON COLUMN sales_orders.measure_provider_id IS 'æµ‹é‡æœåŠ¡å•†ID';
COMMENT ON COLUMN sales_orders.install_provider_id IS 'å®‰è£…æœåŠ¡å•†ID';
COMMENT ON COLUMN sales_orders.expected_install_date IS 'æœŸæœ›å®‰è£…æ—¥æœŸ';
COMMENT ON COLUMN sales_orders.actual_install_date IS 'å®é™…å®‰è£…æ—¥æœŸ';
COMMENT ON COLUMN sales_orders.remark IS 'å¤‡æ³¨';
COMMENT ON COLUMN sales_orders.created_by IS 'åˆ›å»ºäººID';
COMMENT ON COLUMN sales_orders.updated_by IS 'æ›´æ–°äººID';
COMMENT ON COLUMN sales_orders.created_at IS 'åˆ›å»ºæ—¶é—´';
COMMENT ON COLUMN sales_orders.updated_at IS 'æ›´æ–°æ—¶é—´';
COMMENT ON COLUMN sales_orders.deleted_at IS 'åˆ é™¤æ—¶é—´ï¼ˆè½¯åˆ é™¤ï¼‰';

-- æ·»åŠ ä¸šåŠ¡é€»è¾‘éªŒè¯çº¦æŸ
ALTER TABLE sales_orders ADD CONSTRAINT chk_sales_orders_paid_amount_not_exceed_total
  CHECK (paid_amount <= total_amount);

ALTER TABLE sales_orders ADD CONSTRAINT chk_sales_orders_install_date_logic
  CHECK (actual_install_date IS NULL OR expected_install_date IS NULL OR actual_install_date >= expected_install_date - INTERVAL '30 days');

ALTER TABLE sales_orders ADD CONSTRAINT chk_sales_orders_status_values
  CHECK (status IN ('INITIAL', 'CONFIRMED', 'MEASURING', 'MEASURED', 'QUOTED', 'PAID', 'PRODUCING', 'PRODUCED', 'DELIVERING', 'DELIVERED', 'INSTALLING', 'INSTALLED', 'COMPLETED', 'CANCELLED'));

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_sales_orders_updated_at BEFORE UPDATE ON sales_orders
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### é”€å”®å•äº§å“è¡¨ï¼ˆorder_productsï¼‰
```sql
CREATE TABLE order_products (
  id BIGSERIAL PRIMARY KEY,
  order_id BIGINT NOT NULL REFERENCES sales_orders(id) ON DELETE CASCADE,
  category VARCHAR(50) NOT NULL,
  product_name VARCHAR(100) NOT NULL,
  specifications VARCHAR(200) NOT NULL,
  quantity INTEGER NOT NULL CHECK (quantity >= 0),
  unit_price DECIMAL(10,2) NOT NULL CHECK (unit_price >= 0),
  total_price DECIMAL(10,2) NOT NULL CHECK (total_price >= 0),
  remarks TEXT,
  sort INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_order_products_order_id ON order_products(order_id);
CREATE INDEX idx_order_products_category ON order_products(category);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE order_products IS 'é”€å”®å•äº§å“è¡¨';
COMMENT ON COLUMN order_products.id IS 'é”€å”®å•äº§å“ID';
COMMENT ON COLUMN order_products.order_id IS 'é”€å”®å•ID';
COMMENT ON COLUMN order_products.category IS 'äº§å“ç±»åˆ«';
COMMENT ON COLUMN order_products.product_name IS 'äº§å“åç§°';
COMMENT ON COLUMN order_products.specifications IS 'è§„æ ¼';
COMMENT ON COLUMN order_products.quantity IS 'æ•°é‡';
COMMENT ON COLUMN order_products.unit_price IS 'å•ä»·';
COMMENT ON COLUMN order_products.total_price IS 'æ€»ä»·';
COMMENT ON COLUMN order_products.remarks IS 'å¤‡æ³¨';
COMMENT ON COLUMN order_products.sort IS 'æ’åº';
COMMENT ON COLUMN order_products.created_at IS 'åˆ›å»ºæ—¶é—´';
COMMENT ON COLUMN order_products.updated_at IS 'æ›´æ–°æ—¶é—´';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_order_products_updated_at BEFORE UPDATE ON order_products
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### é”€å”®å•æœåŠ¡è¡¨ï¼ˆorder_servicesï¼‰
```sql
CREATE TABLE order_services (
  id BIGSERIAL PRIMARY KEY,
  order_id BIGINT NOT NULL REFERENCES sales_orders(id) ON DELETE CASCADE,
  service_type VARCHAR(50) NOT NULL CHECK (service_type IN ('measure', 'install')),
  provider_id BIGINT NOT NULL REFERENCES providers(id),
  provider_name VARCHAR(100),
  scheduled_time TIMESTAMP,
  actual_time TIMESTAMP,
  status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'assigned', 'completed', 'cancelled')),
  fee DECIMAL(10,2) NOT NULL DEFAULT 0.00 CHECK (fee >= 0),
  remark TEXT,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_order_services_order_id ON order_services(order_id);
CREATE INDEX idx_order_services_service_type ON order_services(service_type);
CREATE INDEX idx_order_services_provider_id ON order_services(provider_id);
CREATE INDEX idx_order_services_status ON order_services(status);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE order_services IS 'é”€å”®å•æœåŠ¡è¡¨';
COMMENT ON COLUMN order_services.id IS 'é”€å”®å•æœåŠ¡ID';
COMMENT ON COLUMN order_services.order_id IS 'é”€å”®å•ID';
COMMENT ON COLUMN order_services.service_type IS 'æœåŠ¡ç±»å‹ï¼šmeasure,install';
COMMENT ON COLUMN order_services.provider_id IS 'æœåŠ¡å•†ID';
COMMENT ON COLUMN order_services.provider_name IS 'æœåŠ¡å•†åç§°';
COMMENT ON COLUMN order_services.scheduled_time IS 'é¢„çº¦æ—¶é—´';
COMMENT ON COLUMN order_services.actual_time IS 'å®é™…å®Œæˆæ—¶é—´';
COMMENT ON COLUMN order_services.status IS 'çŠ¶æ€ï¼špending,assigned,completed,cancelled';
COMMENT ON COLUMN order_services.fee IS 'æœåŠ¡è´¹ç”¨';
COMMENT ON COLUMN order_services.remark IS 'å¤‡æ³¨';
COMMENT ON COLUMN order_services.created_at IS 'åˆ›å»ºæ—¶é—´';
COMMENT ON COLUMN order_services.updated_at IS 'æ›´æ–°æ—¶é—´';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_order_services_updated_at BEFORE UPDATE ON order_services
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### é”€å”®å•æ”¯ä»˜è®°å½•è¡¨ï¼ˆorder_paymentsï¼‰
```sql
CREATE TABLE order_payments (
  id BIGSERIAL PRIMARY KEY,
  payment_no VARCHAR(50) NOT NULL UNIQUE,
  order_id BIGINT NOT NULL REFERENCES sales_orders(id),
  amount DECIMAL(10,2) NOT NULL CHECK (amount > 0),
  payment_method VARCHAR(20) NOT NULL CHECK (payment_method IN ('wechat', 'alipay', 'bank', 'cash')),
  status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'success', 'failed', 'cancelled')),
  paid_at TIMESTAMP,
  transaction_id VARCHAR(100),
  remark TEXT,
  created_by BIGINT NOT NULL REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_order_payments_order_id ON order_payments(order_id);
CREATE INDEX idx_order_payments_payment_method ON order_payments(payment_method);
CREATE INDEX idx_order_payments_status ON order_payments(status);
CREATE INDEX idx_order_payments_paid_at ON order_payments(paid_at);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE order_payments IS 'é”€å”®å•æ”¯ä»˜è®°å½•è¡¨';
COMMENT ON COLUMN order_payments.id IS 'æ”¯ä»˜è®°å½•ID';
COMMENT ON COLUMN order_payments.payment_no IS 'æ”¯ä»˜ç¼–å·';
COMMENT ON COLUMN order_payments.order_id IS 'é”€å”®å•ID';
COMMENT ON COLUMN order_payments.amount IS 'æ”¯ä»˜é‡‘é¢';
COMMENT ON COLUMN order_payments.payment_method IS 'æ”¯ä»˜æ–¹å¼ï¼šwechat,alipay,bank,cash';
COMMENT ON COLUMN order_payments.status IS 'çŠ¶æ€ï¼špending,success,failed,cancelled';
COMMENT ON COLUMN order_payments.paid_at IS 'æ”¯ä»˜æ—¶é—´';
COMMENT ON COLUMN order_payments.transaction_id IS 'ç¬¬ä¸‰æ–¹äº¤æ˜“ID';
COMMENT ON COLUMN order_payments.remark IS 'å¤‡æ³¨';
COMMENT ON COLUMN order_payments.created_by IS 'åˆ›å»ºäººID';
COMMENT ON COLUMN order_payments.created_at IS 'åˆ›å»ºæ—¶é—´';
COMMENT ON COLUMN order_payments.updated_at IS 'æ›´æ–°æ—¶é—´';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_order_payments_updated_at BEFORE UPDATE ON order_payments
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### é”€å”®å•çŠ¶æ€å˜æ›´æ—¥å¿—è¡¨ï¼ˆorder_status_logsï¼‰
```sql
CREATE TABLE order_status_logs (
  id BIGSERIAL PRIMARY KEY,
  order_id BIGINT NOT NULL REFERENCES sales_orders(id) ON DELETE CASCADE,
  previous_status VARCHAR(50),
  current_status VARCHAR(50) NOT NULL,
  operator_id BIGINT NOT NULL REFERENCES users(id),
  operator_name VARCHAR(50),
  remark TEXT,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_order_status_logs_order_id ON order_status_logs(order_id);
CREATE INDEX idx_order_status_logs_current_status ON order_status_logs(current_status);
CREATE INDEX idx_order_status_logs_operator_id ON order_status_logs(operator_id);
CREATE INDEX idx_order_status_logs_created_at ON order_status_logs(created_at);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE order_status_logs IS 'é”€å”®å•çŠ¶æ€å˜æ›´æ—¥å¿—è¡¨';
COMMENT ON COLUMN order_status_logs.id IS 'æ—¥å¿—ID';
COMMENT ON COLUMN order_status_logs.order_id IS 'é”€å”®å•ID';
COMMENT ON COLUMN order_status_logs.previous_status IS 'ä¹‹å‰çŠ¶æ€';
COMMENT ON COLUMN order_status_logs.current_status IS 'å½“å‰çŠ¶æ€';
COMMENT ON COLUMN order_status_logs.operator_id IS 'æ“ä½œäººID';
COMMENT ON COLUMN order_status_logs.operator_name IS 'æ“ä½œäººå§“å';
COMMENT ON COLUMN order_status_logs.remark IS 'å¤‡æ³¨';
COMMENT ON COLUMN order_status_logs.created_at IS 'åˆ›å»ºæ—¶é—´';
```

## ğŸ’° ç§¯åˆ†ç®¡ç†æ¨¡å—

### ç§¯åˆ†æµæ°´è¡¨ï¼ˆpoint_logsï¼‰
```sql
CREATE TABLE point_logs (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES users(id),
  points INTEGER NOT NULL,
  type VARCHAR(20) NOT NULL CHECK (type IN ('earned', 'consumed', 'expired')),
  source VARCHAR(50) NOT NULL,
  source_id BIGINT,
  source_description VARCHAR(500),
  balance INTEGER NOT NULL,
  expired_at TIMESTAMP,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_point_logs_user_id ON point_logs(user_id);
CREATE INDEX idx_point_logs_type ON point_logs(type);
CREATE INDEX idx_point_logs_source ON point_logs(source);
CREATE INDEX idx_point_logs_source_id ON point_logs(source_id);
CREATE INDEX idx_point_logs_created_at ON point_logs(created_at);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE point_logs IS 'ç§¯åˆ†æµæ°´è¡¨';
COMMENT ON COLUMN point_logs.id IS 'æµæ°´ID';
COMMENT ON COLUMN point_logs.user_id IS 'ç”¨æˆ·ID';
COMMENT ON COLUMN point_logs.points IS 'ç§¯åˆ†æ•°é‡ï¼ˆæ­£æ•°ä¸ºè·å¾—ï¼Œè´Ÿæ•°ä¸ºæ¶ˆè€—ï¼‰';
COMMENT ON COLUMN point_logs.type IS 'ç±»å‹ï¼šearned,consumed,expired';
COMMENT ON COLUMN point_logs.source IS 'æ¥æºï¼šlead_created,lead_followed,order_signed,order_completed,service_completed';
COMMENT ON COLUMN point_logs.source_id IS 'æ¥æºID';
COMMENT ON COLUMN point_logs.source_description IS 'æ¥æºæè¿°';
COMMENT ON COLUMN point_logs.balance IS 'å˜æ›´åä½™é¢';
COMMENT ON COLUMN point_logs.expired_at IS 'è¿‡æœŸæ—¶é—´';
COMMENT ON COLUMN point_logs.created_at IS 'åˆ›å»ºæ—¶é—´';
```

### ç§¯åˆ†è§„åˆ™è¡¨ï¼ˆpoint_rulesï¼‰
```sql
CREATE TABLE point_rules (
  id BIGSERIAL PRIMARY KEY,
  rule_code VARCHAR(50) NOT NULL UNIQUE,
  rule_name VARCHAR(100) NOT NULL,
  points INTEGER NOT NULL,
  source_type VARCHAR(50) NOT NULL,
  conditions JSONB,
  adjustment_factors JSONB,
  status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive')),
  valid_from TIMESTAMP NOT NULL,
  valid_to TIMESTAMP,
  created_by BIGINT REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_point_rules_source_type ON point_rules(source_type);
CREATE INDEX idx_point_rules_status ON point_rules(status);
CREATE INDEX idx_point_rules_valid_from ON point_rules(valid_from);
CREATE INDEX idx_point_rules_valid_to ON point_rules(valid_to);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE point_rules IS 'ç§¯åˆ†è§„åˆ™è¡¨';
COMMENT ON COLUMN point_rules.id IS 'è§„åˆ™ID';
COMMENT ON COLUMN point_rules.rule_code IS 'è§„åˆ™ç¼–ç ';
COMMENT ON COLUMN point_rules.rule_name IS 'è§„åˆ™åç§°';
COMMENT ON COLUMN point_rules.points IS 'ç§¯åˆ†æ•°é‡';
COMMENT ON COLUMN point_rules.source_type IS 'æ¥æºç±»å‹';
COMMENT ON COLUMN point_rules.conditions IS 'è§¦å‘æ¡ä»¶';
COMMENT ON COLUMN point_rules.adjustment_factors IS 'è°ƒèŠ‚ç³»æ•°';
COMMENT ON COLUMN point_rules.status IS 'çŠ¶æ€ï¼šactive,inactive';
COMMENT ON COLUMN point_rules.valid_from IS 'ç”Ÿæ•ˆæ—¶é—´';
COMMENT ON COLUMN point_rules.valid_to IS 'å¤±æ•ˆæ—¶é—´';
COMMENT ON COLUMN point_rules.created_by IS 'åˆ›å»ºäººID';
COMMENT ON COLUMN point_rules.created_at IS 'åˆ›å»ºæ—¶é—´';
COMMENT ON COLUMN point_rules.updated_at IS 'æ›´æ–°æ—¶é—´';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_point_rules_updated_at BEFORE UPDATE ON point_rules
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

## ğŸ‘¤ å®¢æˆ·ç®¡ç†æ¨¡å—

### å®¢æˆ·è¡¨ï¼ˆcustomersï¼‰
```sql
CREATE TABLE customers (
  id BIGSERIAL PRIMARY KEY,
  customer_no VARCHAR(50) NOT NULL UNIQUE,
  name VARCHAR(50) NOT NULL,
  phone VARCHAR(15) NOT NULL UNIQUE,
  email VARCHAR(100),
  gender VARCHAR(10) CHECK (gender IN ('male', 'female', 'unknown')),
  birthday DATE,
  company VARCHAR(100),
  occupation VARCHAR(50),
  income_level VARCHAR(20) CHECK (income_level IN ('high', 'middle', 'low')),
  customer_type VARCHAR(20) DEFAULT 'individual' CHECK (customer_type IN ('individual', 'enterprise')),
  source VARCHAR(50),
  status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'blacklist')),
  total_orders INTEGER NOT NULL DEFAULT 0,
  total_amount DECIMAL(10,2) NOT NULL DEFAULT 0.00,
  last_order_time TIMESTAMP,
  satisfaction_score DECIMAL(3,1),
  remark TEXT,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  deleted_at TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_customers_name ON customers(name);
CREATE INDEX idx_customers_status ON customers(status);
CREATE INDEX idx_customers_created_at ON customers(created_at);
CREATE INDEX idx_customers_deleted_at ON customers(deleted_at);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE customers IS 'å®¢æˆ·è¡¨';
COMMENT ON COLUMN customers.id IS 'å®¢æˆ·ID';
COMMENT ON COLUMN customers.customer_no IS 'å®¢æˆ·ç¼–å·';
COMMENT ON COLUMN customers.name IS 'å®¢æˆ·å§“å';
COMMENT ON COLUMN customers.phone IS 'å®¢æˆ·æ‰‹æœºå·';
COMMENT ON COLUMN customers.email IS 'å®¢æˆ·é‚®ç®±';
COMMENT ON COLUMN customers.gender IS 'æ€§åˆ«ï¼šmale,female,unknown';
COMMENT ON COLUMN customers.birthday IS 'ç”Ÿæ—¥';
COMMENT ON COLUMN customers.company IS 'å…¬å¸';
COMMENT ON COLUMN customers.occupation IS 'èŒä¸š';
COMMENT ON COLUMN customers.income_level IS 'æ”¶å…¥æ°´å¹³ï¼šhigh,middle,low';
COMMENT ON COLUMN customers.customer_type IS 'å®¢æˆ·ç±»å‹ï¼šindividual,enterprise';
COMMENT ON COLUMN customers.source IS 'å®¢æˆ·æ¥æº';
COMMENT ON COLUMN customers.status IS 'çŠ¶æ€ï¼šactive,inactive,blacklist';
COMMENT ON COLUMN customers.total_orders IS 'æ€»è®¢å•æ•°';
COMMENT ON COLUMN customers.total_amount IS 'æ€»æ¶ˆè´¹é‡‘é¢';
COMMENT ON COLUMN customers.last_order_time IS 'æœ€åä¸‹å•æ—¶é—´';
COMMENT ON COLUMN customers.satisfaction_score IS 'æ»¡æ„åº¦è¯„åˆ†';
COMMENT ON COLUMN customers.remark IS 'å¤‡æ³¨';
COMMENT ON COLUMN customers.created_at IS 'åˆ›å»ºæ—¶é—´';
COMMENT ON COLUMN customers.updated_at IS 'æ›´æ–°æ—¶é—´';
COMMENT ON COLUMN customers.deleted_at IS 'åˆ é™¤æ—¶é—´ï¼ˆè½¯åˆ é™¤ï¼‰';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_customers_updated_at BEFORE UPDATE ON customers
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### å®¢æˆ·åœ°å€è¡¨ï¼ˆcustomer_addressesï¼‰
```sql
CREATE TABLE customer_addresses (
  id BIGSERIAL PRIMARY KEY,
  customer_id BIGINT NOT NULL REFERENCES customers(id) ON DELETE CASCADE,
  address_type VARCHAR(20) NOT NULL DEFAULT 'home' CHECK (address_type IN ('home', 'work', 'other')),
  province VARCHAR(50) NOT NULL,
  city VARCHAR(50) NOT NULL,
  district VARCHAR(50) NOT NULL,
  street VARCHAR(100) NOT NULL,
  detail_address TEXT,
  postal_code VARCHAR(10),
  is_default BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_customer_addresses_customer_id ON customer_addresses(customer_id);
CREATE INDEX idx_customer_addresses_is_default ON customer_addresses(is_default);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE customer_addresses IS 'å®¢æˆ·åœ°å€è¡¨';
COMMENT ON COLUMN customer_addresses.id IS 'åœ°å€ID';
COMMENT ON COLUMN customer_addresses.customer_id IS 'å®¢æˆ·ID';
COMMENT ON COLUMN customer_addresses.address_type IS 'åœ°å€ç±»å‹ï¼šhome,work,other';
COMMENT ON COLUMN customer_addresses.province IS 'çœä»½';
COMMENT ON COLUMN customer_addresses.city IS 'åŸå¸‚';
COMMENT ON COLUMN customer_addresses.district IS 'åŒºå¿';
COMMENT ON COLUMN customer_addresses.street IS 'è¡—é“';
COMMENT ON COLUMN customer_addresses.detail_address IS 'è¯¦ç»†åœ°å€';
COMMENT ON COLUMN customer_addresses.postal_code IS 'é‚®ç¼–';
COMMENT ON COLUMN customer_addresses.is_default IS 'æ˜¯å¦é»˜è®¤åœ°å€';
COMMENT ON COLUMN customer_addresses.created_at IS 'åˆ›å»ºæ—¶é—´';
COMMENT ON COLUMN customer_addresses.updated_at IS 'æ›´æ–°æ—¶é—´';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_customer_addresses_updated_at BEFORE UPDATE ON customer_addresses
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### æ ‡ç­¾è¡¨ï¼ˆtagsï¼‰
```sql
CREATE TABLE tags (
  id BIGSERIAL PRIMARY KEY,
  name VARCHAR(50) NOT NULL,
  color VARCHAR(20),
  category VARCHAR(50) NOT NULL CHECK (category IN ('customer', 'lead', 'order')),
  description TEXT,
  sort INTEGER NOT NULL DEFAULT 0,
  status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive')),
  created_by BIGINT REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(name, category)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_tags_category ON tags(category);
CREATE INDEX idx_tags_status ON tags(status);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE tags IS 'æ ‡ç­¾è¡¨';
COMMENT ON COLUMN tags.id IS 'æ ‡ç­¾ID';
COMMENT ON COLUMN tags.name IS 'æ ‡ç­¾åç§°';
COMMENT ON COLUMN tags.color IS 'æ ‡ç­¾é¢œè‰²';
COMMENT ON COLUMN tags.category IS 'æ ‡ç­¾åˆ†ç±»ï¼šcustomer,lead,order';
COMMENT ON COLUMN tags.description IS 'æè¿°';
COMMENT ON COLUMN tags.sort IS 'æ’åº';
COMMENT ON COLUMN tags.status IS 'çŠ¶æ€ï¼šactive,inactive';
COMMENT ON COLUMN tags.created_by IS 'åˆ›å»ºäººID';
COMMENT ON COLUMN tags.created_at IS 'åˆ›å»ºæ—¶é—´';
COMMENT ON COLUMN tags.updated_at IS 'æ›´æ–°æ—¶é—´';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_tags_updated_at BEFORE UPDATE ON tags
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### å®¢æˆ·æ ‡ç­¾å…³è”è¡¨ï¼ˆcustomer_tagsï¼‰
```sql
CREATE TABLE customer_tags (
  id BIGSERIAL PRIMARY KEY,
  customer_id BIGINT NOT NULL REFERENCES customers(id) ON DELETE CASCADE,
  tag_id BIGINT NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
  created_by BIGINT REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(customer_id, tag_id)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_customer_tags_customer_id ON customer_tags(customer_id);
CREATE INDEX idx_customer_tags_tag_id ON customer_tags(tag_id);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE customer_tags IS 'å®¢æˆ·æ ‡ç­¾å…³è”è¡¨';
COMMENT ON COLUMN customer_tags.id IS 'å…³è”ID';
COMMENT ON COLUMN customer_tags.customer_id IS 'å®¢æˆ·ID';
COMMENT ON COLUMN customer_tags.tag_id IS 'æ ‡ç­¾ID';
COMMENT ON COLUMN customer_tags.created_by IS 'åˆ›å»ºäººID';
COMMENT ON COLUMN customer_tags.created_at IS 'åˆ›å»ºæ—¶é—´';
```

## ğŸ”§ ç³»ç»Ÿé…ç½®æ¨¡å—

### ç³»ç»Ÿé…ç½®è¡¨ï¼ˆsystem_configsï¼‰
```sql
CREATE TABLE system_configs (
  id BIGSERIAL PRIMARY KEY,
  config_key VARCHAR(100) NOT NULL UNIQUE,
  config_value TEXT,
  config_type VARCHAR(20) NOT NULL DEFAULT 'string' CHECK (config_type IN ('string', 'number', 'boolean', 'json')),
  module VARCHAR(50) NOT NULL,
  description TEXT,
  is_system BOOLEAN NOT NULL DEFAULT FALSE,
  editable BOOLEAN NOT NULL DEFAULT TRUE,
  created_by BIGINT REFERENCES users(id),
  updated_by BIGINT REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_system_configs_module ON system_configs(module);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE system_configs IS 'ç³»ç»Ÿé…ç½®è¡¨';
COMMENT ON COLUMN system_configs.id IS 'é…ç½®ID';
COMMENT ON COLUMN system_configs.config_key IS 'é…ç½®é”®';
COMMENT ON COLUMN system_configs.config_value IS 'é…ç½®å€¼';
COMMENT ON COLUMN system_configs.config_type IS 'é…ç½®ç±»å‹ï¼šstring,number,boolean,json';
COMMENT ON COLUMN system_configs.module IS 'é…ç½®æ¨¡å—';
COMMENT ON COLUMN system_configs.description IS 'æè¿°';
COMMENT ON COLUMN system_configs.is_system IS 'æ˜¯å¦ç³»ç»Ÿé…ç½®';
COMMENT ON COLUMN system_configs.editable IS 'æ˜¯å¦å¯ç¼–è¾‘';
COMMENT ON COLUMN system_configs.created_by IS 'åˆ›å»ºäººID';
COMMENT ON COLUMN system_configs.updated_by IS 'æ›´æ–°äººID';
COMMENT ON COLUMN system_configs.created_at IS 'åˆ›å»ºæ—¶é—´';
COMMENT ON COLUMN system_configs.updated_at IS 'æ›´æ–°æ—¶é—´';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_system_configs_updated_at BEFORE UPDATE ON system_configs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

## ğŸ“‹ æ—¥å¿—ç®¡ç†æ¨¡å—

### æ“ä½œæ—¥å¿—è¡¨ï¼ˆoperation_logsï¼‰
```sql
CREATE TABLE operation_logs (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES users(id),
  user_name VARCHAR(50),
  module VARCHAR(50) NOT NULL,
  action VARCHAR(50) NOT NULL,
  method VARCHAR(10),
  path VARCHAR(200),
  params JSONB,
  ip VARCHAR(50),
  user_agent TEXT,
  duration INTEGER,
  result VARCHAR(20) CHECK (result IN ('success', 'failure')),
  error_message TEXT,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_operation_logs_user_id ON operation_logs(user_id);
CREATE INDEX idx_operation_logs_module ON operation_logs(module);
CREATE INDEX idx_operation_logs_action ON operation_logs(action);
CREATE INDEX idx_operation_logs_created_at ON operation_logs(created_at);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE operation_logs IS 'æ“ä½œæ—¥å¿—è¡¨';
COMMENT ON COLUMN operation_logs.id IS 'æ—¥å¿—ID';
COMMENT ON COLUMN operation_logs.user_id IS 'ç”¨æˆ·ID';
COMMENT ON COLUMN operation_logs.user_name IS 'ç”¨æˆ·å§“å';
COMMENT ON COLUMN operation_logs.module IS 'æ“ä½œæ¨¡å—';
COMMENT ON COLUMN operation_logs.action IS 'æ“ä½œåŠ¨ä½œ';
COMMENT ON COLUMN operation_logs.method IS 'è¯·æ±‚æ–¹æ³•';
COMMENT ON COLUMN operation_logs.path IS 'è¯·æ±‚è·¯å¾„';
COMMENT ON COLUMN operation_logs.params IS 'è¯·æ±‚å‚æ•°';
COMMENT ON COLUMN operation_logs.ip IS 'IPåœ°å€';
COMMENT ON COLUMN operation_logs.user_agent IS 'ç”¨æˆ·ä»£ç†';
COMMENT ON COLUMN operation_logs.duration IS 'è¯·æ±‚è€—æ—¶ï¼ˆæ¯«ç§’ï¼‰';
COMMENT ON COLUMN operation_logs.result IS 'æ“ä½œç»“æœï¼šsuccess,failure';
COMMENT ON COLUMN operation_logs.error_message IS 'é”™è¯¯ä¿¡æ¯';
COMMENT ON COLUMN operation_logs.created_at IS 'åˆ›å»ºæ—¶é—´';
```

### ç™»å½•æ—¥å¿—è¡¨ï¼ˆlogin_logsï¼‰
```sql
CREATE TABLE login_logs (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES users(id),
  user_name VARCHAR(50),
  login_time TIMESTAMP NOT NULL,
  login_ip VARCHAR(50),
  login_location VARCHAR(200),
  user_agent TEXT,
  login_result VARCHAR(20) NOT NULL CHECK (login_result IN ('success', 'failure')),
  failure_reason VARCHAR(200),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_login_logs_user_id ON login_logs(user_id);
CREATE INDEX idx_login_logs_login_time ON login_logs(login_time);
CREATE INDEX idx_login_logs_login_result ON login_logs(login_result);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE login_logs IS 'ç™»å½•æ—¥å¿—è¡¨';
COMMENT ON COLUMN login_logs.id IS 'æ—¥å¿—ID';
COMMENT ON COLUMN login_logs.user_id IS 'ç”¨æˆ·ID';
COMMENT ON COLUMN login_logs.user_name IS 'ç”¨æˆ·å';
COMMENT ON COLUMN login_logs.login_time IS 'ç™»å½•æ—¶é—´';
COMMENT ON COLUMN login_logs.login_ip IS 'ç™»å½•IP';
COMMENT ON COLUMN login_logs.login_location IS 'ç™»å½•åœ°ç‚¹';
COMMENT ON COLUMN login_logs.user_agent IS 'ç”¨æˆ·ä»£ç†';
COMMENT ON COLUMN login_logs.login_result IS 'ç™»å½•ç»“æœï¼šsuccess,failure';
COMMENT ON COLUMN login_logs.failure_reason IS 'å¤±è´¥åŸå› ';
COMMENT ON COLUMN login_logs.created_at IS 'åˆ›å»ºæ—¶é—´';
```

## ğŸ” ç´¢å¼•ä¼˜åŒ–ç­–ç•¥

### æ ¸å¿ƒæŸ¥è¯¢ç´¢å¼•
```sql
-- ç”¨æˆ·ç™»å½•æŸ¥è¯¢ä¼˜åŒ–
CREATE INDEX idx_users_login ON users(username, status);

-- çº¿ç´¢æŸ¥è¯¢ä¼˜åŒ–
CREATE INDEX idx_leads_query ON leads(status, assigned_to, next_follow_time, created_at);

-- è®¢å•æŸ¥è¯¢ä¼˜åŒ–
CREATE INDEX idx_orders_query ON sales_orders(status, sales_id, customer_name, created_at);

-- ç§¯åˆ†æµæ°´æŸ¥è¯¢ä¼˜åŒ–
CREATE INDEX idx_point_logs_query ON point_logs(user_id, created_at, type, source);

-- å®¢æˆ·æŸ¥è¯¢ä¼˜åŒ–
CREATE INDEX idx_customers_query ON customers(phone, name, status, created_at);
```

### å¤åˆç´¢å¼•è®¾è®¡
```sql
-- å¤šæ¡ä»¶ç»„åˆæŸ¥è¯¢
CREATE INDEX idx_leads_composite ON leads(customer_phone, status, source, created_at);
CREATE INDEX idx_orders_composite ON sales_orders(order_no, customer_phone, status, sales_id);

-- æ’åºä¼˜åŒ–
CREATE INDEX idx_leads_sort ON leads(next_follow_time, status, assigned_to);
CREATE INDEX idx_orders_sort ON sales_orders(created_at DESC, status, sales_id);
```

### å…¨æ–‡ç´¢å¼•
```sql
-- å®¢æˆ·ä¿¡æ¯å…¨æ–‡æœç´¢
CREATE INDEX idx_customers_fulltext ON customers USING gin(to_tsvector('chinese', name || ' ' || phone || ' ' || COALESCE(company, '')));

-- äº§å“ä¿¡æ¯å…¨æ–‡æœç´¢
CREATE INDEX idx_products_fulltext ON order_products USING gin(to_tsvector('chinese', product_name || ' ' || COALESCE(specifications, '')));
```

## ğŸ“Š åˆ†è¡¨åˆ†åº“ç­–ç•¥

### æ°´å¹³åˆ†è¡¨ç­–ç•¥

#### æŒ‰æ—¶é—´ç»´åº¦åˆ†è¡¨
```sql
-- ç§¯åˆ†æµæ°´è¡¨æŒ‰æœˆåˆ†è¡¨
CREATE TABLE point_logs_202501 (LIKE point_logs INCLUDING ALL);
CREATE TABLE point_logs_202502 (LIKE point_logs INCLUDING ALL);
CREATE TABLE point_logs_202503 (LIKE point_logs INCLUDING ALL);

-- æ“ä½œæ—¥å¿—è¡¨æŒ‰å‘¨åˆ†è¡¨
CREATE TABLE operation_logs_2025w01 (LIKE operation_logs INCLUDING ALL);
CREATE TABLE operation_logs_2025w02 (LIKE operation_logs INCLUDING ALL);
CREATE TABLE operation_logs_2025w03 (LIKE operation_logs INCLUDING ALL);
```

#### æŒ‰ä¸šåŠ¡ç»´åº¦åˆ†è¡¨
```sql
-- æŒ‰ç”¨æˆ·IDå–æ¨¡åˆ†è¡¨ï¼ˆç¤ºä¾‹ï¼‰
-- ç”¨æˆ·ID % 4 = 0çš„è¡¨
CREATE TABLE user_points_0 (LIKE point_logs INCLUDING ALL);
-- ç”¨æˆ·ID % 4 = 1çš„è¡¨
CREATE TABLE user_points_1 (LIKE point_logs INCLUDING ALL);
-- ç”¨æˆ·ID % 4 = 2çš„è¡¨
CREATE TABLE user_points_2 (LIKE point_logs INCLUDING ALL);
-- ç”¨æˆ·ID % 4 = 3çš„è¡¨
CREATE TABLE user_points_3 (LIKE point_logs INCLUDING ALL);
```

### å‚ç›´åˆ†è¡¨ç­–ç•¥

#### ç”¨æˆ·è¡¨æ‹†åˆ†
```sql
-- ç”¨æˆ·åŸºæœ¬ä¿¡æ¯è¡¨ï¼ˆé«˜é¢‘æŸ¥è¯¢ï¼‰
CREATE TABLE users_basic (
  id, username, nickname, phone, email, status, last_login_time
);

-- ç”¨æˆ·æ‰©å±•ä¿¡æ¯è¡¨ï¼ˆä½é¢‘æŸ¥è¯¢ï¼‰
CREATE TABLE users_profile (
  user_id, avatar, birthday, address, bio, preferences
);

-- ç”¨æˆ·è®¤è¯ä¿¡æ¯è¡¨ï¼ˆå®‰å…¨æ•æ„Ÿï¼‰
CREATE TABLE users_auth (
  user_id, password, salt, mfa_secret, last_password_change
);
```

## ğŸ”’ æ•°æ®å®‰å…¨ç­–ç•¥

### æ•æ„Ÿæ•°æ®åŠ å¯†
```sql
-- å¯†ç åŠ å¯†å­˜å‚¨ï¼ˆä½¿ç”¨bcryptï¼‰
ALTER TABLE users ADD COLUMN password_hash VARCHAR(255) NOT NULL;
COMMENT ON COLUMN users.password_hash IS 'å¯†ç å“ˆå¸Œ';

-- æ‰‹æœºå·åŠ å¯†å­˜å‚¨ï¼ˆä½¿ç”¨AESï¼‰
ALTER TABLE customers ADD COLUMN phone_encrypted VARCHAR(100);
ALTER TABLE customers ADD COLUMN phone_mask VARCHAR(15);
COMMENT ON COLUMN customers.phone_encrypted IS 'åŠ å¯†æ‰‹æœºå·';
COMMENT ON COLUMN customers.phone_mask IS 'è„±æ•æ‰‹æœºå·';

-- èº«ä»½è¯ä¿¡æ¯åŠ å¯†
ALTER TABLE customers ADD COLUMN id_card_encrypted VARCHAR(200);
COMMENT ON COLUMN customers.id_card_encrypted IS 'åŠ å¯†èº«ä»½è¯ä¿¡æ¯';
```

### æ•°æ®è„±æ•ç­–ç•¥
```sql
-- åˆ›å»ºè„±æ•è§†å›¾
CREATE VIEW customers_masked AS
SELECT 
  id,
  customer_no,
  name,
  CONCAT(LEFT(phone, 3), '****', RIGHT(phone, 4)) AS phone_display,
  email,
  status,
  created_at
FROM customers;

-- æ·»åŠ è§†å›¾æ³¨é‡Š
COMMENT ON VIEW customers_masked IS 'å®¢æˆ·ä¿¡æ¯è„±æ•è§†å›¾';
```

## ğŸ“ˆ æ€§èƒ½ç›‘æ§ä¸ä¼˜åŒ–

### æ…¢æŸ¥è¯¢ç›‘æ§
```sql
-- å¼€å¯æ…¢æŸ¥è¯¢æ—¥å¿—
ALTER SYSTEM SET log_min_duration_statement = 1000;  -- è¶…è¿‡1ç§’çš„æŸ¥è¯¢è®°å½•
ALTER SYSTEM SET log_statement = 'all';
ALTER SYSTEM SET log_directory = 'pg_log';
ALTER SYSTEM SET log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log';
SELECT pg_reload_conf();

-- åˆ›å»ºæ…¢æŸ¥è¯¢åˆ†æè¡¨
CREATE TABLE slow_query_logs (
  id BIGSERIAL PRIMARY KEY,
  query_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  execution_time DECIMAL(10,3) NOT NULL,
  query_text TEXT NOT NULL,
  user_host VARCHAR(100),
  rows_examined INTEGER,
  rows_sent INTEGER
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_slow_query_logs_query_time ON slow_query_logs(query_time);
CREATE INDEX idx_slow_query_logs_execution_time ON slow_query_logs(execution_time);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE slow_query_logs IS 'æ…¢æŸ¥è¯¢åˆ†æè¡¨';
COMMENT ON COLUMN slow_query_logs.id IS 'è®°å½•ID';
COMMENT ON COLUMN slow_query_logs.query_time IS 'æŸ¥è¯¢æ—¶é—´';
COMMENT ON COLUMN slow_query_logs.execution_time IS 'æ‰§è¡Œæ—¶é—´ï¼ˆç§’ï¼‰';
COMMENT ON COLUMN slow_query_logs.query_text IS 'æŸ¥è¯¢è¯­å¥';
COMMENT ON COLUMN slow_query_logs.user_host IS 'ç”¨æˆ·ä¸»æœº';
COMMENT ON COLUMN slow_query_logs.rows_examined IS 'æ£€æŸ¥è¡Œæ•°';
COMMENT ON COLUMN slow_query_logs.rows_sent IS 'è¿”å›è¡Œæ•°';
```

### ç´¢å¼•ä½¿ç”¨ç›‘æ§
```sql
-- æŸ¥çœ‹ç´¢å¼•ä½¿ç”¨æƒ…å†µ
SELECT 
  schemaname,
  tablename,
  indexname,
  idx_scan,
  idx_tup_read,
  idx_tup_fetch
FROM pg_stat_user_indexes 
ORDER BY schemaname, tablename, indexname;

-- ç›‘æ§ç´¢å¼•å‘½ä¸­ç‡
SELECT 
  datname,
  numbackends,
  xact_commit,
  xact_rollback,
  blks_read,
  blks_hit,
  round(blks_hit::numeric / (blks_hit + blks_read) * 100, 2) AS cache_hit_ratio
FROM pg_stat_database 
WHERE datname = current_database();
```

## ğŸ”„ æ•°æ®å¤‡ä»½ä¸æ¢å¤

### å¤‡ä»½ç­–ç•¥
```bash
# å…¨é‡å¤‡ä»½ï¼ˆæ¯æ—¥ï¼‰
pg_dump -h localhost -U postgres -d crm_db -f backup_$(date +%Y%m%d).sql

# å¢é‡å¤‡ä»½ï¼ˆæ¯å°æ—¶ï¼‰- åŸºäºWALæ—¥å¿—
pg_receivewal -h localhost -U postgres -D /var/lib/postgresql/wal_archive -z -P
```

### æ¢å¤ç­–ç•¥
```bash
# å…¨é‡æ¢å¤
psql -h localhost -U postgres -d crm_db -f backup_20250101.sql

# åŸºäºæ—¶é—´ç‚¹æ¢å¤ï¼ˆPITRï¼‰
pg_ctl start -D /var/lib/postgresql/data
psql -U postgres -c "SELECT pg_start_backup('backup');"
# æ‰§è¡Œæ–‡ä»¶ç³»ç»Ÿå¤‡ä»½
psql -U postgres -c "SELECT pg_stop_backup();"
```

## â° å®šæ—¶ä»»åŠ¡é…ç½®

### 1. çº¿ç´¢çŠ¶æ€è‡ªåŠ¨åŒ–ä»»åŠ¡

```sql
-- åˆ›å»ºçŠ¶æ€åˆ·æ–°å­˜å‚¨è¿‡ç¨‹
CREATE OR REPLACE FUNCTION refresh_lead_statuses()
RETURNS void AS $$
BEGIN
    -- æ›´æ–°è¿‡æœŸçš„é¢„æŠ¥ä»·çŠ¶æ€
    UPDATE lead_quotes 
    SET is_expired = TRUE, updated_at = CURRENT_TIMESTAMP
    WHERE expires_at < CURRENT_TIMESTAMP AND is_expired = FALSE;
    
    -- ä¸º10å¤©æœªè½¬åŒ–çš„å·²æŠ¥ä»·çº¿ç´¢æ·»åŠ "éœ€ç»´æŠ¤"æ ‡ç­¾
    UPDATE lead_quotes 
    SET needs_maintenance = TRUE, 
        maintenance_added_at = CURRENT_TIMESTAMP,
        updated_at = CURRENT_TIMESTAMP
    WHERE quoted_at < CURRENT_TIMESTAMP - INTERVAL '10 days'
      AND needs_maintenance = FALSE
      AND lead_id NOT IN (
          SELECT DISTINCT lead_id FROM sales_orders WHERE lead_id IS NOT NULL
      );
    
    -- è®°å½•çŠ¶æ€å˜æ›´æ—¥å¿—
    INSERT INTO lead_status_logs (lead_id, previous_status, current_status, change_reason, operator_id)
    SELECT l.id, l.status, l.status, 'ç³»ç»Ÿè‡ªåŠ¨åˆ·æ–°çŠ¶æ€', 1
    FROM leads l
    WHERE l.updated_at = CURRENT_TIMESTAMP;
    
    -- æ¸…ç†1å¹´å‰çš„é¢„æŠ¥ä»·è®°å½•
    DELETE FROM lead_quotes 
    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '1 year';
    
    -- è®°å½•ä»»åŠ¡æ‰§è¡Œæ—¥å¿—
    INSERT INTO scheduled_task_logs (task_name, status, affected_rows)
    VALUES ('refresh_lead_statuses', 'success', ROW_COUNT());
    
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºçº¿ç´¢è·Ÿè¿›æé†’å­˜å‚¨è¿‡ç¨‹
CREATE OR REPLACE FUNCTION send_follow_up_reminders()
RETURNS void AS $$
BEGIN
    -- æ›´æ–°éœ€è¦è·Ÿè¿›æé†’çš„çº¿ç´¢
    UPDATE leads 
    SET updated_at = CURRENT_TIMESTAMP
    WHERE next_follow_time <= CURRENT_TIMESTAMP 
      AND status NOT IN ('converted', 'lost')
      AND next_follow_time IS NOT NULL;
      
    -- è®°å½•ä»»åŠ¡æ‰§è¡Œæ—¥å¿—
    INSERT INTO scheduled_task_logs (task_name, status, affected_rows)
    VALUES ('send_follow_up_reminders', 'success', ROW_COUNT());
    
END;
$$ LANGUAGE plpgsql;
```

### 2. å®šæ—¶ä»»åŠ¡è°ƒåº¦é…ç½®

```sql
-- éœ€è¦å®‰è£…pg_cronæ‰©å±•
-- CREATE EXTENSION IF NOT EXISTS pg_cron;

-- æ¯æ—¥å‡Œæ™¨2ç‚¹æ‰§è¡ŒçŠ¶æ€åˆ·æ–°ä»»åŠ¡
SELECT cron.schedule(
    'daily-lead-status-refresh', 
    '0 2 * * *', 
    'SELECT refresh_lead_statuses();'
);

-- æ¯å°æ—¶æ£€æŸ¥è·Ÿè¿›æé†’
SELECT cron.schedule(
    'hourly-follow-up-reminders', 
    '0 * * * *', 
    'SELECT send_follow_up_reminders();'
);

-- æŸ¥çœ‹å·²é…ç½®çš„å®šæ—¶ä»»åŠ¡
SELECT * FROM cron.job;

-- åˆ é™¤å®šæ—¶ä»»åŠ¡ï¼ˆå¦‚éœ€è¦ï¼‰
-- SELECT cron.unschedule('daily-lead-status-refresh');
-- SELECT cron.unschedule('hourly-follow-up-reminders');
```

### 3. ä»»åŠ¡æ‰§è¡Œæ—¥å¿—è¡¨

```sql
-- åˆ›å»ºä»»åŠ¡æ‰§è¡Œæ—¥å¿—è¡¨
CREATE TABLE scheduled_task_logs (
    id BIGSERIAL PRIMARY KEY,
    task_name VARCHAR(100) NOT NULL,
    execution_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) NOT NULL DEFAULT 'success',
    error_message TEXT,
    execution_duration INTERVAL,
    affected_rows INTEGER DEFAULT 0
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_scheduled_task_logs_task_name ON scheduled_task_logs(task_name);
CREATE INDEX idx_scheduled_task_logs_execution_time ON scheduled_task_logs(execution_time);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE scheduled_task_logs IS 'å®šæ—¶ä»»åŠ¡æ‰§è¡Œæ—¥å¿—è¡¨';
COMMENT ON COLUMN scheduled_task_logs.id IS 'æ—¥å¿—ID';
COMMENT ON COLUMN scheduled_task_logs.task_name IS 'ä»»åŠ¡åç§°';
COMMENT ON COLUMN scheduled_task_logs.execution_time IS 'æ‰§è¡Œæ—¶é—´';
COMMENT ON COLUMN scheduled_task_logs.status IS 'æ‰§è¡ŒçŠ¶æ€ï¼šsuccess/failed';
COMMENT ON COLUMN scheduled_task_logs.error_message IS 'é”™è¯¯ä¿¡æ¯';
COMMENT ON COLUMN scheduled_task_logs.execution_duration IS 'æ‰§è¡Œè€—æ—¶';
COMMENT ON COLUMN scheduled_task_logs.affected_rows IS 'å½±å“è¡Œæ•°';
```

### 4. æ•°æ®ä¿ç•™ç­–ç•¥

```sql
-- åˆ›å»ºæ•°æ®æ¸…ç†å­˜å‚¨è¿‡ç¨‹
CREATE OR REPLACE FUNCTION cleanup_old_data()
RETURNS void AS $$
BEGIN
    -- æ¸…ç†1å¹´å‰çš„é¢„æŠ¥ä»·è®°å½•
    DELETE FROM lead_quotes 
    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '1 year';
    
    -- æ¸…ç†3ä¸ªæœˆå‰çš„ä»»åŠ¡æ‰§è¡Œæ—¥å¿—
    DELETE FROM scheduled_task_logs 
    WHERE execution_time < CURRENT_TIMESTAMP - INTERVAL '3 months';
    
    -- æ¸…ç†6ä¸ªæœˆå‰çš„çº¿ç´¢çŠ¶æ€å˜æ›´æ—¥å¿—
    DELETE FROM lead_status_logs 
    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '6 months';
    
    -- è®°å½•æ¸…ç†ä»»åŠ¡æ‰§è¡Œæ—¥å¿—
    INSERT INTO scheduled_task_logs (task_name, status, affected_rows)
    VALUES ('cleanup_old_data', 'success', ROW_COUNT());
    
END;
$$ LANGUAGE plpgsql;

-- æ¯å‘¨æ—¥å‡Œæ™¨3ç‚¹æ‰§è¡Œæ•°æ®æ¸…ç†ä»»åŠ¡
SELECT cron.schedule(
    'weekly-data-cleanup', 
    '0 3 * * 0', 
    'SELECT cleanup_old_data();'
);
```

## ğŸ“ æµ‹é‡ç®¡ç†æ¨¡å—

### æµ‹é‡ä»»åŠ¡è¡¨ï¼ˆmeasurementsï¼‰
```sql
CREATE TABLE measurements (
  id BIGSERIAL PRIMARY KEY,
  order_id BIGINT NOT NULL REFERENCES sales_orders(id),
  customer_id BIGINT NOT NULL REFERENCES customers(id),
  measurer_id BIGINT REFERENCES users(id),
  appointment_time TIMESTAMP,
  actual_start_time TIMESTAMP,
  actual_end_time TIMESTAMP,
  status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'scheduled', 'in_progress', 'completed', 'cancelled')),
  measurement_data JSONB,
  photos JSONB,
  notes TEXT,
  created_by BIGINT NOT NULL REFERENCES users(id),
  updated_by BIGINT REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_measurements_order_id ON measurements(order_id);
CREATE INDEX idx_measurements_customer_id ON measurements(customer_id);
CREATE INDEX idx_measurements_measurer_id ON measurements(measurer_id);
CREATE INDEX idx_measurements_status ON measurements(status);
CREATE INDEX idx_measurements_appointment_time ON measurements(appointment_time);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE measurements IS 'æµ‹é‡ä»»åŠ¡è¡¨';
COMMENT ON COLUMN measurements.id IS 'æµ‹é‡ID';
COMMENT ON COLUMN measurements.order_id IS 'è®¢å•ID';
COMMENT ON COLUMN measurements.customer_id IS 'å®¢æˆ·ID';
COMMENT ON COLUMN measurements.measurer_id IS 'æµ‹é‡å‘˜ID';
COMMENT ON COLUMN measurements.appointment_time IS 'é¢„çº¦æ—¶é—´';
COMMENT ON COLUMN measurements.actual_start_time IS 'å®é™…å¼€å§‹æ—¶é—´';
COMMENT ON COLUMN measurements.actual_end_time IS 'å®é™…ç»“æŸæ—¶é—´';
COMMENT ON COLUMN measurements.status IS 'çŠ¶æ€ï¼špending,scheduled,in_progress,completed,cancelled';
COMMENT ON COLUMN measurements.measurement_data IS 'æµ‹é‡æ•°æ®';
COMMENT ON COLUMN measurements.photos IS 'æµ‹é‡ç…§ç‰‡';
COMMENT ON COLUMN measurements.notes IS 'å¤‡æ³¨';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_measurements_updated_at BEFORE UPDATE ON measurements
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

## ğŸ”§ å®‰è£…ç®¡ç†æ¨¡å—

### å®‰è£…ä»»åŠ¡è¡¨ï¼ˆinstallationsï¼‰
```sql
CREATE TABLE installations (
  id BIGSERIAL PRIMARY KEY,
  order_id BIGINT NOT NULL REFERENCES sales_orders(id),
  customer_id BIGINT NOT NULL REFERENCES customers(id),
  installer_id BIGINT REFERENCES users(id),
  scheduled_date DATE,
  actual_start_time TIMESTAMP,
  actual_end_time TIMESTAMP,
  status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'scheduled', 'in_progress', 'completed', 'cancelled')),
  installation_progress JSONB,
  photos JSONB,
  work_hours DECIMAL(5,2),
  notes TEXT,
  created_by BIGINT NOT NULL REFERENCES users(id),
  updated_by BIGINT REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_installations_order_id ON installations(order_id);
CREATE INDEX idx_installations_customer_id ON installations(customer_id);
CREATE INDEX idx_installations_installer_id ON installations(installer_id);
CREATE INDEX idx_installations_status ON installations(status);
CREATE INDEX idx_installations_scheduled_date ON installations(scheduled_date);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE installations IS 'å®‰è£…ä»»åŠ¡è¡¨';
COMMENT ON COLUMN installations.id IS 'å®‰è£…ID';
COMMENT ON COLUMN installations.order_id IS 'è®¢å•ID';
COMMENT ON COLUMN installations.customer_id IS 'å®¢æˆ·ID';
COMMENT ON COLUMN installations.installer_id IS 'å®‰è£…å‘˜ID';
COMMENT ON COLUMN installations.scheduled_date IS 'è®¡åˆ’å®‰è£…æ—¥æœŸ';
COMMENT ON COLUMN installations.actual_start_time IS 'å®é™…å¼€å§‹æ—¶é—´';
COMMENT ON COLUMN installations.actual_end_time IS 'å®é™…ç»“æŸæ—¶é—´';
COMMENT ON COLUMN installations.status IS 'çŠ¶æ€ï¼špending,scheduled,in_progress,completed,cancelled';
COMMENT ON COLUMN installations.installation_progress IS 'å®‰è£…è¿›åº¦';
COMMENT ON COLUMN installations.photos IS 'å®‰è£…ç…§ç‰‡';
COMMENT ON COLUMN installations.work_hours IS 'å·¥ä½œæ—¶é•¿';
COMMENT ON COLUMN installations.notes IS 'å¤‡æ³¨';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_installations_updated_at BEFORE UPDATE ON installations
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

## ğŸ“¦ äº§å“ç®¡ç†æ¨¡å—

### äº§å“è¡¨ï¼ˆproductsï¼‰
```sql
CREATE TABLE products (
  id BIGSERIAL PRIMARY KEY,
  name VARCHAR(200) NOT NULL,
  code VARCHAR(100) NOT NULL UNIQUE,
  category_id BIGINT REFERENCES product_categories(id),
  description TEXT,
  specifications JSONB,
  unit VARCHAR(20) NOT NULL DEFAULT 'ä»¶',
  price DECIMAL(10,2) NOT NULL DEFAULT 0 CHECK (price >= 0),
  cost_price DECIMAL(10,2) CHECK (cost_price >= 0),
  inventory_type VARCHAR(20) NOT NULL DEFAULT 'unlimited' CHECK (inventory_type IN ('unlimited', 'limited')),
  inventory_quantity INTEGER DEFAULT 0,
  inventory_alert_threshold INTEGER DEFAULT 0,
  status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'pre_launch', 'discontinued')),
  launch_date DATE,
  discontinue_date DATE,
  images JSONB,
  created_by BIGINT NOT NULL REFERENCES users(id),
  updated_by BIGINT REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_products_code ON products(code);
CREATE INDEX idx_products_category_id ON products(category_id);
CREATE INDEX idx_products_status ON products(status);
CREATE INDEX idx_products_name ON products USING gin(to_tsvector('chinese', name));

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE products IS 'äº§å“è¡¨';
COMMENT ON COLUMN products.id IS 'äº§å“ID';
COMMENT ON COLUMN products.name IS 'äº§å“åç§°';
COMMENT ON COLUMN products.code IS 'äº§å“ç¼–ç ';
COMMENT ON COLUMN products.category_id IS 'äº§å“åˆ†ç±»ID';
COMMENT ON COLUMN products.description IS 'äº§å“æè¿°';
COMMENT ON COLUMN products.specifications IS 'äº§å“è§„æ ¼';
COMMENT ON COLUMN products.unit IS 'è®¡é‡å•ä½';
COMMENT ON COLUMN products.price IS 'é”€å”®ä»·æ ¼';
COMMENT ON COLUMN products.cost_price IS 'æˆæœ¬ä»·æ ¼';
COMMENT ON COLUMN products.inventory_type IS 'åº“å­˜ç±»å‹ï¼šunlimited,limited';
COMMENT ON COLUMN products.inventory_quantity IS 'åº“å­˜æ•°é‡';
COMMENT ON COLUMN products.inventory_alert_threshold IS 'åº“å­˜é¢„è­¦é˜ˆå€¼';
COMMENT ON COLUMN products.status IS 'çŠ¶æ€ï¼šactive,inactive,pre_launch,discontinued';
COMMENT ON COLUMN products.launch_date IS 'ä¸Šæ¶æ—¥æœŸ';
COMMENT ON COLUMN products.discontinue_date IS 'ä¸‹æ¶æ—¥æœŸ';
COMMENT ON COLUMN products.images IS 'äº§å“å›¾ç‰‡';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_products_updated_at BEFORE UPDATE ON products
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### äº§å“åˆ†ç±»è¡¨ï¼ˆproduct_categoriesï¼‰
```sql
CREATE TABLE product_categories (
  id BIGSERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  parent_id BIGINT REFERENCES product_categories(id),
  sort_order INTEGER DEFAULT 0,
  description TEXT,
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  created_by BIGINT NOT NULL REFERENCES users(id),
  updated_by BIGINT REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_product_categories_parent_id ON product_categories(parent_id);
CREATE INDEX idx_product_categories_sort_order ON product_categories(sort_order);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE product_categories IS 'äº§å“åˆ†ç±»è¡¨';
COMMENT ON COLUMN product_categories.id IS 'åˆ†ç±»ID';
COMMENT ON COLUMN product_categories.name IS 'åˆ†ç±»åç§°';
COMMENT ON COLUMN product_categories.parent_id IS 'çˆ¶åˆ†ç±»ID';
COMMENT ON COLUMN product_categories.sort_order IS 'æ’åº';
COMMENT ON COLUMN product_categories.description IS 'åˆ†ç±»æè¿°';
COMMENT ON COLUMN product_categories.is_active IS 'æ˜¯å¦å¯ç”¨';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_product_categories_updated_at BEFORE UPDATE ON product_categories
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

## ğŸ’° æŠ¥ä»·ç®¡ç†æ¨¡å—

### æŠ¥ä»·è¡¨ï¼ˆquotationsï¼‰
```sql
CREATE TABLE quotations (
  id BIGSERIAL PRIMARY KEY,
  quote_number VARCHAR(50) NOT NULL UNIQUE,
  customer_id BIGINT NOT NULL REFERENCES customers(id),
  lead_id BIGINT REFERENCES leads(id),
  title VARCHAR(200) NOT NULL,
  total_amount DECIMAL(10,2) NOT NULL DEFAULT 0 CHECK (total_amount >= 0),
  discount_amount DECIMAL(10,2) NOT NULL DEFAULT 0 CHECK (discount_amount >= 0),
  final_amount DECIMAL(10,2) NOT NULL DEFAULT 0 CHECK (final_amount >= 0),
  valid_until DATE NOT NULL,
  status VARCHAR(20) NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'pending_approval', 'approved', 'sent', 'accepted', 'rejected', 'expired')),
  approval_status VARCHAR(20) DEFAULT 'pending' CHECK (approval_status IN ('pending', 'approved', 'rejected')),
  approved_by BIGINT REFERENCES users(id),
  approved_at TIMESTAMP,
  sent_at TIMESTAMP,
  notes TEXT,
  terms_conditions TEXT,
  created_by BIGINT NOT NULL REFERENCES users(id),
  updated_by BIGINT REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_quotations_quote_number ON quotations(quote_number);
CREATE INDEX idx_quotations_customer_id ON quotations(customer_id);
CREATE INDEX idx_quotations_lead_id ON quotations(lead_id);
CREATE INDEX idx_quotations_status ON quotations(status);
CREATE INDEX idx_quotations_valid_until ON quotations(valid_until);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE quotations IS 'æŠ¥ä»·è¡¨';
COMMENT ON COLUMN quotations.id IS 'æŠ¥ä»·ID';
COMMENT ON COLUMN quotations.quote_number IS 'æŠ¥ä»·å•å·';
COMMENT ON COLUMN quotations.customer_id IS 'å®¢æˆ·ID';
COMMENT ON COLUMN quotations.lead_id IS 'çº¿ç´¢ID';
COMMENT ON COLUMN quotations.title IS 'æŠ¥ä»·æ ‡é¢˜';
COMMENT ON COLUMN quotations.total_amount IS 'æ€»é‡‘é¢';
COMMENT ON COLUMN quotations.discount_amount IS 'æŠ˜æ‰£é‡‘é¢';
COMMENT ON COLUMN quotations.final_amount IS 'æœ€ç»ˆé‡‘é¢';
COMMENT ON COLUMN quotations.valid_until IS 'æœ‰æ•ˆæœŸè‡³';
COMMENT ON COLUMN quotations.status IS 'çŠ¶æ€ï¼šdraft,pending_approval,approved,sent,accepted,rejected,expired';
COMMENT ON COLUMN quotations.approval_status IS 'å®¡æ‰¹çŠ¶æ€ï¼špending,approved,rejected';
COMMENT ON COLUMN quotations.approved_by IS 'å®¡æ‰¹äººID';
COMMENT ON COLUMN quotations.approved_at IS 'å®¡æ‰¹æ—¶é—´';
COMMENT ON COLUMN quotations.sent_at IS 'å‘é€æ—¶é—´';
COMMENT ON COLUMN quotations.notes IS 'å¤‡æ³¨';
COMMENT ON COLUMN quotations.terms_conditions IS 'æ¡æ¬¾æ¡ä»¶';

-- æ·»åŠ ä¸šåŠ¡é€»è¾‘éªŒè¯çº¦æŸ
ALTER TABLE quotations ADD CONSTRAINT chk_quotations_discount_not_exceed_total
  CHECK (discount_amount <= total_amount);

ALTER TABLE quotations ADD CONSTRAINT chk_quotations_final_amount_logic
  CHECK (final_amount = total_amount - discount_amount);

ALTER TABLE quotations ADD CONSTRAINT chk_quotations_valid_until_future
  CHECK (valid_until >= CURRENT_DATE);

ALTER TABLE quotations ADD CONSTRAINT chk_quotations_approval_logic
  CHECK (
    (status = 'pending_approval' AND approval_status = 'pending') OR
    (status = 'approved' AND approval_status = 'approved' AND approved_by IS NOT NULL AND approved_at IS NOT NULL) OR
    (status IN ('draft', 'sent', 'accepted', 'rejected', 'expired'))
  );

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_quotations_updated_at BEFORE UPDATE ON quotations
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### æŠ¥ä»·æ˜ç»†è¡¨ï¼ˆquotation_itemsï¼‰
```sql
CREATE TABLE quotation_items (
  id BIGSERIAL PRIMARY KEY,
  quotation_id BIGINT NOT NULL REFERENCES quotations(id) ON DELETE CASCADE,
  product_id BIGINT REFERENCES products(id),
  product_name VARCHAR(200) NOT NULL,
  product_code VARCHAR(100),
  specifications TEXT,
  unit VARCHAR(20) NOT NULL DEFAULT 'ä»¶',
  quantity DECIMAL(10,2) NOT NULL DEFAULT 1 CHECK (quantity >= 0),
  unit_price DECIMAL(10,2) NOT NULL DEFAULT 0 CHECK (unit_price >= 0),
  total_price DECIMAL(10,2) NOT NULL DEFAULT 0 CHECK (total_price >= 0),
  discount_rate DECIMAL(5,2) DEFAULT 0 CHECK (discount_rate >= 0 AND discount_rate <= 100),
  discount_amount DECIMAL(10,2) DEFAULT 0 CHECK (discount_amount >= 0),
  final_price DECIMAL(10,2) NOT NULL DEFAULT 0 CHECK (final_price >= 0),
  sort_order INTEGER DEFAULT 0,
  notes TEXT,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_quotation_items_quotation_id ON quotation_items(quotation_id);
CREATE INDEX idx_quotation_items_product_id ON quotation_items(product_id);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE quotation_items IS 'æŠ¥ä»·æ˜ç»†è¡¨';
COMMENT ON COLUMN quotation_items.id IS 'æ˜ç»†ID';
COMMENT ON COLUMN quotation_items.quotation_id IS 'æŠ¥ä»·ID';
COMMENT ON COLUMN quotation_items.product_id IS 'äº§å“ID';
COMMENT ON COLUMN quotation_items.product_name IS 'äº§å“åç§°';
COMMENT ON COLUMN quotation_items.product_code IS 'äº§å“ç¼–ç ';
COMMENT ON COLUMN quotation_items.specifications IS 'è§„æ ¼è¯´æ˜';
COMMENT ON COLUMN quotation_items.unit IS 'è®¡é‡å•ä½';
COMMENT ON COLUMN quotation_items.quantity IS 'æ•°é‡';
COMMENT ON COLUMN quotation_items.unit_price IS 'å•ä»·';
COMMENT ON COLUMN quotation_items.total_price IS 'å°è®¡';
COMMENT ON COLUMN quotation_items.discount_rate IS 'æŠ˜æ‰£ç‡';
COMMENT ON COLUMN quotation_items.discount_amount IS 'æŠ˜æ‰£é‡‘é¢';
COMMENT ON COLUMN quotation_items.final_price IS 'æœ€ç»ˆä»·æ ¼';
COMMENT ON COLUMN quotation_items.sort_order IS 'æ’åº';
COMMENT ON COLUMN quotation_items.notes IS 'å¤‡æ³¨';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_quotation_items_updated_at BEFORE UPDATE ON quotation_items
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

## ğŸ›ï¸ ç§¯åˆ†å•†åŸæ¨¡å—

### å•†åŸå•†å“è¡¨ï¼ˆmall_itemsï¼‰
```sql
CREATE TABLE mall_items (
  id BIGSERIAL PRIMARY KEY,
  name VARCHAR(200) NOT NULL,
  description TEXT,
  category VARCHAR(50) NOT NULL,
  points_required INTEGER NOT NULL DEFAULT 0 CHECK (points_required >= 0),
  cash_required DECIMAL(10,2) DEFAULT 0 CHECK (cash_required >= 0),
  stock_quantity INTEGER DEFAULT -1,
  images JSONB,
  status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'out_of_stock')),
  sort_order INTEGER DEFAULT 0,
  start_time TIMESTAMP,
  end_time TIMESTAMP,
  exchange_limit INTEGER DEFAULT 0,
  created_by BIGINT NOT NULL REFERENCES users(id),
  updated_by BIGINT REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_mall_items_category ON mall_items(category);
CREATE INDEX idx_mall_items_status ON mall_items(status);
CREATE INDEX idx_mall_items_points_required ON mall_items(points_required);
CREATE INDEX idx_mall_items_sort_order ON mall_items(sort_order);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE mall_items IS 'å•†åŸå•†å“è¡¨';
COMMENT ON COLUMN mall_items.id IS 'å•†å“ID';
COMMENT ON COLUMN mall_items.name IS 'å•†å“åç§°';
COMMENT ON COLUMN mall_items.description IS 'å•†å“æè¿°';
COMMENT ON COLUMN mall_items.category IS 'å•†å“åˆ†ç±»';
COMMENT ON COLUMN mall_items.points_required IS 'æ‰€éœ€ç§¯åˆ†';
COMMENT ON COLUMN mall_items.cash_required IS 'æ‰€éœ€ç°é‡‘';
COMMENT ON COLUMN mall_items.stock_quantity IS 'åº“å­˜æ•°é‡ï¼ˆ-1è¡¨ç¤ºæ— é™ï¼‰';
COMMENT ON COLUMN mall_items.images IS 'å•†å“å›¾ç‰‡';
COMMENT ON COLUMN mall_items.status IS 'çŠ¶æ€ï¼šactive,inactive,out_of_stock';
COMMENT ON COLUMN mall_items.sort_order IS 'æ’åº';
COMMENT ON COLUMN mall_items.start_time IS 'å¼€å§‹æ—¶é—´';
COMMENT ON COLUMN mall_items.end_time IS 'ç»“æŸæ—¶é—´';
COMMENT ON COLUMN mall_items.exchange_limit IS 'å…‘æ¢é™åˆ¶ï¼ˆ0è¡¨ç¤ºæ— é™åˆ¶ï¼‰';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_mall_items_updated_at BEFORE UPDATE ON mall_items
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### å…‘æ¢è®¢å•è¡¨ï¼ˆexchange_ordersï¼‰
```sql
CREATE TABLE exchange_orders (
  id BIGSERIAL PRIMARY KEY,
  order_number VARCHAR(50) NOT NULL UNIQUE,
  user_id BIGINT NOT NULL REFERENCES users(id),
  mall_item_id BIGINT NOT NULL REFERENCES mall_items(id),
  item_name VARCHAR(200) NOT NULL,
  quantity INTEGER NOT NULL DEFAULT 1 CHECK (quantity > 0),
  points_used INTEGER NOT NULL DEFAULT 0 CHECK (points_used >= 0),
  cash_used DECIMAL(10,2) DEFAULT 0 CHECK (cash_used >= 0),
  status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'confirmed', 'shipped', 'completed', 'cancelled')),
  shipping_address JSONB,
  tracking_number VARCHAR(100),
  notes TEXT,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_exchange_orders_order_number ON exchange_orders(order_number);
CREATE INDEX idx_exchange_orders_user_id ON exchange_orders(user_id);
CREATE INDEX idx_exchange_orders_mall_item_id ON exchange_orders(mall_item_id);
CREATE INDEX idx_exchange_orders_status ON exchange_orders(status);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE exchange_orders IS 'å…‘æ¢è®¢å•è¡¨';
COMMENT ON COLUMN exchange_orders.id IS 'è®¢å•ID';
COMMENT ON COLUMN exchange_orders.order_number IS 'è®¢å•å·';
COMMENT ON COLUMN exchange_orders.user_id IS 'ç”¨æˆ·ID';
COMMENT ON COLUMN exchange_orders.mall_item_id IS 'å•†å“ID';
COMMENT ON COLUMN exchange_orders.item_name IS 'å•†å“åç§°';
COMMENT ON COLUMN exchange_orders.quantity IS 'å…‘æ¢æ•°é‡';
COMMENT ON COLUMN exchange_orders.points_used IS 'ä½¿ç”¨ç§¯åˆ†';
COMMENT ON COLUMN exchange_orders.cash_used IS 'ä½¿ç”¨ç°é‡‘';
COMMENT ON COLUMN exchange_orders.status IS 'çŠ¶æ€ï¼špending,confirmed,shipped,completed,cancelled';
COMMENT ON COLUMN exchange_orders.shipping_address IS 'æ”¶è´§åœ°å€';
COMMENT ON COLUMN exchange_orders.tracking_number IS 'å¿«é€’å•å·';
COMMENT ON COLUMN exchange_orders.notes IS 'å¤‡æ³¨';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_exchange_orders_updated_at BEFORE UPDATE ON exchange_orders
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

## ğŸ“ æ–‡ä»¶ç®¡ç†æ¨¡å—

### æ–‡ä»¶è¡¨ï¼ˆfilesï¼‰
```sql
CREATE TABLE files (
  id BIGSERIAL PRIMARY KEY,
  original_name VARCHAR(255) NOT NULL,
  file_name VARCHAR(255) NOT NULL,
  file_path VARCHAR(500) NOT NULL,
  file_size BIGINT NOT NULL DEFAULT 0,
  mime_type VARCHAR(100),
  file_hash VARCHAR(64),
  category VARCHAR(50) NOT NULL,
  business_type VARCHAR(50),
  business_id BIGINT,
  version INTEGER DEFAULT 1,
  parent_file_id BIGINT REFERENCES files(id),
  is_public BOOLEAN NOT NULL DEFAULT FALSE,
  download_count INTEGER DEFAULT 0,
  tags JSONB,
  metadata JSONB,
  uploaded_by BIGINT NOT NULL REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_files_file_name ON files(file_name);
CREATE INDEX idx_files_category ON files(category);
CREATE INDEX idx_files_business_type_id ON files(business_type, business_id);
CREATE INDEX idx_files_uploaded_by ON files(uploaded_by);
CREATE INDEX idx_files_file_hash ON files(file_hash);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE files IS 'æ–‡ä»¶è¡¨';
COMMENT ON COLUMN files.id IS 'æ–‡ä»¶ID';
COMMENT ON COLUMN files.original_name IS 'åŸå§‹æ–‡ä»¶å';
COMMENT ON COLUMN files.file_name IS 'å­˜å‚¨æ–‡ä»¶å';
COMMENT ON COLUMN files.file_path IS 'æ–‡ä»¶è·¯å¾„';
COMMENT ON COLUMN files.file_size IS 'æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰';
COMMENT ON COLUMN files.mime_type IS 'MIMEç±»å‹';
COMMENT ON COLUMN files.file_hash IS 'æ–‡ä»¶å“ˆå¸Œå€¼';
COMMENT ON COLUMN files.category IS 'æ–‡ä»¶åˆ†ç±»';
COMMENT ON COLUMN files.business_type IS 'ä¸šåŠ¡ç±»å‹';
COMMENT ON COLUMN files.business_id IS 'ä¸šåŠ¡ID';
COMMENT ON COLUMN files.version IS 'ç‰ˆæœ¬å·';
COMMENT ON COLUMN files.parent_file_id IS 'çˆ¶æ–‡ä»¶ID';
COMMENT ON COLUMN files.is_public IS 'æ˜¯å¦å…¬å¼€';
COMMENT ON COLUMN files.download_count IS 'ä¸‹è½½æ¬¡æ•°';
COMMENT ON COLUMN files.tags IS 'æ ‡ç­¾';
COMMENT ON COLUMN files.metadata IS 'å…ƒæ•°æ®';
COMMENT ON COLUMN files.uploaded_by IS 'ä¸Šä¼ äººID';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_files_updated_at BEFORE UPDATE ON files
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

## âœ… å®¡æ‰¹æµç¨‹æ¨¡å—

### å®¡æ‰¹æµç¨‹è¡¨ï¼ˆapproval_flowsï¼‰
```sql
CREATE TABLE approval_flows (
  id BIGSERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  business_type VARCHAR(50) NOT NULL,
  description TEXT,
  flow_config JSONB NOT NULL,
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  created_by BIGINT NOT NULL REFERENCES users(id),
  updated_by BIGINT REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_approval_flows_business_type ON approval_flows(business_type);
CREATE INDEX idx_approval_flows_is_active ON approval_flows(is_active);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE approval_flows IS 'å®¡æ‰¹æµç¨‹è¡¨';
COMMENT ON COLUMN approval_flows.id IS 'æµç¨‹ID';
COMMENT ON COLUMN approval_flows.name IS 'æµç¨‹åç§°';
COMMENT ON COLUMN approval_flows.business_type IS 'ä¸šåŠ¡ç±»å‹';
COMMENT ON COLUMN approval_flows.description IS 'æµç¨‹æè¿°';
COMMENT ON COLUMN approval_flows.flow_config IS 'æµç¨‹é…ç½®';
COMMENT ON COLUMN approval_flows.is_active IS 'æ˜¯å¦å¯ç”¨';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_approval_flows_updated_at BEFORE UPDATE ON approval_flows
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### å®¡æ‰¹å®ä¾‹è¡¨ï¼ˆapproval_instancesï¼‰
```sql
CREATE TABLE approval_instances (
  id BIGSERIAL PRIMARY KEY,
  flow_id BIGINT NOT NULL REFERENCES approval_flows(id),
  business_type VARCHAR(50) NOT NULL,
  business_id BIGINT NOT NULL,
  title VARCHAR(200) NOT NULL,
  current_step INTEGER DEFAULT 1,
  status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected', 'cancelled')),
  applicant_id BIGINT NOT NULL REFERENCES users(id),
  application_data JSONB,
  result_data JSONB,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_approval_instances_flow_id ON approval_instances(flow_id);
CREATE INDEX idx_approval_instances_business_type_id ON approval_instances(business_type, business_id);
CREATE INDEX idx_approval_instances_status ON approval_instances(status);
CREATE INDEX idx_approval_instances_applicant_id ON approval_instances(applicant_id);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE approval_instances IS 'å®¡æ‰¹å®ä¾‹è¡¨';
COMMENT ON COLUMN approval_instances.id IS 'å®ä¾‹ID';
COMMENT ON COLUMN approval_instances.flow_id IS 'æµç¨‹ID';
COMMENT ON COLUMN approval_instances.business_type IS 'ä¸šåŠ¡ç±»å‹';
COMMENT ON COLUMN approval_instances.business_id IS 'ä¸šåŠ¡ID';
COMMENT ON COLUMN approval_instances.title IS 'å®¡æ‰¹æ ‡é¢˜';
COMMENT ON COLUMN approval_instances.current_step IS 'å½“å‰æ­¥éª¤';
COMMENT ON COLUMN approval_instances.status IS 'çŠ¶æ€ï¼špending,approved,rejected,cancelled';
COMMENT ON COLUMN approval_instances.applicant_id IS 'ç”³è¯·äººID';
COMMENT ON COLUMN approval_instances.application_data IS 'ç”³è¯·æ•°æ®';
COMMENT ON COLUMN approval_instances.result_data IS 'å®¡æ‰¹ç»“æœæ•°æ®';

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_approval_instances_updated_at BEFORE UPDATE ON approval_instances
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### å®¡æ‰¹è®°å½•è¡¨ï¼ˆapproval_recordsï¼‰
```sql
CREATE TABLE approval_records (
  id BIGSERIAL PRIMARY KEY,
  instance_id BIGINT NOT NULL REFERENCES approval_instances(id) ON DELETE CASCADE,
  step_number INTEGER NOT NULL,
  approver_id BIGINT NOT NULL REFERENCES users(id),
  action VARCHAR(20) NOT NULL CHECK (action IN ('approve', 'reject', 'transfer')),
  comment TEXT,
  processed_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_approval_records_instance_id ON approval_records(instance_id);
CREATE INDEX idx_approval_records_approver_id ON approval_records(approver_id);
CREATE INDEX idx_approval_records_step_number ON approval_records(step_number);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE approval_records IS 'å®¡æ‰¹è®°å½•è¡¨';
COMMENT ON COLUMN approval_records.id IS 'è®°å½•ID';
COMMENT ON COLUMN approval_records.instance_id IS 'å®ä¾‹ID';
COMMENT ON COLUMN approval_records.step_number IS 'æ­¥éª¤å·';
COMMENT ON COLUMN approval_records.approver_id IS 'å®¡æ‰¹äººID';
COMMENT ON COLUMN approval_records.action IS 'æ“ä½œï¼šapprove,reject,transfer';
COMMENT ON COLUMN approval_records.comment IS 'å®¡æ‰¹æ„è§';
COMMENT ON COLUMN approval_records.processed_at IS 'å¤„ç†æ—¶é—´';
```

## ğŸ“‹ ç¼–å·ç”Ÿæˆæœ€ä½³å®è·µ

### æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **ç¼“å­˜ç­–ç•¥**
   - ä½¿ç”¨Redisç¼“å­˜å½“æ—¥æµæ°´å·ï¼Œå‡å°‘æ•°æ®åº“è®¿é—®
   - ç¼“å­˜ç”Ÿæˆå™¨é…ç½®ï¼Œé¿å…é‡å¤æŸ¥è¯¢
   - è®¾ç½®åˆç†çš„ç¼“å­˜è¿‡æœŸæ—¶é—´

2. **å¹¶å‘æ§åˆ¶**
   - ä½¿ç”¨RedisåŸå­æ“ä½œï¼ˆINCRï¼‰ä¿è¯å¹¶å‘å®‰å…¨
   - æ•°æ®åº“å±‚é¢ä½¿ç”¨è¡Œé”é˜²æ­¢é‡å¤
   - æ‰¹é‡ç”Ÿæˆæ—¶ä½¿ç”¨INCRBYå‡å°‘ç½‘ç»œå¼€é”€

3. **å®¹é”™æœºåˆ¶**
   - Redisä¸å¯ç”¨æ—¶é™çº§åˆ°æ•°æ®åº“ç”Ÿæˆ
   - å®šæœŸåŒæ­¥Rediså’Œæ•°æ®åº“çš„æµæ°´å·
   - å¼‚å¸¸æƒ…å†µä¸‹çš„ç¼–å·å›æ”¶æœºåˆ¶

### ç›‘æ§å’Œå‘Šè­¦

```sql
-- ç¼–å·ç”Ÿæˆç›‘æ§è§†å›¾
CREATE VIEW number_generation_stats AS
SELECT 
  business_type,
  DATE(generation_date) as date,
  COUNT(*) as total_generated,
  MAX(sequence_number) as max_sequence,
  MIN(sequence_number) as min_sequence
FROM number_generation_logs
GROUP BY business_type, DATE(generation_date);

-- ç¼–å·ä½¿ç”¨ç‡ç›‘æ§
CREATE VIEW number_usage_rate AS
SELECT 
  ng.business_type,
  ng.current_sequence,
  POWER(10, ng.sequence_length) as max_capacity,
  (ng.current_sequence / POWER(10, ng.sequence_length)) * 100 as usage_rate
FROM number_generators ng;
```

### æ³¨æ„äº‹é¡¹

1. **ç¼–å·é•¿åº¦è§„åˆ’**
   - æ ¹æ®ä¸šåŠ¡é‡é¢„ä¼°é€‰æ‹©åˆé€‚çš„æµæ°´å·é•¿åº¦
   - é¢„ç•™è¶³å¤Ÿçš„å¢é•¿ç©ºé—´
   - è€ƒè™‘æ˜¾ç¤ºå’Œå­˜å‚¨çš„ä¾¿åˆ©æ€§

2. **æ—¥æœŸåˆ‡æ¢å¤„ç†**
   - ç¡®ä¿è·¨æ—¥æœŸæ—¶æµæ°´å·æ­£ç¡®é‡ç½®
   - å¤„ç†æ—¶åŒºé—®é¢˜
   - è€ƒè™‘èŠ‚å‡æ—¥å’Œç‰¹æ®Šæ—¥æœŸ

3. **æ•°æ®ä¸€è‡´æ€§**
   - å®šæœŸæ ¡éªŒRediså’Œæ•°æ®åº“çš„ä¸€è‡´æ€§
   - å¤„ç†ç¼“å­˜å¤±æ•ˆæ—¶çš„æ•°æ®åŒæ­¥
   - å»ºç«‹æ•°æ®ä¿®å¤æœºåˆ¶

4. **ä¸šåŠ¡æ‰©å±•**
   - æ–°å¢ä¸šåŠ¡ç±»å‹æ—¶çš„é…ç½®ç®¡ç†
   - ç¼–å·æ ¼å¼å˜æ›´çš„å…¼å®¹æ€§å¤„ç†
   - å†å²æ•°æ®çš„è¿ç§»ç­–ç•¥

## ğŸ“± ç”µè¯å·ç æ ¼å¼éªŒè¯çº¦æŸ

ä¸ºç¡®ä¿ç”µè¯å·ç æ•°æ®çš„ä¸€è‡´æ€§å’Œæœ‰æ•ˆæ€§ï¼Œå¯¹æ‰€æœ‰ç”µè¯å­—æ®µæ·»åŠ æ ¼å¼éªŒè¯çº¦æŸï¼š

```sql
-- ç”µè¯å·ç æ ¼å¼éªŒè¯å‡½æ•°
CREATE OR REPLACE FUNCTION validate_phone_format(phone_number VARCHAR(15))
RETURNS BOOLEAN AS $$
BEGIN
  -- å…è®¸ç©ºå€¼
  IF phone_number IS NULL OR phone_number = '' THEN
    RETURN TRUE;
  END IF;
  
  -- éªŒè¯ä¸­å›½å¤§é™†æ‰‹æœºå·æ ¼å¼ï¼š1å¼€å¤´ï¼Œç¬¬äºŒä½ä¸º3-9ï¼Œæ€»é•¿åº¦11ä½
  -- éªŒè¯å›ºå®šç”µè¯æ ¼å¼ï¼šåŒºå·+å·ç ï¼Œæ”¯æŒå¸¦è¿å­—ç¬¦
  RETURN phone_number ~ '^(1[3-9]\d{9}|0\d{2,3}-?\d{7,8})$';
END;
$$ LANGUAGE plpgsql;

-- ä¸ºä¸»è¦è¡¨çš„ç”µè¯å­—æ®µæ·»åŠ æ£€æŸ¥çº¦æŸ
ALTER TABLE users ADD CONSTRAINT chk_users_phone 
  CHECK (validate_phone_format(phone));

ALTER TABLE customers ADD CONSTRAINT chk_customers_phone 
  CHECK (validate_phone_format(phone));

ALTER TABLE leads ADD CONSTRAINT chk_leads_customer_phone 
  CHECK (validate_phone_format(customer_phone));

ALTER TABLE sales_orders ADD CONSTRAINT chk_sales_orders_customer_phone 
  CHECK (validate_phone_format(customer_phone));

ALTER TABLE sales_orders ADD CONSTRAINT chk_sales_orders_delivery_phone 
  CHECK (validate_phone_format(delivery_phone));

-- ä¸ºå…¶ä»–æ¨¡å—çš„ç”µè¯å­—æ®µæ·»åŠ çº¦æŸ
ALTER TABLE measurement_orders ADD CONSTRAINT chk_measurement_orders_customer_phone 
  CHECK (validate_phone_format(customer_phone));

ALTER TABLE installation_orders ADD CONSTRAINT chk_installation_orders_customer_phone 
  CHECK (validate_phone_format(customer_phone));

ALTER TABLE quotes ADD CONSTRAINT chk_quotes_customer_phone 
  CHECK (validate_phone_format(customer_phone));

ALTER TABLE mall_orders ADD CONSTRAINT chk_mall_orders_receiver_phone 
  CHECK (validate_phone_format(receiver_phone));

-- æ·»åŠ çº¦æŸè¯´æ˜æ³¨é‡Š
COMMENT ON FUNCTION validate_phone_format IS 'ç”µè¯å·ç æ ¼å¼éªŒè¯å‡½æ•°ï¼Œæ”¯æŒä¸­å›½å¤§é™†æ‰‹æœºå·å’Œå›ºå®šç”µè¯';

-- é‚®ç®±æ ¼å¼éªŒè¯å‡½æ•°
CREATE OR REPLACE FUNCTION validate_email_format(email_address VARCHAR(100))
RETURNS BOOLEAN AS $$
BEGIN
  -- å…è®¸ç©ºå€¼
  IF email_address IS NULL OR email_address = '' THEN
    RETURN TRUE;
  END IF;
  
  -- éªŒè¯é‚®ç®±æ ¼å¼ï¼šåŸºæœ¬çš„é‚®ç®±æ ¼å¼éªŒè¯
  RETURN email_address ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- ä¸ºä¸»è¦è¡¨çš„é‚®ç®±å­—æ®µæ·»åŠ æ£€æŸ¥çº¦æŸ
ALTER TABLE users ADD CONSTRAINT chk_users_email 
  CHECK (validate_email_format(email));

ALTER TABLE customers ADD CONSTRAINT chk_customers_email 
  CHECK (validate_email_format(email));

ALTER TABLE leads ADD CONSTRAINT chk_leads_customer_email 
  CHECK (validate_email_format(customer_email));

ALTER TABLE sales_orders ADD CONSTRAINT chk_sales_orders_customer_email 
  CHECK (validate_email_format(customer_email));

-- æ·»åŠ é‚®ç®±éªŒè¯å‡½æ•°è¯´æ˜æ³¨é‡Š
COMMENT ON FUNCTION validate_email_format IS 'é‚®ç®±æ ¼å¼éªŒè¯å‡½æ•°ï¼ŒéªŒè¯åŸºæœ¬çš„é‚®ç®±æ ¼å¼';

-- çŠ¶æ€å˜æ›´æ—¥å¿—è¡¨
CREATE TABLE status_change_logs (
    id BIGSERIAL PRIMARY KEY,
    table_name VARCHAR(50) NOT NULL,
    record_id BIGINT NOT NULL,
    field_name VARCHAR(50) NOT NULL,
    old_value VARCHAR(100),
    new_value VARCHAR(100) NOT NULL,
    changed_by BIGINT NOT NULL REFERENCES users(id),
    changed_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    reason TEXT,
    ip_address INET,
    user_agent TEXT
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_status_change_logs_table_record ON status_change_logs(table_name, record_id);
CREATE INDEX idx_status_change_logs_changed_by ON status_change_logs(changed_by);
CREATE INDEX idx_status_change_logs_changed_at ON status_change_logs(changed_at);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE status_change_logs IS 'çŠ¶æ€å˜æ›´æ—¥å¿—è¡¨';
COMMENT ON COLUMN status_change_logs.table_name IS 'è¡¨å';
COMMENT ON COLUMN status_change_logs.record_id IS 'è®°å½•ID';
COMMENT ON COLUMN status_change_logs.field_name IS 'å­—æ®µå';
COMMENT ON COLUMN status_change_logs.old_value IS 'æ—§å€¼';
COMMENT ON COLUMN status_change_logs.new_value IS 'æ–°å€¼';
COMMENT ON COLUMN status_change_logs.changed_by IS 'å˜æ›´äººID';
COMMENT ON COLUMN status_change_logs.changed_at IS 'å˜æ›´æ—¶é—´';
COMMENT ON COLUMN status_change_logs.reason IS 'å˜æ›´åŸå› ';
COMMENT ON COLUMN status_change_logs.ip_address IS 'IPåœ°å€';
COMMENT ON COLUMN status_change_logs.user_agent IS 'ç”¨æˆ·ä»£ç†';

-- çŠ¶æ€å˜æ›´éªŒè¯å‡½æ•°
CREATE OR REPLACE FUNCTION validate_status_transition(
    p_table_name VARCHAR(50),
    p_field_name VARCHAR(50),
    p_old_status VARCHAR(50),
    p_new_status VARCHAR(50)
) RETURNS BOOLEAN AS $$
BEGIN
    -- é”€å”®è®¢å•çŠ¶æ€å˜æ›´è§„åˆ™
    IF p_table_name = 'sales_orders' AND p_field_name = 'status' THEN
        RETURN CASE 
            WHEN p_old_status = 'INITIAL' AND p_new_status IN ('CONFIRMED', 'CANCELLED') THEN TRUE
            WHEN p_old_status = 'CONFIRMED' AND p_new_status IN ('MEASURING', 'CANCELLED') THEN TRUE
            WHEN p_old_status = 'MEASURING' AND p_new_status IN ('MEASURED', 'CANCELLED') THEN TRUE
            WHEN p_old_status = 'MEASURED' AND p_new_status IN ('QUOTED', 'CANCELLED') THEN TRUE
            WHEN p_old_status = 'QUOTED' AND p_new_status IN ('PAID', 'CANCELLED') THEN TRUE
            WHEN p_old_status = 'PAID' AND p_new_status IN ('PRODUCING', 'CANCELLED') THEN TRUE
            WHEN p_old_status = 'PRODUCING' AND p_new_status IN ('PRODUCED', 'CANCELLED') THEN TRUE
            WHEN p_old_status = 'PRODUCED' AND p_new_status IN ('DELIVERING', 'CANCELLED') THEN TRUE
            WHEN p_old_status = 'DELIVERING' AND p_new_status IN ('DELIVERED', 'CANCELLED') THEN TRUE
            WHEN p_old_status = 'DELIVERED' AND p_new_status IN ('INSTALLING', 'CANCELLED') THEN TRUE
            WHEN p_old_status = 'INSTALLING' AND p_new_status IN ('INSTALLED', 'CANCELLED') THEN TRUE
            WHEN p_old_status = 'INSTALLED' AND p_new_status = 'COMPLETED' THEN TRUE
            ELSE FALSE
        END;
    END IF;
    
    -- çº¿ç´¢çŠ¶æ€å˜æ›´è§„åˆ™
    IF p_table_name = 'leads' AND p_field_name = 'status' THEN
        RETURN CASE 
            WHEN p_old_status = 'new' AND p_new_status IN ('assigned', 'invalid') THEN TRUE
            WHEN p_old_status = 'assigned' AND p_new_status IN ('following', 'invalid') THEN TRUE
            WHEN p_old_status = 'following' AND p_new_status IN ('converted', 'invalid') THEN TRUE
            ELSE FALSE
        END;
    END IF;
    
    -- æŠ¥ä»·çŠ¶æ€å˜æ›´è§„åˆ™
    IF p_table_name = 'quotations' AND p_field_name = 'status' THEN
        RETURN CASE 
            WHEN p_old_status = 'draft' AND p_new_status IN ('pending_approval', 'expired') THEN TRUE
            WHEN p_old_status = 'pending_approval' AND p_new_status IN ('approved', 'rejected') THEN TRUE
            WHEN p_old_status = 'approved' AND p_new_status IN ('sent', 'expired') THEN TRUE
            WHEN p_old_status = 'sent' AND p_new_status IN ('accepted', 'rejected', 'expired') THEN TRUE
            ELSE FALSE
        END;
    END IF;
    
    -- é»˜è®¤å…è®¸æ‰€æœ‰å˜æ›´ï¼ˆå¯¹äºæœªå®šä¹‰è§„åˆ™çš„è¡¨ï¼‰
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- çŠ¶æ€å˜æ›´æ—¥å¿—è®°å½•å‡½æ•°
CREATE OR REPLACE FUNCTION log_status_change() RETURNS TRIGGER AS $$
DECLARE
    old_val TEXT;
    new_val TEXT;
    field_name TEXT;
BEGIN
    -- è·å–è§¦å‘å™¨å‚æ•°ä¸­çš„å­—æ®µå
    field_name := TG_ARGV[0];
    
    -- è·å–æ—§å€¼å’Œæ–°å€¼
    EXECUTE format('SELECT ($1).%I::TEXT', field_name) INTO old_val USING OLD;
    EXECUTE format('SELECT ($1).%I::TEXT', field_name) INTO new_val USING NEW;
    
    -- å¦‚æœå€¼å‘ç”Ÿå˜åŒ–ï¼Œè®°å½•æ—¥å¿—
    IF old_val IS DISTINCT FROM new_val THEN
        -- éªŒè¯çŠ¶æ€å˜æ›´æ˜¯å¦åˆæ³•
        IF NOT validate_status_transition(TG_TABLE_NAME, field_name, old_val, new_val) THEN
            RAISE EXCEPTION 'éæ³•çš„çŠ¶æ€å˜æ›´: % ä» % åˆ° %', field_name, old_val, new_val;
        END IF;
        
        -- è®°å½•çŠ¶æ€å˜æ›´æ—¥å¿—
        INSERT INTO status_change_logs (
            table_name, record_id, field_name, old_value, new_value, changed_by
        ) VALUES (
            TG_TABLE_NAME, NEW.id, field_name, old_val, new_val, 
            COALESCE(NEW.updated_by, NEW.created_by, 1) -- é»˜è®¤ç”¨æˆ·IDä¸º1
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ä¸ºå…³é”®è¡¨åˆ›å»ºçŠ¶æ€å˜æ›´è§¦å‘å™¨
CREATE TRIGGER trg_sales_orders_status_change
    BEFORE UPDATE ON sales_orders
    FOR EACH ROW
    EXECUTE FUNCTION log_status_change('status');

CREATE TRIGGER trg_leads_status_change
    BEFORE UPDATE ON leads
    FOR EACH ROW
    EXECUTE FUNCTION log_status_change('status');

CREATE TRIGGER trg_quotations_status_change
    BEFORE UPDATE ON quotations
    FOR EACH ROW
    EXECUTE FUNCTION log_status_change('status');

-- æ€§èƒ½ä¼˜åŒ–ç´¢å¼•
-- å¤åˆç´¢å¼•ç”¨äºå¸¸è§æŸ¥è¯¢åœºæ™¯

-- é”€å”®è®¢å•ç›¸å…³å¤åˆç´¢å¼•
CREATE INDEX idx_sales_orders_customer_status ON sales_orders(customer_id, status);
CREATE INDEX idx_sales_orders_sales_date ON sales_orders(sales_id, created_at);
CREATE INDEX idx_sales_orders_status_amount ON sales_orders(status, total_amount);
CREATE INDEX idx_sales_orders_date_range ON sales_orders(created_at, status) WHERE deleted_at IS NULL;

-- çº¿ç´¢ç›¸å…³å¤åˆç´¢å¼•
CREATE INDEX idx_leads_assigned_status ON leads(assigned_to, status);
CREATE INDEX idx_leads_source_status ON leads(source, status);
CREATE INDEX idx_leads_follow_time ON leads(next_follow_time) WHERE status IN ('assigned', 'following');
CREATE INDEX idx_leads_conversion ON leads(converted_at, converted_to_order_id) WHERE status = 'converted';

-- æŠ¥ä»·ç›¸å…³å¤åˆç´¢å¼•
CREATE INDEX idx_quotations_customer_status ON quotations(customer_id, status);
CREATE INDEX idx_quotations_valid_status ON quotations(valid_until, status);
CREATE INDEX idx_quotations_approval ON quotations(approval_status, approved_by);

-- å®¢æˆ·ç›¸å…³å¤åˆç´¢å¼•
CREATE INDEX idx_customers_city_status ON customers(city, status);
CREATE INDEX idx_customers_source_created ON customers(source, created_at);
CREATE INDEX idx_customers_phone_name ON customers(phone, customer_name);

-- ç”¨æˆ·ç›¸å…³å¤åˆç´¢å¼•
CREATE INDEX idx_users_role_status ON users(role, status);
CREATE INDEX idx_users_department_role ON users(department_id, role);

-- äº§å“ç›¸å…³å¤åˆç´¢å¼•
CREATE INDEX idx_products_category_status ON products(category_id, status);
CREATE INDEX idx_products_price_range ON products(price) WHERE status = 'active';

-- åº“å­˜ç›¸å…³å¤åˆç´¢å¼•
CREATE INDEX idx_inventory_warehouse_product ON inventory(warehouse_id, product_id);
CREATE INDEX idx_inventory_low_stock ON inventory(warehouse_id, available_quantity) 
    WHERE available_quantity <= safety_stock;

-- è®¢å•æ˜ç»†ç›¸å…³ç´¢å¼•
CREATE INDEX idx_sales_order_items_product ON sales_order_items(product_id, order_id);
CREATE INDEX idx_quotation_items_product ON quotation_items(product_id, quotation_id);

-- æ—¥å¿—è¡¨åˆ†åŒºç´¢å¼•ï¼ˆæŒ‰æ—¶é—´åˆ†åŒºï¼‰
CREATE INDEX idx_status_change_logs_date ON status_change_logs(changed_at);
CREATE INDEX idx_status_change_logs_table_date ON status_change_logs(table_name, changed_at);

-- éƒ¨åˆ†ç´¢å¼•ï¼ˆæ¡ä»¶ç´¢å¼•ï¼‰ç”¨äºç‰¹å®šæŸ¥è¯¢
CREATE INDEX idx_sales_orders_active ON sales_orders(id, status) 
    WHERE status NOT IN ('COMPLETED', 'CANCELLED');
CREATE INDEX idx_leads_active ON leads(id, status) 
    WHERE status NOT IN ('converted', 'invalid');
CREATE INDEX idx_quotations_pending ON quotations(id, created_at) 
    WHERE status IN ('draft', 'pending_approval', 'sent');

-- å…¨æ–‡æœç´¢ç´¢å¼•
CREATE INDEX idx_customers_search ON customers USING gin(to_tsvector('chinese', customer_name || ' ' || COALESCE(company_name, '')));
CREATE INDEX idx_products_search ON products USING gin(to_tsvector('chinese', product_name || ' ' || COALESCE(description, '')));
CREATE INDEX idx_leads_search ON leads USING gin(to_tsvector('chinese', customer_name || ' ' || COALESCE(requirement, '')));

-- æ•°æ®åº“å¤‡ä»½å’Œæ¢å¤ç­–ç•¥

-- 1. åˆ›å»ºå¤‡ä»½æ—¥å¿—è¡¨
CREATE TABLE backup_logs (
    id BIGSERIAL PRIMARY KEY,
    backup_type VARCHAR(20) NOT NULL CHECK (backup_type IN ('full', 'incremental', 'differential')),
    backup_file_path TEXT NOT NULL,
    backup_size BIGINT,
    start_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    end_time TIMESTAMP,
    status VARCHAR(20) NOT NULL DEFAULT 'running' CHECK (status IN ('running', 'completed', 'failed')),
    error_message TEXT,
    created_by BIGINT REFERENCES users(id)
);

-- 2. åˆ›å»ºæ•°æ®å½’æ¡£è¡¨ï¼ˆç”¨äºå†å²æ•°æ®å½’æ¡£ï¼‰
CREATE TABLE archived_sales_orders (
    LIKE sales_orders INCLUDING ALL
);

CREATE TABLE archived_leads (
    LIKE leads INCLUDING ALL
);

CREATE TABLE archived_quotations (
    LIKE quotations INCLUDING ALL
);

-- 3. æ•°æ®å½’æ¡£å‡½æ•°
CREATE OR REPLACE FUNCTION archive_old_data(
    p_table_name VARCHAR(50),
    p_archive_before_date DATE
) RETURNS INTEGER AS $$
DECLARE
    archived_count INTEGER := 0;
BEGIN
    -- å½’æ¡£é”€å”®è®¢å•
    IF p_table_name = 'sales_orders' THEN
        INSERT INTO archived_sales_orders 
        SELECT * FROM sales_orders 
        WHERE created_at < p_archive_before_date 
        AND status IN ('COMPLETED', 'CANCELLED');
        
        GET DIAGNOSTICS archived_count = ROW_COUNT;
        
        DELETE FROM sales_orders 
        WHERE created_at < p_archive_before_date 
        AND status IN ('COMPLETED', 'CANCELLED');
    END IF;
    
    -- å½’æ¡£çº¿ç´¢
    IF p_table_name = 'leads' THEN
        INSERT INTO archived_leads 
        SELECT * FROM leads 
        WHERE created_at < p_archive_before_date 
        AND status IN ('converted', 'invalid');
        
        GET DIAGNOSTICS archived_count = ROW_COUNT;
        
        DELETE FROM leads 
        WHERE created_at < p_archive_before_date 
        AND status IN ('converted', 'invalid');
    END IF;
    
    -- å½’æ¡£æŠ¥ä»·
    IF p_table_name = 'quotations' THEN
        INSERT INTO archived_quotations 
        SELECT * FROM quotations 
        WHERE created_at < p_archive_before_date 
        AND status IN ('accepted', 'rejected', 'expired');
        
        GET DIAGNOSTICS archived_count = ROW_COUNT;
        
        DELETE FROM quotations 
        WHERE created_at < p_archive_before_date 
        AND status IN ('accepted', 'rejected', 'expired');
    END IF;
    
    RETURN archived_count;
END;
$$ LANGUAGE plpgsql;

-- 4. æ•°æ®åº“å¥åº·æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION database_health_check()
RETURNS TABLE(
    check_name VARCHAR(50),
    status VARCHAR(20),
    details TEXT
) AS $$
BEGIN
    -- æ£€æŸ¥è¡¨ç©ºé—´ä½¿ç”¨æƒ…å†µ
    RETURN QUERY
    SELECT 
        'tablespace_usage'::VARCHAR(50),
        CASE WHEN pg_size_pretty(pg_database_size(current_database()))::TEXT LIKE '%GB%' THEN 'warning' ELSE 'ok' END::VARCHAR(20),
        'Database size: ' || pg_size_pretty(pg_database_size(current_database()))::TEXT;
    
    -- æ£€æŸ¥é•¿æ—¶é—´è¿è¡Œçš„æŸ¥è¯¢
    RETURN QUERY
    SELECT 
        'long_running_queries'::VARCHAR(50),
        CASE WHEN COUNT(*) > 0 THEN 'warning' ELSE 'ok' END::VARCHAR(20),
        'Long running queries: ' || COUNT(*)::TEXT
    FROM pg_stat_activity 
    WHERE state = 'active' 
    AND query_start < NOW() - INTERVAL '5 minutes'
    AND query NOT LIKE '%pg_stat_activity%';
    
    -- æ£€æŸ¥é”ç­‰å¾…æƒ…å†µ
    RETURN QUERY
    SELECT 
        'lock_waits'::VARCHAR(50),
        CASE WHEN COUNT(*) > 0 THEN 'critical' ELSE 'ok' END::VARCHAR(20),
        'Lock waits: ' || COUNT(*)::TEXT
    FROM pg_stat_activity 
    WHERE wait_event_type = 'Lock';
    
    -- æ£€æŸ¥è¿æ¥æ•°
    RETURN QUERY
    SELECT 
        'connection_count'::VARCHAR(50),
        CASE WHEN COUNT(*) > 80 THEN 'warning' WHEN COUNT(*) > 90 THEN 'critical' ELSE 'ok' END::VARCHAR(20),
        'Active connections: ' || COUNT(*)::TEXT
    FROM pg_stat_activity 
    WHERE state = 'active';
END;
$$ LANGUAGE plpgsql;

-- 5. è‡ªåŠ¨æ¸…ç†è¿‡æœŸæ•°æ®çš„å‡½æ•°
CREATE OR REPLACE FUNCTION cleanup_expired_data()
RETURNS INTEGER AS $$
DECLARE
    cleanup_count INTEGER := 0;
    total_count INTEGER := 0;
BEGIN
    -- æ¸…ç†è¿‡æœŸçš„çŠ¶æ€å˜æ›´æ—¥å¿—ï¼ˆä¿ç•™1å¹´ï¼‰
    DELETE FROM status_change_logs 
    WHERE changed_at < NOW() - INTERVAL '1 year';
    GET DIAGNOSTICS cleanup_count = ROW_COUNT;
    total_count := total_count + cleanup_count;
    
    -- æ¸…ç†è¿‡æœŸçš„å¤‡ä»½æ—¥å¿—ï¼ˆä¿ç•™6ä¸ªæœˆï¼‰
    DELETE FROM backup_logs 
    WHERE start_time < NOW() - INTERVAL '6 months';
    GET DIAGNOSTICS cleanup_count = ROW_COUNT;
    total_count := total_count + cleanup_count;
    
    -- æ¸…ç†è½¯åˆ é™¤çš„è®°å½•ï¼ˆåˆ é™¤è¶…è¿‡3ä¸ªæœˆçš„ï¼‰
    DELETE FROM sales_orders 
    WHERE deleted_at IS NOT NULL 
    AND deleted_at < NOW() - INTERVAL '3 months';
    GET DIAGNOSTICS cleanup_count = ROW_COUNT;
    total_count := total_count + cleanup_count;
    
    DELETE FROM leads 
    WHERE deleted_at IS NOT NULL 
    AND deleted_at < NOW() - INTERVAL '3 months';
    GET DIAGNOSTICS cleanup_count = ROW_COUNT;
    total_count := total_count + cleanup_count;
    
    DELETE FROM customers 
    WHERE deleted_at IS NOT NULL 
    AND deleted_at < NOW() - INTERVAL '3 months';
    GET DIAGNOSTICS cleanup_count = ROW_COUNT;
    total_count := total_count + cleanup_count;
    
    RETURN total_count;
END;
$$ LANGUAGE plpgsql;

## ğŸ“‹ å®¢æˆ·ä¿¡æ¯åŒæ­¥æœºåˆ¶

### å®¢æˆ·ä¿¡æ¯å†—ä½™é—®é¢˜åˆ†æ

#### å½“å‰å†—ä½™æƒ…å†µ
```sql
-- å®¢æˆ·ä¿¡æ¯åœ¨å¤šä¸ªè¡¨ä¸­é‡å¤å­˜å‚¨
-- 1. çº¿ç´¢è¡¨ (leads)
customer_name, customer_phone, customer_address, customer_city, customer_district

-- 2. é”€å”®è®¢å•è¡¨ (sales_orders)  
customer_name, customer_phone, customer_address

-- 3. æµ‹é‡ä»»åŠ¡è¡¨ (measurements)
customer_id, ä½†å¯èƒ½å­˜åœ¨å†—ä½™çš„å®¢æˆ·ä¿¡æ¯å­—æ®µ

-- 4. å®‰è£…ä»»åŠ¡è¡¨ (installations)
customer_id, ä½†å¯èƒ½å­˜åœ¨å†—ä½™çš„å®¢æˆ·ä¿¡æ¯å­—æ®µ

-- 5. å®¢æˆ·è¡¨ (customers) - ä¸»è¡¨
name, phone, email, company, occupation, ç­‰å®Œæ•´ä¿¡æ¯
```

#### æ•°æ®ä¸ä¸€è‡´é£é™©
- **æ›´æ–°é—æ¼**ï¼šå®¢æˆ·ä¿¡æ¯æ›´æ–°æ—¶ï¼Œå¯èƒ½é—æ¼æŸäº›å…³è”è¡¨
- **æ•°æ®å†²çª**ï¼šä¸åŒè¡¨ä¸­åŒä¸€å®¢æˆ·çš„ä¿¡æ¯ä¸ä¸€è‡´
- **ç»´æŠ¤å›°éš¾**ï¼šéœ€è¦åœ¨å¤šä¸ªåœ°æ–¹ç»´æŠ¤ç›¸åŒçš„å®¢æˆ·ä¿¡æ¯
- **æŸ¥è¯¢å¤æ‚**ï¼šéœ€è¦å…³è”å¤šä¸ªè¡¨æ‰èƒ½è·å–å®Œæ•´çš„å®¢æˆ·ä¿¡æ¯

## ğŸ”¢ ç»Ÿä¸€ç¼–å·ç”Ÿæˆç³»ç»Ÿ

### ç¼–å·ç”Ÿæˆå™¨è¡¨ (number_generators)
```sql
CREATE TABLE number_generators (
    id BIGSERIAL PRIMARY KEY,
    business_type VARCHAR(20) NOT NULL UNIQUE COMMENT 'ä¸šåŠ¡ç±»å‹',
    prefix VARCHAR(10) NOT NULL COMMENT 'ç¼–å·å‰ç¼€',
    current_date DATE NOT NULL COMMENT 'å½“å‰æ—¥æœŸ',
    current_sequence INT NOT NULL DEFAULT 0 COMMENT 'å½“å‰æµæ°´å·',
    sequence_length INT NOT NULL DEFAULT 3 COMMENT 'æµæ°´å·é•¿åº¦',
    format_template VARCHAR(50) NOT NULL COMMENT 'æ ¼å¼æ¨¡æ¿',
    description VARCHAR(100) COMMENT 'æè¿°',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_business_type (business_type),
    INDEX idx_current_date (current_date)
) COMMENT 'ç¼–å·ç”Ÿæˆå™¨è¡¨';

-- åˆå§‹åŒ–ç¼–å·ç”Ÿæˆå™¨æ•°æ®
INSERT INTO number_generators (business_type, prefix, current_date, format_template, description) VALUES
('lead', 'L', CURRENT_DATE, '{prefix}{date}{sequence}', 'çº¿ç´¢ç¼–å·'),
('order', 'O', CURRENT_DATE, '{prefix}{date}{sequence}', 'è®¢å•ç¼–å·'),
('customer', 'C', CURRENT_DATE, '{prefix}{date}{sequence}', 'å®¢æˆ·ç¼–å·'),
('product', 'P', CURRENT_DATE, '{prefix}{date}{sequence}', 'äº§å“ç¼–å·'),
('measurement', 'M', CURRENT_DATE, '{prefix}{date}{sequence}', 'æµ‹é‡ç¼–å·'),
('installation', 'I', CURRENT_DATE, '{prefix}{date}{sequence}', 'å®‰è£…ç¼–å·'),
('quote', 'Q', CURRENT_DATE, '{prefix}{date}{sequence}', 'æŠ¥ä»·ç¼–å·'),
('contract', 'CT', CURRENT_DATE, '{prefix}{date}{sequence}', 'åˆåŒç¼–å·'),
('point_transaction', 'PT', CURRENT_DATE, '{prefix}{date}{sequence}', 'ç§¯åˆ†äº¤æ˜“ç¼–å·'),
('mall_order', 'MO', CURRENT_DATE, '{prefix}{date}{sequence}', 'å•†åŸè®¢å•ç¼–å·'),
('reservation', 'R', CURRENT_DATE, '{prefix}{date}{sequence}', 'åº“å­˜é¢„ç•™ç¼–å·'),
('stocktake', 'S', CURRENT_DATE, '{prefix}{date}{sequence}', 'ç›˜ç‚¹ç¼–å·'),
('finance', 'F', CURRENT_DATE, '{prefix}{date}{sequence}', 'è´¢åŠ¡æµæ°´ç¼–å·'),
('logistics', 'T', CURRENT_DATE, '{prefix}{date}{sequence}', 'ç‰©æµä»»åŠ¡ç¼–å·');
```

### ç¼–å·ç”Ÿæˆå‡½æ•°
```sql
-- ç»Ÿä¸€ç¼–å·ç”Ÿæˆå‡½æ•°
CREATE OR REPLACE FUNCTION generate_business_number(p_business_type VARCHAR(20))
RETURNS VARCHAR(20) AS $
DECLARE
    v_generator RECORD;
    v_current_date DATE;
    v_date_str VARCHAR(8);
    v_sequence_str VARCHAR(10);
    v_new_number VARCHAR(20);
BEGIN
    v_current_date := CURRENT_DATE;
    v_date_str := TO_CHAR(v_current_date, 'YYYYMMDD');
    
    -- è·å–ç”Ÿæˆå™¨é…ç½®ï¼ˆåŠ é”é˜²æ­¢å¹¶å‘ï¼‰
    SELECT * INTO v_generator 
    FROM number_generators 
    WHERE business_type = p_business_type 
    FOR UPDATE;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'æœªæ‰¾åˆ°ä¸šåŠ¡ç±»å‹ % çš„ç¼–å·ç”Ÿæˆå™¨', p_business_type;
    END IF;
    
    -- æ£€æŸ¥æ—¥æœŸæ˜¯å¦å˜æ›´ï¼Œå¦‚æœå˜æ›´åˆ™é‡ç½®æµæ°´å·
    IF v_generator.current_date != v_current_date THEN
        UPDATE number_generators 
        SET current_date = v_current_date,
            current_sequence = 1,
            updated_at = CURRENT_TIMESTAMP
        WHERE business_type = p_business_type;
        
        v_sequence_str := LPAD('1', v_generator.sequence_length, '0');
    ELSE
        -- é€’å¢æµæ°´å·
        UPDATE number_generators 
        SET current_sequence = current_sequence + 1,
            updated_at = CURRENT_TIMESTAMP
        WHERE business_type = p_business_type;
        
        v_sequence_str := LPAD((v_generator.current_sequence + 1)::TEXT, v_generator.sequence_length, '0');
    END IF;
    
    -- ç”Ÿæˆç¼–å·
    v_new_number := v_generator.prefix || v_date_str || v_sequence_str;
    
    -- è®°å½•ç”Ÿæˆæ—¥å¿—
    INSERT INTO number_generation_logs (
        business_type, generated_number, generation_date, sequence_number
    ) VALUES (
        p_business_type, v_new_number, v_current_date, 
        CASE WHEN v_generator.current_date != v_current_date THEN 1 ELSE v_generator.current_sequence + 1 END
    );
    
    RETURN v_new_number;
END;
$ LANGUAGE plpgsql;
```

### ç¼–å·ç”Ÿæˆæ—¥å¿—è¡¨
```sql
CREATE TABLE number_generation_logs (
    id BIGSERIAL PRIMARY KEY,
    business_type VARCHAR(20) NOT NULL COMMENT 'ä¸šåŠ¡ç±»å‹',
    generated_number VARCHAR(20) NOT NULL COMMENT 'ç”Ÿæˆçš„ç¼–å·',
    generation_date DATE NOT NULL COMMENT 'ç”Ÿæˆæ—¥æœŸ',
    sequence_number INT NOT NULL COMMENT 'å½“æ—¥æµæ°´å·',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_business_type (business_type),
    INDEX idx_generated_number (generated_number),
    INDEX idx_generation_date (generation_date)
) COMMENT 'ç¼–å·ç”Ÿæˆæ—¥å¿—è¡¨';
```

### ç¼–å·é‡å¤æ£€æŸ¥å‡½æ•°
```sql
-- ç¼–å·å”¯ä¸€æ€§æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION check_number_uniqueness(
    p_table_name VARCHAR(50),
    p_column_name VARCHAR(50),
    p_number VARCHAR(20)
) RETURNS BOOLEAN AS $
DECLARE
    v_count INT;
    v_sql TEXT;
BEGIN
    v_sql := FORMAT('SELECT COUNT(*) FROM %I WHERE %I = $1', p_table_name, p_column_name);
    EXECUTE v_sql INTO v_count USING p_number;
    
    RETURN v_count = 0;
END;
$ LANGUAGE plpgsql;
```

### æ‰¹é‡ç¼–å·ç”Ÿæˆå‡½æ•°
```sql
-- æ‰¹é‡ç¼–å·ç”Ÿæˆå‡½æ•°ï¼ˆç”¨äºæ•°æ®è¿ç§»ï¼‰
CREATE OR REPLACE FUNCTION generate_batch_numbers(
    p_business_type VARCHAR(20),
    p_count INT
) RETURNS TEXT[] AS $
DECLARE
    v_numbers TEXT[] := '{}';
    v_number VARCHAR(20);
    i INT;
BEGIN
    FOR i IN 1..p_count LOOP
        v_number := generate_business_number(p_business_type);
        v_numbers := array_append(v_numbers, v_number);
    END LOOP;
    
    RETURN v_numbers;
END;
$ LANGUAGE plpgsql;
```

### å®¢æˆ·ä¿¡æ¯åŒæ­¥è§£å†³æ–¹æ¡ˆ

#### æ•°æ®åº“è§¦å‘å™¨åŒæ­¥
```sql
-- å®¢æˆ·ä¿¡æ¯å˜æ›´åŒæ­¥è§¦å‘å™¨
CREATE OR REPLACE FUNCTION sync_customer_info()
RETURNS TRIGGER AS $
BEGIN
    -- åŒæ­¥åˆ°çº¿ç´¢è¡¨
    UPDATE leads 
    SET customer_name = NEW.name,
        customer_phone = NEW.phone,
        updated_at = CURRENT_TIMESTAMP
    WHERE customer_id = NEW.id;
    
    -- åŒæ­¥åˆ°é”€å”®è®¢å•è¡¨
    UPDATE sales_orders 
    SET customer_name = NEW.name,
        customer_phone = NEW.phone,
        updated_at = CURRENT_TIMESTAMP
    WHERE customer_id = NEW.id;
    
    -- è®°å½•åŒæ­¥æ—¥å¿—
    INSERT INTO customer_sync_logs (
        customer_id, sync_type, affected_tables, 
        old_values, new_values, sync_time
    ) VALUES (
        NEW.id, 'customer_update', 
        ARRAY['leads', 'sales_orders'],
        jsonb_build_object('name', OLD.name, 'phone', OLD.phone),
        jsonb_build_object('name', NEW.name, 'phone', NEW.phone),
        CURRENT_TIMESTAMP
    );
    
    RETURN NEW;
END;
$ LANGUAGE plpgsql;

-- åˆ›å»ºè§¦å‘å™¨
CREATE TRIGGER trigger_sync_customer_info
    AFTER UPDATE OF name, phone ON customers
    FOR EACH ROW
    WHEN (OLD.name IS DISTINCT FROM NEW.name OR OLD.phone IS DISTINCT FROM NEW.phone)
    EXECUTE FUNCTION sync_customer_info();
```

### ğŸ“± åº”ç”¨å±‚ç¼–å·ç”ŸæˆæœåŠ¡

### ç¼–å·ç”ŸæˆæœåŠ¡ç±»
```typescript
// services/NumberGeneratorService.ts
export class NumberGeneratorService {
  private redis: Redis;
  private db: Database;
  
  constructor(redis: Redis, db: Database) {
    this.redis = redis;
    this.db = db;
  }

  /**
   * ç”Ÿæˆä¸šåŠ¡ç¼–å·
   * @param businessType ä¸šåŠ¡ç±»å‹
   * @returns ç”Ÿæˆçš„ç¼–å·
   */
  async generateNumber(businessType: string): Promise<string> {
    const cacheKey = `number_gen:${businessType}:${this.getCurrentDateStr()}`;
    
    try {
      // 1. å°è¯•ä»Redisè·å–å½“æ—¥æµæ°´å·
      let sequence = await this.redis.incr(cacheKey);
      
      // 2. å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡ç”Ÿæˆï¼Œè®¾ç½®è¿‡æœŸæ—¶é—´
      if (sequence === 1) {
        await this.redis.expire(cacheKey, 86400); // 24å°æ—¶è¿‡æœŸ
      }
      
      // 3. ç”Ÿæˆç¼–å·
      const config = await this.getGeneratorConfig(businessType);
      const number = this.formatNumber(config, sequence);
      
      // 4. å¼‚æ­¥æ›´æ–°æ•°æ®åº“ï¼ˆä¸é˜»å¡å“åº”ï¼‰
      this.updateDatabaseAsync(businessType, sequence, number);
      
      // 5. éªŒè¯ç¼–å·å”¯ä¸€æ€§
      await this.validateNumberUniqueness(businessType, number);
      
      return number;
    } catch (error) {
      // é™çº§åˆ°æ•°æ®åº“ç”Ÿæˆ
      return this.generateFromDatabase(businessType);
    }
  }

  /**
   * æ‰¹é‡ç”Ÿæˆç¼–å·
   * @param businessType ä¸šåŠ¡ç±»å‹
   * @param count ç”Ÿæˆæ•°é‡
   * @returns ç¼–å·æ•°ç»„
   */
  async generateBatchNumbers(businessType: string, count: number): Promise<string[]> {
    const cacheKey = `number_gen:${businessType}:${this.getCurrentDateStr()}`;
    
    // æ‰¹é‡é€’å¢
    const startSequence = await this.redis.incrby(cacheKey, count);
    const endSequence = startSequence - count + 1;
    
    const config = await this.getGeneratorConfig(businessType);
    const numbers: string[] = [];
    
    for (let i = endSequence; i <= startSequence; i++) {
      numbers.push(this.formatNumber(config, i));
    }
    
    // å¼‚æ­¥æ›´æ–°æ•°æ®åº“
    this.updateDatabaseBatchAsync(businessType, numbers);
    
    return numbers;
  }

  /**
   * æ ¼å¼åŒ–ç¼–å·
   */
  private formatNumber(config: GeneratorConfig, sequence: number): string {
    const dateStr = this.getCurrentDateStr();
    const sequenceStr = sequence.toString().padStart(config.sequenceLength, '0');
    return `${config.prefix}${dateStr}${sequenceStr}`;
  }

  /**
   * è·å–ç”Ÿæˆå™¨é…ç½®ï¼ˆå¸¦ç¼“å­˜ï¼‰
   */
  private async getGeneratorConfig(businessType: string): Promise<GeneratorConfig> {
    const cacheKey = `number_config:${businessType}`;
    
    let config = await this.redis.get(cacheKey);
    if (!config) {
      config = await this.db.query(
        'SELECT * FROM number_generators WHERE business_type = ?',
        [businessType]
      );
      await this.redis.setex(cacheKey, 3600, JSON.stringify(config)); // 1å°æ—¶ç¼“å­˜
    }
    
    return JSON.parse(config);
  }

  /**
   * éªŒè¯ç¼–å·å”¯ä¸€æ€§
   */
  private async validateNumberUniqueness(businessType: string, number: string): Promise<void> {
    const tableConfig = this.getTableConfig(businessType);
    const exists = await this.db.query(
      `SELECT 1 FROM ${tableConfig.tableName} WHERE ${tableConfig.columnName} = ? LIMIT 1`,
      [number]
    );
    
    if (exists.length > 0) {
      throw new Error(`ç¼–å· ${number} å·²å­˜åœ¨`);
    }
  }

  /**
   * å¼‚æ­¥æ›´æ–°æ•°æ®åº“
   */
  private async updateDatabaseAsync(businessType: string, sequence: number, number: string): Promise<void> {
    // ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—æˆ–å®šæ—¶ä»»åŠ¡å¼‚æ­¥æ›´æ–°
    await this.db.query(
      'UPDATE number_generators SET current_sequence = ?, updated_at = NOW() WHERE business_type = ?',
      [sequence, businessType]
    );
    
    // è®°å½•ç”Ÿæˆæ—¥å¿—
    await this.db.query(
      'INSERT INTO number_generation_logs (business_type, generated_number, generation_date, sequence_number) VALUES (?, ?, CURDATE(), ?)',
      [businessType, number, sequence]
    );
  }

  private getCurrentDateStr(): string {
    return new Date().toISOString().slice(0, 10).replace(/-/g, '');
  }
}
```

### ç¼–å·ç”Ÿæˆé…ç½®æ¥å£
```typescript
// interfaces/NumberGenerator.ts
export interface GeneratorConfig {
  businessType: string;
  prefix: string;
  sequenceLength: number;
  formatTemplate: string;
  description: string;
}

export interface TableConfig {
  tableName: string;
  columnName: string;
}

export const BUSINESS_TYPE_MAPPING: Record<string, TableConfig> = {
  'lead': { tableName: 'leads', columnName: 'lead_no' },
  'order': { tableName: 'sales_orders', columnName: 'order_no' },
  'customer': { tableName: 'customers', columnName: 'customer_no' },
  'product': { tableName: 'products', columnName: 'product_code' },
  'measurement': { tableName: 'measurement_orders', columnName: 'measurement_no' },
  'installation': { tableName: 'installation_orders', columnName: 'installation_no' },
  'quote': { tableName: 'quotations', columnName: 'quote_no' },
  'contract': { tableName: 'contracts', columnName: 'contract_number' },
  'point_transaction': { tableName: 'point_transactions', columnName: 'transaction_no' },
  'mall_order': { tableName: 'mall_orders', columnName: 'order_no' },
  'reservation': { tableName: 'inventory_reservations', columnName: 'reservation_no' },
  'stocktake': { tableName: 'inventory_stocktakes', columnName: 'stocktake_no' },
  'finance': { tableName: 'financial_transactions', columnName: 'transaction_no' },
  'logistics': { tableName: 'logistics_tasks', columnName: 'task_no' }
};
```

### ç¼–å·ç”Ÿæˆä¸­é—´ä»¶
```typescript
// middleware/NumberGeneratorMiddleware.ts
export class NumberGeneratorMiddleware {
  private numberService: NumberGeneratorService;

  constructor(numberService: NumberGeneratorService) {
    this.numberService = numberService;
  }

  /**
   * è‡ªåŠ¨ç”Ÿæˆç¼–å·çš„è£…é¥°å™¨
   */
  autoGenerateNumber(businessType: string, fieldName: string = 'no') {
    return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
      const method = descriptor.value;

      descriptor.value = async function (...args: any[]) {
        const data = args[0];
        
        // å¦‚æœæ²¡æœ‰æä¾›ç¼–å·ï¼Œè‡ªåŠ¨ç”Ÿæˆ
        if (!data[fieldName]) {
          data[fieldName] = await this.numberService.generateNumber(businessType);
        }
        
        return method.apply(this, args);
      };
    };
  }
}
```

### ä½¿ç”¨ç¤ºä¾‹
```typescript
// services/LeadService.ts
export class LeadService {
  @autoGenerateNumber('lead', 'lead_no')
  async createLead(leadData: CreateLeadDto): Promise<Lead> {
    // leadData.lead_no å·²è‡ªåŠ¨ç”Ÿæˆ
    return this.leadRepository.create(leadData);
  }
}

// services/OrderService.ts
export class OrderService {
  @autoGenerateNumber('order', 'order_no')
  async createOrder(orderData: CreateOrderDto): Promise<Order> {
    // orderData.order_no å·²è‡ªåŠ¨ç”Ÿæˆ
    return this.orderRepository.create(orderData);
  }
}
```

### å®¢æˆ·ä¿¡æ¯åŒæ­¥æ—¥å¿—è¡¨
```sql
-- å®¢æˆ·ä¿¡æ¯åŒæ­¥æ—¥å¿—è¡¨
CREATE TABLE customer_sync_logs (
    id BIGSERIAL PRIMARY KEY,
    customer_id BIGINT NOT NULL REFERENCES customers(id),
    sync_type VARCHAR(50) NOT NULL, -- åŒæ­¥ç±»å‹ï¼šcustomer_update, address_update, contact_update
    affected_tables TEXT[] NOT NULL, -- å—å½±å“çš„è¡¨
    old_values JSONB, -- æ—§å€¼
    new_values JSONB, -- æ–°å€¼
    sync_status VARCHAR(20) DEFAULT 'success', -- åŒæ­¥çŠ¶æ€ï¼šsuccess, failed, partial
    error_message TEXT, -- é”™è¯¯ä¿¡æ¯
    sync_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    sync_duration_ms INTEGER -- åŒæ­¥è€—æ—¶(æ¯«ç§’)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_customer_sync_customer_id ON customer_sync_logs(customer_id);
CREATE INDEX idx_customer_sync_type ON customer_sync_logs(sync_type);
CREATE INDEX idx_customer_sync_time ON customer_sync_logs(sync_time);
CREATE INDEX idx_customer_sync_status ON customer_sync_logs(sync_status);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE customer_sync_logs IS 'å®¢æˆ·ä¿¡æ¯åŒæ­¥æ—¥å¿—è¡¨';
COMMENT ON COLUMN customer_sync_logs.customer_id IS 'å®¢æˆ·ID';
COMMENT ON COLUMN customer_sync_logs.sync_type IS 'åŒæ­¥ç±»å‹';
COMMENT ON COLUMN customer_sync_logs.affected_tables IS 'å—å½±å“çš„è¡¨';
COMMENT ON COLUMN customer_sync_logs.old_values IS 'æ—§å€¼';
COMMENT ON COLUMN customer_sync_logs.new_values IS 'æ–°å€¼';
COMMENT ON COLUMN customer_sync_logs.sync_status IS 'åŒæ­¥çŠ¶æ€';
COMMENT ON COLUMN customer_sync_logs.error_message IS 'é”™è¯¯ä¿¡æ¯';
COMMENT ON COLUMN customer_sync_logs.sync_time IS 'åŒæ­¥æ—¶é—´';
COMMENT ON COLUMN customer_sync_logs.sync_duration_ms IS 'åŒæ­¥è€—æ—¶(æ¯«ç§’)';

-- å®¢æˆ·ä¿¡æ¯ä¸€è‡´æ€§æ£€æŸ¥è¡¨
CREATE TABLE customer_consistency_checks (
    id BIGSERIAL PRIMARY KEY,
    customer_id BIGINT NOT NULL REFERENCES customers(id),
    table_name VARCHAR(50) NOT NULL,
    field_name VARCHAR(50) NOT NULL,
    master_value TEXT, -- ä¸»è¡¨å€¼
    slave_value TEXT, -- ä»è¡¨å€¼
    inconsistency_type VARCHAR(50), -- ä¸ä¸€è‡´ç±»å‹ï¼švalue_mismatch, missing_record
    detected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    resolved_at TIMESTAMP,
    resolution_method VARCHAR(50), -- è§£å†³æ–¹æ³•ï¼šauto_sync, manual_fix
    resolved_by BIGINT REFERENCES users(id)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_consistency_customer_id ON customer_consistency_checks(customer_id);
CREATE INDEX idx_consistency_table ON customer_consistency_checks(table_name);
CREATE INDEX idx_consistency_detected ON customer_consistency_checks(detected_at);
CREATE INDEX idx_consistency_resolved ON customer_consistency_checks(resolved_at);

-- æ·»åŠ è¡¨æ³¨é‡Š
COMMENT ON TABLE customer_consistency_checks IS 'å®¢æˆ·ä¿¡æ¯ä¸€è‡´æ€§æ£€æŸ¥è¡¨';
COMMENT ON COLUMN customer_consistency_checks.customer_id IS 'å®¢æˆ·ID';
COMMENT ON COLUMN customer_consistency_checks.table_name IS 'è¡¨å';
COMMENT ON COLUMN customer_consistency_checks.field_name IS 'å­—æ®µå';
COMMENT ON COLUMN customer_consistency_checks.master_value IS 'ä¸»è¡¨å€¼';
COMMENT ON COLUMN customer_consistency_checks.slave_value IS 'ä»è¡¨å€¼';
COMMENT ON COLUMN customer_consistency_checks.inconsistency_type IS 'ä¸ä¸€è‡´ç±»å‹';
COMMENT ON COLUMN customer_consistency_checks.detected_at IS 'æ£€æµ‹æ—¶é—´';
COMMENT ON COLUMN customer_consistency_checks.resolved_at IS 'è§£å†³æ—¶é—´';
COMMENT ON COLUMN customer_consistency_checks.resolution_method IS 'è§£å†³æ–¹æ³•';
COMMENT ON COLUMN customer_consistency_checks.resolved_by IS 'è§£å†³äººID';
```

#### æ•°æ®ä¸€è‡´æ€§æ£€æŸ¥
```sql
-- å®¢æˆ·ä¿¡æ¯ä¸€è‡´æ€§æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION check_customer_data_consistency()
RETURNS TABLE(
    customer_id BIGINT,
    table_name VARCHAR(50),
    field_name VARCHAR(50),
    master_value TEXT,
    slave_value TEXT,
    inconsistency_type VARCHAR(50)
) AS $
BEGIN
    -- æ¸…ç©ºä¹‹å‰çš„æ£€æŸ¥ç»“æœ
    DELETE FROM customer_consistency_checks WHERE detected_at < CURRENT_DATE;
    
    -- æ£€æŸ¥çº¿ç´¢è¡¨æ•°æ®ä¸€è‡´æ€§
    INSERT INTO customer_consistency_checks (
        customer_id, table_name, field_name, master_value, slave_value, inconsistency_type
    )
    SELECT 
        c.id, 'leads', 'customer_name', c.name, l.customer_name, 'value_mismatch'
    FROM customers c
    JOIN leads l ON c.id = l.customer_id
    WHERE c.name != l.customer_name;
    
    INSERT INTO customer_consistency_checks (
        customer_id, table_name, field_name, master_value, slave_value, inconsistency_type
    )
    SELECT 
        c.id, 'leads', 'customer_phone', c.phone, l.customer_phone, 'value_mismatch'
    FROM customers c
    JOIN leads l ON c.id = l.customer_id
    WHERE c.phone != l.customer_phone;
    
    -- æ£€æŸ¥é”€å”®è®¢å•è¡¨æ•°æ®ä¸€è‡´æ€§
    INSERT INTO customer_consistency_checks (
        customer_id, table_name, field_name, master_value, slave_value, inconsistency_type
    )
    SELECT 
        c.id, 'sales_orders', 'customer_name', c.name, so.customer_name, 'value_mismatch'
    FROM customers c
    JOIN sales_orders so ON c.id = so.customer_id
    WHERE c.name != so.customer_name;
    
    INSERT INTO customer_consistency_checks (
        customer_id, table_name, field_name, master_value, slave_value, inconsistency_type
    )
    SELECT 
        c.id, 'sales_orders', 'customer_phone', c.phone, so.customer_phone, 'value_mismatch'
    FROM customers c
    JOIN sales_orders so ON c.id = so.customer_id
    WHERE c.phone != so.customer_phone;
    
    -- è¿”å›æ£€æŸ¥ç»“æœ
    RETURN QUERY
    SELECT 
        cc.customer_id, cc.table_name, cc.field_name, 
        cc.master_value, cc.slave_value, cc.inconsistency_type
    FROM customer_consistency_checks cc
    WHERE cc.resolved_at IS NULL
    ORDER BY cc.customer_id, cc.table_name, cc.field_name;
END;
$ LANGUAGE plpgsql;

-- æ·»åŠ å‡½æ•°æ³¨é‡Š
COMMENT ON FUNCTION check_customer_data_consistency IS 'æ£€æŸ¥å®¢æˆ·ä¿¡æ¯åœ¨å„è¡¨ä¸­çš„ä¸€è‡´æ€§';
```

#### è‡ªåŠ¨ä¿®å¤æœºåˆ¶
```sql
-- è‡ªåŠ¨ä¿®å¤å®¢æˆ·ä¿¡æ¯ä¸ä¸€è‡´
CREATE OR REPLACE FUNCTION auto_fix_customer_inconsistency(
    fix_customer_id BIGINT DEFAULT NULL
)
RETURNS TABLE(
    customer_id BIGINT,
    fixed_count INTEGER,
    error_count INTEGER,
    details JSONB
) AS $
DECLARE
    inconsistency_record RECORD;
    fix_count INTEGER := 0;
    error_count INTEGER := 0;
    fix_details JSONB := '[]'::JSONB;
BEGIN
    FOR inconsistency_record IN 
        SELECT * FROM customer_consistency_checks 
        WHERE resolved_at IS NULL 
        AND (fix_customer_id IS NULL OR customer_consistency_checks.customer_id = fix_customer_id)
    LOOP
        BEGIN
            -- æ ¹æ®è¡¨åå’Œå­—æ®µåæ‰§è¡Œä¿®å¤
            IF inconsistency_record.table_name = 'leads' AND inconsistency_record.field_name = 'customer_name' THEN
                UPDATE leads 
                SET customer_name = inconsistency_record.master_value,
                    updated_at = CURRENT_TIMESTAMP
                WHERE customer_id = inconsistency_record.customer_id;
                
            ELSIF inconsistency_record.table_name = 'leads' AND inconsistency_record.field_name = 'customer_phone' THEN
                UPDATE leads 
                SET customer_phone = inconsistency_record.master_value,
                    updated_at = CURRENT_TIMESTAMP
                WHERE customer_id = inconsistency_record.customer_id;
                
            ELSIF inconsistency_record.table_name = 'sales_orders' AND inconsistency_record.field_name = 'customer_name' THEN
                UPDATE sales_orders 
                SET customer_name = inconsistency_record.master_value,
                    updated_at = CURRENT_TIMESTAMP
                WHERE customer_id = inconsistency_record.customer_id;
                
            ELSIF inconsistency_record.table_name = 'sales_orders' AND inconsistency_record.field_name = 'customer_phone' THEN
                UPDATE sales_orders 
                SET customer_phone = inconsistency_record.master_value,
                    updated_at = CURRENT_TIMESTAMP
                WHERE customer_id = inconsistency_record.customer_id;
            END IF;
            
            -- æ ‡è®°ä¸ºå·²è§£å†³
            UPDATE customer_consistency_checks 
            SET resolved_at = CURRENT_TIMESTAMP,
                resolution_method = 'auto_sync'
            WHERE id = inconsistency_record.id;
            
            fix_count := fix_count + 1;
            fix_details := fix_details || jsonb_build_object(
                'table', inconsistency_record.table_name,
                'field', inconsistency_record.field_name,
                'old_value', inconsistency_record.slave_value,
                'new_value', inconsistency_record.master_value
            );
            
        EXCEPTION WHEN OTHERS THEN
            error_count := error_count + 1;
            
            -- è®°å½•é”™è¯¯
            UPDATE customer_consistency_checks 
            SET resolved_at = CURRENT_TIMESTAMP,
                resolution_method = 'failed'
            WHERE id = inconsistency_record.id;
        END;
    END LOOP;
    
    RETURN QUERY SELECT 
        COALESCE(fix_customer_id, 0::BIGINT), 
        fix_count, 
        error_count, 
        fix_details;
END;
$ LANGUAGE plpgsql;

-- æ·»åŠ å‡½æ•°æ³¨é‡Š
COMMENT ON FUNCTION auto_fix_customer_inconsistency IS 'è‡ªåŠ¨ä¿®å¤å®¢æˆ·ä¿¡æ¯ä¸ä¸€è‡´é—®é¢˜';
```

### å®šæ—¶ä»»åŠ¡å’Œç›‘æ§

#### å®šæ—¶ä¸€è‡´æ€§æ£€æŸ¥
```sql
-- ä¸€è‡´æ€§æ£€æŸ¥ç»Ÿè®¡è§†å›¾
CREATE VIEW customer_consistency_stats AS
SELECT 
    DATE(detected_at) as check_date,
    table_name,
    inconsistency_type,
    COUNT(*) as inconsistency_count,
    COUNT(CASE WHEN resolved_at IS NOT NULL THEN 1 END) as resolved_count,
    COUNT(CASE WHEN resolved_at IS NULL THEN 1 END) as pending_count
FROM customer_consistency_checks
GROUP BY DATE(detected_at), table_name, inconsistency_type
ORDER BY check_date DESC, table_name;

-- æ·»åŠ è§†å›¾æ³¨é‡Š
COMMENT ON VIEW customer_consistency_stats IS 'å®¢æˆ·ä¿¡æ¯ä¸€è‡´æ€§æ£€æŸ¥ç»Ÿè®¡è§†å›¾';
```

#### ç›‘æ§æŒ‡æ ‡
```sql
-- å®¢æˆ·ä¿¡æ¯åŒæ­¥æ€§èƒ½ç›‘æ§
CREATE VIEW customer_sync_performance AS
SELECT 
    DATE(sync_time) as sync_date,
    sync_type,
    COUNT(*) as total_syncs,
    COUNT(CASE WHEN sync_status = 'success' THEN 1 END) as success_count,
    COUNT(CASE WHEN sync_status = 'failed' THEN 1 END) as failed_count,
    AVG(sync_duration_ms) as avg_duration_ms,
    MAX(sync_duration_ms) as max_duration_ms
FROM customer_sync_logs
GROUP BY DATE(sync_time), sync_type
ORDER BY sync_date DESC, sync_type;

-- æ·»åŠ è§†å›¾æ³¨é‡Š
COMMENT ON VIEW customer_sync_performance IS 'å®¢æˆ·ä¿¡æ¯åŒæ­¥æ€§èƒ½ç›‘æ§è§†å›¾';
```

---
**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.4  
**æœ€åæ›´æ–°**ï¼š2025å¹´1æœˆ21æ—¥  
**ä¸‹æ¬¡è¯„å®¡**ï¼š2025å¹´2æœˆ21æ—¥
