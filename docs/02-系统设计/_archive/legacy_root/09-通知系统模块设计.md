# 通知系统模块设计

## 1. 模块概述

### 1.1 功能目标
- **多渠道通知**：支持短信、邮件、微信、APP推送等多种通知渠道
- **模板管理**：提供灵活的通知模板管理和个性化定制
- **消息队列**：实现异步消息处理和高并发支持
- **智能推送**：基于用户偏好和行为的智能通知策略
- **统计分析**：提供通知发送统计和效果分析
- **失败重试**：支持消息发送失败的自动重试机制

### 1.2 通知类型
- **系统通知**：系统维护、更新等重要信息
- **业务通知**：订单状态、服务进度、支付结果等
- **营销通知**：促销活动、优惠券、推荐服务等
- **提醒通知**：预约提醒、到期提醒、生日祝福等
- **异常通知**：系统异常、安全警告等紧急信息

## 2. 数据库设计

### 2.1 通知模板表 (notification_templates)
```sql
CREATE TABLE notification_templates (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    template_code VARCHAR(50) NOT NULL UNIQUE COMMENT '模板编码',
    template_name VARCHAR(100) NOT NULL COMMENT '模板名称',
    template_type ENUM('system', 'business', 'marketing', 'reminder', 'alert') NOT NULL COMMENT '模板类型',
    channel_type ENUM('sms', 'email', 'wechat', 'push', 'all') NOT NULL COMMENT '通知渠道',
    title_template TEXT COMMENT '标题模板',
    content_template TEXT NOT NULL COMMENT '内容模板',
    variables JSON COMMENT '模板变量定义',
    is_active BOOLEAN DEFAULT TRUE COMMENT '是否启用',
    priority TINYINT DEFAULT 1 COMMENT '优先级(1-5)',
    created_by BIGINT COMMENT '创建人',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_template_code (template_code),
    INDEX idx_template_type (template_type),
    INDEX idx_channel_type (channel_type)
);
```

### 2.2 通知消息表 (notification_messages)
```sql
CREATE TABLE notification_messages (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    message_id VARCHAR(64) NOT NULL UNIQUE COMMENT '消息唯一标识',
    template_id BIGINT COMMENT '模板ID',
    user_id BIGINT NOT NULL COMMENT '接收用户ID',
    channel_type ENUM('sms', 'email', 'wechat', 'push') NOT NULL COMMENT '通知渠道',
    recipient VARCHAR(255) NOT NULL COMMENT '接收方(手机号/邮箱等)',
    title VARCHAR(255) COMMENT '消息标题',
    content TEXT NOT NULL COMMENT '消息内容',
    variables JSON COMMENT '模板变量值',
    status ENUM('pending', 'sending', 'sent', 'failed', 'cancelled') DEFAULT 'pending' COMMENT '发送状态',
    send_time TIMESTAMP NULL COMMENT '发送时间',
    retry_count TINYINT DEFAULT 0 COMMENT '重试次数',
    max_retry TINYINT DEFAULT 3 COMMENT '最大重试次数',
    error_message TEXT COMMENT '错误信息',
    external_id VARCHAR(100) COMMENT '第三方平台消息ID',
    priority TINYINT DEFAULT 1 COMMENT '优先级',
    scheduled_at TIMESTAMP NULL COMMENT '计划发送时间',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_message_id (message_id),
    INDEX idx_user_id (user_id),
    INDEX idx_status (status),
    INDEX idx_channel_type (channel_type),
    INDEX idx_scheduled_at (scheduled_at),
    INDEX idx_created_at (created_at),
    FOREIGN KEY (template_id) REFERENCES notification_templates(id),
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

### 2.3 用户通知偏好表 (user_notification_preferences)
```sql
CREATE TABLE user_notification_preferences (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    notification_type ENUM('system', 'business', 'marketing', 'reminder', 'alert') NOT NULL,
    channel_type ENUM('sms', 'email', 'wechat', 'push') NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE COMMENT '是否启用',
    quiet_hours_start TIME COMMENT '免打扰开始时间',
    quiet_hours_end TIME COMMENT '免打扰结束时间',
    frequency_limit TINYINT DEFAULT 0 COMMENT '频率限制(每日最大条数,0为不限制)',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_user_type_channel (user_id, notification_type, channel_type),
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

### 2.4 通知统计表 (notification_statistics)
```sql
CREATE TABLE notification_statistics (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    stat_date DATE NOT NULL COMMENT '统计日期',
    template_id BIGINT COMMENT '模板ID',
    channel_type ENUM('sms', 'email', 'wechat', 'push') NOT NULL,
    total_sent INT DEFAULT 0 COMMENT '发送总数',
    success_count INT DEFAULT 0 COMMENT '成功数量',
    failed_count INT DEFAULT 0 COMMENT '失败数量',
    click_count INT DEFAULT 0 COMMENT '点击数量',
    conversion_count INT DEFAULT 0 COMMENT '转化数量',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_date_template_channel (stat_date, template_id, channel_type),
    INDEX idx_stat_date (stat_date),
    INDEX idx_template_id (template_id),
    FOREIGN KEY (template_id) REFERENCES notification_templates(id)
);
```

### 2.5 通知渠道配置表 (notification_channels)
```sql
CREATE TABLE notification_channels (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    channel_type ENUM('sms', 'email', 'wechat', 'push') NOT NULL UNIQUE,
    channel_name VARCHAR(50) NOT NULL COMMENT '渠道名称',
    provider VARCHAR(50) NOT NULL COMMENT '服务提供商',
    config JSON NOT NULL COMMENT '渠道配置信息',
    is_enabled BOOLEAN DEFAULT TRUE COMMENT '是否启用',
    daily_limit INT DEFAULT 0 COMMENT '日发送限制(0为不限制)',
    rate_limit INT DEFAULT 0 COMMENT '每秒发送限制(0为不限制)',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

## 3. API接口设计

### 3.1 通知模板管理
```typescript
// 创建通知模板
POST /api/notification/templates
{
  "templateCode": "order_confirmed",
  "templateName": "订单确认通知",
  "templateType": "business",
  "channelType": "sms",
  "titleTemplate": "订单确认",
  "contentTemplate": "您的订单{{orderNo}}已确认，预计{{serviceTime}}开始服务。",
  "variables": [
    {"name": "orderNo", "type": "string", "description": "订单号"},
    {"name": "serviceTime", "type": "datetime", "description": "服务时间"}
  ],
  "priority": 2
}

// 获取模板列表
GET /api/notification/templates?page=1&size=20&type=business&channel=sms

// 更新模板
PUT /api/notification/templates/{id}

// 删除模板
DELETE /api/notification/templates/{id}
```

### 3.2 消息发送管理
```typescript
// 发送单条消息
POST /api/notification/messages/send
{
  "templateCode": "order_confirmed",
  "userId": 12345,
  "channelType": "sms",
  "variables": {
    "orderNo": "ORD20240101001",
    "serviceTime": "2024-01-02 10:00:00"
  },
  "scheduledAt": "2024-01-01 20:00:00"
}

// 批量发送消息
POST /api/notification/messages/batch-send
{
  "templateCode": "marketing_promotion",
  "channelType": "push",
  "recipients": [
    {
      "userId": 12345,
      "variables": {"userName": "张三", "discount": "8折"}
    },
    {
      "userId": 12346,
      "variables": {"userName": "李四", "discount": "7折"}
    }
  ]
}

// 获取消息列表
GET /api/notification/messages?page=1&size=20&status=sent&channel=sms&user_id=12345

// 获取消息详情
GET /api/notification/messages/{messageId}

// 重发消息
POST /api/notification/messages/{messageId}/resend
```

### 3.3 用户偏好管理
```typescript
// 获取用户通知偏好
GET /api/notification/preferences/{userId}

// 更新用户通知偏好
PUT /api/notification/preferences/{userId}
{
  "preferences": [
    {
      "notificationType": "business",
      "channelType": "sms",
      "isEnabled": true,
      "quietHoursStart": "22:00",
      "quietHoursEnd": "08:00",
      "frequencyLimit": 5
    }
  ]
}
```

### 3.4 统计分析
```typescript
// 获取发送统计
GET /api/notification/statistics?start_date=2024-01-01&end_date=2024-01-31&channel=sms&template_id=123

// 获取渠道性能统计
GET /api/notification/statistics/channels?period=7d

// 获取模板效果统计
GET /api/notification/statistics/templates?period=30d&top=10
```

## 4. 核心业务逻辑

### 4.1 通知发送服务 (NotificationService)
```typescript
class NotificationService {
  // 发送通知
  async sendNotification(request: SendNotificationRequest): Promise<string> {
    // 1. 验证模板和用户
    const template = await this.validateTemplate(request.templateCode);
    const user = await this.validateUser(request.userId);
    
    // 2. 检查用户偏好
    const preference = await this.checkUserPreference(
      request.userId, 
      template.templateType, 
      request.channelType
    );
    
    if (!preference.isEnabled) {
      throw new Error('用户已关闭此类型通知');
    }
    
    // 3. 检查免打扰时间
    if (this.isInQuietHours(preference)) {
      // 延迟到免打扰时间结束后发送
      request.scheduledAt = this.calculateNextSendTime(preference);
    }
    
    // 4. 渲染消息内容
    const message = await this.renderMessage(template, request.variables);
    
    // 5. 创建消息记录
    const messageId = await this.createMessage({
      templateId: template.id,
      userId: request.userId,
      channelType: request.channelType,
      recipient: await this.getRecipient(user, request.channelType),
      title: message.title,
      content: message.content,
      variables: request.variables,
      priority: template.priority,
      scheduledAt: request.scheduledAt
    });
    
    // 6. 加入发送队列
    await this.queueMessage(messageId);
    
    return messageId;
  }
  
  // 批量发送通知
  async batchSendNotification(request: BatchSendRequest): Promise<string[]> {
    const messageIds: string[] = [];
    
    for (const recipient of request.recipients) {
      try {
        const messageId = await this.sendNotification({
          templateCode: request.templateCode,
          userId: recipient.userId,
          channelType: request.channelType,
          variables: recipient.variables,
          scheduledAt: request.scheduledAt
        });
        messageIds.push(messageId);
      } catch (error) {
        console.error(`发送失败 userId: ${recipient.userId}`, error);
      }
    }
    
    return messageIds;
  }
  
  // 处理消息队列
  async processMessageQueue(): Promise<void> {
    const messages = await this.getPendingMessages();
    
    for (const message of messages) {
      try {
        await this.sendMessage(message);
        await this.updateMessageStatus(message.id, 'sent');
        await this.updateStatistics(message);
      } catch (error) {
        await this.handleSendError(message, error);
      }
    }
  }
  
  // 处理发送错误
  private async handleSendError(message: NotificationMessage, error: Error): Promise<void> {
    message.retryCount++;
    message.errorMessage = error.message;
    
    if (message.retryCount < message.maxRetry) {
      // 计算重试延迟时间（指数退避）
      const delay = Math.pow(2, message.retryCount) * 60000; // 2^n 分钟
      message.scheduledAt = new Date(Date.now() + delay);
      message.status = 'pending';
    } else {
      message.status = 'failed';
    }
    
    await this.updateMessage(message);
  }
}
```

### 4.2 消息渲染服务 (MessageRenderer)
```typescript
class MessageRenderer {
  // 渲染消息内容
  async renderMessage(template: NotificationTemplate, variables: Record<string, any>): Promise<RenderedMessage> {
    // 1. 验证变量
    this.validateVariables(template.variables, variables);
    
    // 2. 渲染标题
    const title = template.titleTemplate ? 
      this.renderTemplate(template.titleTemplate, variables) : null;
    
    // 3. 渲染内容
    const content = this.renderTemplate(template.contentTemplate, variables);
    
    return { title, content };
  }
  
  // 模板渲染
  private renderTemplate(template: string, variables: Record<string, any>): string {
    return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
      const value = variables[key];
      if (value === undefined) {
        throw new Error(`模板变量 ${key} 未提供`);
      }
      return this.formatValue(value);
    });
  }
  
  // 格式化变量值
  private formatValue(value: any): string {
    if (value instanceof Date) {
      return value.toLocaleString('zh-CN');
    }
    return String(value);
  }
}
```

### 4.3 渠道适配器 (ChannelAdapter)
```typescript
interface ChannelAdapter {
  send(message: NotificationMessage): Promise<SendResult>;
  getDeliveryStatus(externalId: string): Promise<DeliveryStatus>;
}

// 短信渠道适配器
class SmsChannelAdapter implements ChannelAdapter {
  async send(message: NotificationMessage): Promise<SendResult> {
    const config = await this.getChannelConfig('sms');
    
    // 调用短信服务商API
    const response = await this.smsProvider.send({
      phone: message.recipient,
      content: message.content,
      templateId: config.templateId
    });
    
    return {
      success: response.success,
      externalId: response.messageId,
      error: response.error
    };
  }
}

// 邮件渠道适配器
class EmailChannelAdapter implements ChannelAdapter {
  async send(message: NotificationMessage): Promise<SendResult> {
    const config = await this.getChannelConfig('email');
    
    // 调用邮件服务
    const response = await this.emailProvider.send({
      to: message.recipient,
      subject: message.title,
      html: this.formatEmailContent(message.content)
    });
    
    return {
      success: response.success,
      externalId: response.messageId,
      error: response.error
    };
  }
}
```

## 5. 前端界面设计

### 5.1 管理后台界面

#### 5.1.1 通知模板管理
- **模板列表页面**
  - 模板搜索和筛选（类型、渠道、状态）
  - 模板列表展示（编码、名称、类型、渠道、状态、操作）
  - 批量操作（启用/禁用、删除）

- **模板编辑页面**
  - 基本信息设置（编码、名称、类型、渠道、优先级）
  - 模板内容编辑器（支持变量插入、预览）
  - 变量定义管理
  - 模板测试功能

#### 5.1.2 消息发送管理
- **消息列表页面**
  - 消息搜索和筛选（状态、渠道、时间范围、用户）
  - 消息列表展示（ID、接收人、渠道、状态、发送时间）
  - 消息详情查看和重发操作

- **批量发送页面**
  - 模板选择和渠道配置
  - 接收人导入（Excel、CSV）
  - 变量映射配置
  - 发送预览和确认

#### 5.1.3 统计分析页面
- **发送统计仪表板**
  - 实时发送数据展示
  - 渠道性能对比图表
  - 模板效果排行榜

- **详细分析报表**
  - 自定义时间范围统计
  - 多维度数据分析
  - 数据导出功能

### 5.2 用户端界面

#### 5.2.1 通知偏好设置
- **偏好设置页面**
  - 通知类型开关（系统、业务、营销等）
  - 渠道选择（短信、邮件、微信、推送）
  - 免打扰时间设置
  - 频率限制配置

#### 5.2.2 消息中心
- **消息列表**
  - 未读/已读消息分类
  - 消息搜索和筛选
  - 消息详情查看

## 6. 性能优化

### 6.1 消息队列优化
- **分布式队列**：使用Redis或RabbitMQ实现高性能消息队列
- **优先级队列**：根据消息优先级进行队列调度
- **批量处理**：合并同类型消息进行批量发送
- **限流控制**：实现渠道级别的发送频率限制

### 6.2 数据库优化
- **分表策略**：按时间或用户ID对消息表进行分表
- **索引优化**：为常用查询字段建立合适的索引
- **数据归档**：定期归档历史消息数据
- **读写分离**：使用主从复制分离读写操作

### 6.3 缓存策略
- **模板缓存**：缓存常用通知模板减少数据库查询
- **用户偏好缓存**：缓存用户通知偏好设置
- **渠道配置缓存**：缓存渠道配置信息
- **统计数据缓存**：缓存统计分析结果

## 7. 安全与权限控制

### 7.1 数据安全
- **敏感信息加密**：对手机号、邮箱等敏感信息进行加密存储
- **访问日志记录**：记录所有通知发送和管理操作日志
- **数据脱敏**：在日志和统计中对敏感信息进行脱敏处理

### 7.2 权限管理
- **角色权限**：
  - 系统管理员：全部通知管理权限
  - 运营人员：模板管理和消息发送权限
  - 客服人员：消息查看和重发权限
  - 普通用户：个人偏好设置权限

### 7.3 防护机制
- **频率限制**：防止恶意大量发送通知
- **内容审核**：对营销类通知内容进行审核
- **黑名单机制**：支持用户和内容黑名单
- **异常监控**：监控异常发送行为并及时告警

## 8. 监控与告警

### 8.1 业务监控
- **发送成功率监控**：实时监控各渠道发送成功率
- **延迟监控**：监控消息发送延迟时间
- **队列积压监控**：监控消息队列积压情况
- **用户投诉监控**：监控用户投诉和退订情况

### 8.2 系统监控
- **服务可用性监控**：监控通知服务可用性
- **资源使用监控**：监控CPU、内存、网络等资源使用
- **第三方服务监控**：监控短信、邮件等第三方服务状态
- **数据库性能监控**：监控数据库查询性能和连接数

### 8.3 告警机制
- **实时告警**：发送失败率超阈值时立即告警
- **趋势告警**：基于历史数据预测异常趋势
- **多渠道告警**：支持邮件、短信、钉钉等多种告警方式
- **告警升级**：支持告警级别升级和自动处理

## 9. 总结

通知系统模块设计涵盖了多渠道通知发送、模板管理、用户偏好、统计分析等核心功能。通过合理的数据库设计、完善的API接口、高效的业务逻辑实现，以及全面的性能优化和安全控制，能够为L2C平台提供稳定、高效、智能的通知服务。

该设计支持水平扩展，具备良好的可维护性和扩展性，能够满足平台业务发展的需要，为用户提供优质的通知体验。
