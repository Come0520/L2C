# 文件管理模块设计

## 1. 模块概述

### 1.1 功能目标
- **文件上传**：支持多种文件类型的安全上传和格式验证
- **存储管理**：提供本地存储和云存储的统一管理接口
- **访问控制**：实现细粒度的文件访问权限控制
- **CDN加速**：集成CDN服务提供文件快速访问
- **版本管理**：支持文件版本控制和历史记录
- **安全防护**：提供文件安全扫描和恶意文件检测

### 1.2 文件类型分类
- **用户头像**：用户个人头像图片
- **身份证件**：身份证、营业执照等认证文件
- **服务图片**：服务展示图片、现场照片等
- **订单附件**：订单相关的图片、文档等
- **系统文件**：系统配置、模板等文件
- **临时文件**：上传过程中的临时文件

### 1.3 存储策略
- **本地存储**：用于开发环境和小文件存储
- **云存储**：阿里云OSS、腾讯云COS等云存储服务
- **CDN分发**：通过CDN网络加速文件访问
- **分层存储**：根据访问频率进行冷热数据分层

## 2. 数据库设计

### 2.1 文件信息表 (files)
```sql
CREATE TABLE files (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    file_id VARCHAR(64) NOT NULL UNIQUE COMMENT '文件唯一标识',
    original_name VARCHAR(255) NOT NULL COMMENT '原始文件名',
    file_name VARCHAR(255) NOT NULL COMMENT '存储文件名',
    file_path VARCHAR(500) NOT NULL COMMENT '文件存储路径',
    file_size BIGINT NOT NULL COMMENT '文件大小(字节)',
    file_type VARCHAR(50) NOT NULL COMMENT '文件类型',
    mime_type VARCHAR(100) NOT NULL COMMENT 'MIME类型',
    file_extension VARCHAR(10) NOT NULL COMMENT '文件扩展名',
    md5_hash VARCHAR(32) NOT NULL COMMENT '文件MD5值',
    sha256_hash VARCHAR(64) COMMENT '文件SHA256值',
    storage_type ENUM('local', 'oss', 'cos', 'qiniu') NOT NULL COMMENT '存储类型',
    storage_bucket VARCHAR(100) COMMENT '存储桶名称',
    cdn_url VARCHAR(500) COMMENT 'CDN访问地址',
    access_level ENUM('public', 'private', 'protected') DEFAULT 'private' COMMENT '访问级别',
    category ENUM('avatar', 'certificate', 'service', 'order', 'system', 'temp') NOT NULL COMMENT '文件分类',
    owner_id BIGINT COMMENT '文件所有者ID',
    owner_type ENUM('user', 'provider', 'admin', 'system') COMMENT '所有者类型',
    upload_ip VARCHAR(45) COMMENT '上传IP地址',
    user_agent TEXT COMMENT '上传用户代理',
    status ENUM('uploading', 'completed', 'failed', 'deleted') DEFAULT 'uploading' COMMENT '文件状态',
    virus_scan_status ENUM('pending', 'scanning', 'clean', 'infected', 'error') DEFAULT 'pending' COMMENT '病毒扫描状态',
    virus_scan_result TEXT COMMENT '病毒扫描结果',
    download_count INT DEFAULT 0 COMMENT '下载次数',
    last_access_at TIMESTAMP NULL COMMENT '最后访问时间',
    expires_at TIMESTAMP NULL COMMENT '过期时间',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_file_id (file_id),
    INDEX idx_md5_hash (md5_hash),
    INDEX idx_owner (owner_id, owner_type),
    INDEX idx_category (category),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at),
    FOREIGN KEY (owner_id) REFERENCES users(id) ON DELETE SET NULL
);
```

### 2.2 文件版本表 (file_versions)
```sql
CREATE TABLE file_versions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    file_id BIGINT NOT NULL COMMENT '文件ID',
    version_number INT NOT NULL COMMENT '版本号',
    file_path VARCHAR(500) NOT NULL COMMENT '版本文件路径',
    file_size BIGINT NOT NULL COMMENT '文件大小',
    md5_hash VARCHAR(32) NOT NULL COMMENT '文件MD5值',
    change_description TEXT COMMENT '变更说明',
    created_by BIGINT COMMENT '创建人',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_file_id (file_id),
    INDEX idx_version (file_id, version_number),
    FOREIGN KEY (file_id) REFERENCES files(id) ON DELETE CASCADE,
    FOREIGN KEY (created_by) REFERENCES users(id) ON DELETE SET NULL
);
```

### 2.3 文件访问权限表 (file_permissions)
```sql
CREATE TABLE file_permissions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    file_id BIGINT NOT NULL COMMENT '文件ID',
    user_id BIGINT COMMENT '用户ID',
    role_id BIGINT COMMENT '角色ID',
    permission_type ENUM('read', 'write', 'delete', 'share') NOT NULL COMMENT '权限类型',
    granted_by BIGINT COMMENT '授权人',
    expires_at TIMESTAMP NULL COMMENT '权限过期时间',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_file_id (file_id),
    INDEX idx_user_id (user_id),
    INDEX idx_role_id (role_id),
    FOREIGN KEY (file_id) REFERENCES files(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (granted_by) REFERENCES users(id) ON DELETE SET NULL
);
```

### 2.4 文件访问日志表 (file_access_logs)
```sql
CREATE TABLE file_access_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    file_id BIGINT NOT NULL COMMENT '文件ID',
    user_id BIGINT COMMENT '访问用户ID',
    action ENUM('upload', 'download', 'view', 'delete', 'share') NOT NULL COMMENT '操作类型',
    ip_address VARCHAR(45) COMMENT '访问IP',
    user_agent TEXT COMMENT '用户代理',
    referer VARCHAR(500) COMMENT '来源页面',
    response_code INT COMMENT '响应状态码',
    response_size BIGINT COMMENT '响应大小',
    response_time INT COMMENT '响应时间(毫秒)',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_file_id (file_id),
    INDEX idx_user_id (user_id),
    INDEX idx_action (action),
    INDEX idx_created_at (created_at),
    FOREIGN KEY (file_id) REFERENCES files(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
);
```

### 2.5 存储配置表 (storage_configs)
```sql
CREATE TABLE storage_configs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    storage_type ENUM('local', 'oss', 'cos', 'qiniu') NOT NULL UNIQUE,
    config_name VARCHAR(50) NOT NULL COMMENT '配置名称',
    endpoint VARCHAR(255) COMMENT '存储端点',
    access_key VARCHAR(100) COMMENT '访问密钥',
    secret_key VARCHAR(100) COMMENT '密钥',
    bucket_name VARCHAR(100) COMMENT '存储桶名称',
    region VARCHAR(50) COMMENT '存储区域',
    cdn_domain VARCHAR(255) COMMENT 'CDN域名',
    is_default BOOLEAN DEFAULT FALSE COMMENT '是否默认存储',
    is_enabled BOOLEAN DEFAULT TRUE COMMENT '是否启用',
    max_file_size BIGINT DEFAULT 104857600 COMMENT '最大文件大小(100MB)',
    allowed_extensions JSON COMMENT '允许的文件扩展名',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

## 3. API接口设计

### 3.1 文件上传接口
```typescript
// 单文件上传
POST /api/files/upload
Content-Type: multipart/form-data
{
  "file": File,
  "category": "avatar",
  "accessLevel": "private",
  "description": "用户头像"
}

// 多文件上传
POST /api/files/batch_upload
Content-Type: multipart/form-data
{
  "files": File[],
  "category": "service",
  "accessLevel": "public"
}

// 分片上传初始化
POST /api/files/multipart/init
{
  "fileName": "large-file.zip",
  "fileSize": 1073741824,
  "chunkSize": 5242880,
  "md5Hash": "d41d8cd98f00b204e9800998ecf8427e"
}

// 分片上传
POST /api/files/multipart/upload/{uploadId}
Content-Type: multipart/form-data
{
  "chunk": File,
  "chunkIndex": 1,
  "chunkHash": "chunk_md5_hash"
}

// 分片上传完成
POST /api/files/multipart/complete/{uploadId}
{
  "chunks": [
    {"index": 1, "hash": "chunk1_hash"},
    {"index": 2, "hash": "chunk2_hash"}
  ]
}
```

### 3.2 文件管理接口
```typescript
// 获取文件列表
GET /api/files?page=1&size=20&category=avatar&owner=12345&status=completed

// 获取文件详情
GET /api/files/{fileId}

// 更新文件信息
PUT /api/files/{fileId}
{
  "originalName": "new-name.jpg",
  "description": "更新后的描述",
  "accessLevel": "public"
}

// 删除文件
DELETE /api/files/{fileId}

// 批量删除文件
DELETE /api/files/batch
{
  "fileIds": ["file1", "file2", "file3"]
}

// 复制文件
POST /api/files/{fileId}/copy
{
  "newName": "copy-of-file.jpg",
  "category": "service"
}

// 移动文件
POST /api/files/{fileId}/move
{
  "newPath": "/new/path/",
  "category": "order"
}
```

### 3.3 文件访问接口
```typescript
// 获取文件下载链接
GET /api/files/{file_id}/download_url?expires=3600

// 直接下载文件
GET /api/files/{file_id}/download

// 获取文件预览链接
GET /api/files/{file_id}/preview_url?width=200&height=200

// 获取文件缩略图
GET /api/files/{file_id}/thumbnail?size=small

// 文件在线预览
GET /api/files/{file_id}/preview
```

### 3.4 权限管理接口
```typescript
// 获取文件权限
GET /api/files/{fileId}/permissions

// 设置文件权限
POST /api/files/{fileId}/permissions
{
  "permissions": [
    {
      "userId": 12345,
      "permissionType": "read",
      "expiresAt": "2024-12-31 23:59:59"
    }
  ]
}

// 分享文件
POST /api/files/{fileId}/share
{
  "shareType": "link",
  "expiresAt": "2024-01-31 23:59:59",
  "password": "123456",
  "allowDownload": true
}

// 获取分享链接
GET /api/files/shared/{shareToken}
```

### 3.5 统计分析接口
```typescript
// 获取文件统计
GET /api/files/statistics?period=7d&category=avatar

// 获取存储使用情况
GET /api/files/storage/usage

// 获取访问日志
GET /api/files/{file_id}/access_logs?page=1&size=20&action=download
```

## 4. 核心业务逻辑

### 4.1 文件上传服务 (FileUploadService)
```typescript
class FileUploadService {
  // 单文件上传
  async uploadFile(file: File, options: UploadOptions): Promise<FileInfo> {
    // 1. 文件验证
    await this.validateFile(file, options);
    
    // 2. 生成文件ID和存储路径
    const fileId = this.generateFileId();
    const storagePath = this.generateStoragePath(file, options.category);
    
    // 3. 计算文件哈希
    const md5Hash = await this.calculateMD5(file);
    const sha256Hash = await this.calculateSHA256(file);
    
    // 4. 检查文件是否已存在（去重）
    const existingFile = await this.findFileByHash(md5Hash);
    if (existingFile && options.allowDuplicate === false) {
      return this.createFileReference(existingFile, options);
    }
    
    // 5. 创建文件记录
    const fileRecord = await this.createFileRecord({
      fileId,
      originalName: file.name,
      fileName: this.generateFileName(file),
      filePath: storagePath,
      fileSize: file.size,
      fileType: this.getFileType(file),
      mimeType: file.type,
      fileExtension: this.getFileExtension(file.name),
      md5Hash,
      sha256Hash,
      category: options.category,
      ownerId: options.ownerId,
      ownerType: options.ownerType,
      accessLevel: options.accessLevel,
      status: 'uploading'
    });
    
    // 6. 上传到存储服务
    try {
      const storageResult = await this.uploadToStorage(file, storagePath);
      
      // 7. 更新文件状态
      await this.updateFileStatus(fileRecord.id, 'completed', {
        cdnUrl: storageResult.cdnUrl,
        storageType: storageResult.storageType,
        storageBucket: storageResult.bucket
      });
      
      // 8. 启动病毒扫描
      await this.scheduleVirusScan(fileRecord.id);
      
      // 9. 记录访问日志
      await this.logFileAccess(fileRecord.id, 'upload', options.userId);
      
      return await this.getFileInfo(fileRecord.id);
    } catch (error) {
      await this.updateFileStatus(fileRecord.id, 'failed');
      throw error;
    }
  }
  
  // 分片上传
  async initMultipartUpload(request: MultipartInitRequest): Promise<string> {
    // 1. 验证文件信息
    await this.validateMultipartRequest(request);
    
    // 2. 创建上传会话
    const uploadId = this.generateUploadId();
    const uploadSession = {
      uploadId,
      fileName: request.fileName,
      fileSize: request.fileSize,
      chunkSize: request.chunkSize,
      totalChunks: Math.ceil(request.fileSize / request.chunkSize),
      md5Hash: request.md5Hash,
      uploadedChunks: new Set(),
      createdAt: new Date(),
      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24小时过期
    };
    
    await this.saveUploadSession(uploadSession);
    return uploadId;
  }
  
  async uploadChunk(uploadId: string, chunk: ChunkData): Promise<void> {
    // 1. 获取上传会话
    const session = await this.getUploadSession(uploadId);
    if (!session || session.expiresAt < new Date()) {
      throw new Error('上传会话不存在或已过期');
    }
    
    // 2. 验证分片
    await this.validateChunk(chunk, session);
    
    // 3. 上传分片到临时存储
    const chunkPath = this.getChunkPath(uploadId, chunk.index);
    await this.uploadChunkToStorage(chunk.data, chunkPath);
    
    // 4. 更新上传进度
    session.uploadedChunks.add(chunk.index);
    await this.updateUploadSession(session);
  }
  
  async completeMultipartUpload(uploadId: string, chunks: ChunkInfo[]): Promise<FileInfo> {
    // 1. 获取上传会话
    const session = await this.getUploadSession(uploadId);
    
    // 2. 验证所有分片已上传
    await this.validateAllChunks(session, chunks);
    
    // 3. 合并分片
    const mergedFilePath = await this.mergeChunks(uploadId, chunks);
    
    // 4. 验证合并后文件
    const mergedFileHash = await this.calculateFileHash(mergedFilePath);
    if (mergedFileHash !== session.md5Hash) {
      throw new Error('文件完整性验证失败');
    }
    
    // 5. 创建文件记录
    const fileRecord = await this.createFileFromMerged(session, mergedFilePath);
    
    // 6. 清理临时文件和会话
    await this.cleanupUploadSession(uploadId);
    
    return await this.getFileInfo(fileRecord.id);
  }
}
```

### 4.2 文件存储服务 (FileStorageService)
```typescript
class FileStorageService {
  private storageAdapters: Map<string, StorageAdapter> = new Map();
  
  constructor() {
    this.initializeStorageAdapters();
  }
  
  // 上传文件到存储
  async uploadToStorage(file: File, path: string, storageType?: string): Promise<StorageResult> {
    const adapter = this.getStorageAdapter(storageType);
    
    try {
      const result = await adapter.upload(file, path);
      return {
        success: true,
        storageType: adapter.getType(),
        bucket: adapter.getBucket(),
        path: result.path,
        url: result.url,
        cdnUrl: result.cdnUrl
      };
    } catch (error) {
      console.error('文件上传失败:', error);
      throw new Error(`文件上传失败: ${error.message}`);
    }
  }
  
  // 从存储删除文件
  async deleteFromStorage(filePath: string, storageType: string): Promise<void> {
    const adapter = this.getStorageAdapter(storageType);
    await adapter.delete(filePath);
  }
  
  // 获取文件访问URL
  async getFileUrl(filePath: string, storageType: string, expires?: number): Promise<string> {
    const adapter = this.getStorageAdapter(storageType);
    return await adapter.getSignedUrl(filePath, expires);
  }
  
  // 复制文件
  async copyFile(sourcePath: string, targetPath: string, storageType: string): Promise<void> {
    const adapter = this.getStorageAdapter(storageType);
    await adapter.copy(sourcePath, targetPath);
  }
  
  private getStorageAdapter(storageType?: string): StorageAdapter {
    const type = storageType || this.getDefaultStorageType();
    const adapter = this.storageAdapters.get(type);
    
    if (!adapter) {
      throw new Error(`不支持的存储类型: ${type}`);
    }
    
    return adapter;
  }
}

// 存储适配器接口
interface StorageAdapter {
  getType(): string;
  getBucket(): string;
  upload(file: File, path: string): Promise<UploadResult>;
  delete(path: string): Promise<void>;
  getSignedUrl(path: string, expires?: number): Promise<string>;
  copy(sourcePath: string, targetPath: string): Promise<void>;
}

// 阿里云OSS适配器
class OSSStorageAdapter implements StorageAdapter {
  private client: OSS;
  
  constructor(config: OSSConfig) {
    this.client = new OSS(config);
  }
  
  getType(): string {
    return 'oss';
  }
  
  getBucket(): string {
    return this.client.options.bucket;
  }
  
  async upload(file: File, path: string): Promise<UploadResult> {
    const result = await this.client.put(path, file);
    return {
      path: result.name,
      url: result.url,
      cdnUrl: this.getCdnUrl(result.name)
    };
  }
  
  async delete(path: string): Promise<void> {
    await this.client.delete(path);
  }
  
  async getSignedUrl(path: string, expires: number = 3600): Promise<string> {
    return this.client.signatureUrl(path, { expires });
  }
  
  async copy(sourcePath: string, targetPath: string): Promise<void> {
    await this.client.copy(targetPath, sourcePath);
  }
  
  private getCdnUrl(path: string): string {
    // 返回CDN加速URL
    return `https://cdn.example.com/${path}`;
  }
}
```

### 4.3 文件权限服务 (FilePermissionService)
```typescript
class FilePermissionService {
  // 检查文件访问权限
  async checkFileAccess(fileId: string, userId: number, action: string): Promise<boolean> {
    // 1. 获取文件信息
    const file = await this.getFileInfo(fileId);
    if (!file) {
      return false;
    }
    
    // 2. 检查文件所有者权限
    if (file.ownerId === userId) {
      return true;
    }
    
    // 3. 检查公开文件权限
    if (file.accessLevel === 'public' && action === 'read') {
      return true;
    }
    
    // 4. 检查受保护文件权限
    if (file.accessLevel === 'protected') {
      return await this.checkProtectedAccess(file, userId, action);
    }
    
    // 5. 检查显式授权权限
    return await this.checkExplicitPermission(fileId, userId, action);
  }
  
  // 设置文件权限
  async setFilePermissions(fileId: string, permissions: FilePermission[]): Promise<void> {
    // 1. 验证权限设置
    await this.validatePermissions(fileId, permissions);
    
    // 2. 删除现有权限
    await this.clearFilePermissions(fileId);
    
    // 3. 添加新权限
    for (const permission of permissions) {
      await this.addFilePermission(fileId, permission);
    }
    
    // 4. 记录权限变更日志
    await this.logPermissionChange(fileId, permissions);
  }
  
  // 生成文件分享链接
  async createShareLink(fileId: string, options: ShareOptions): Promise<string> {
    // 1. 验证分享权限
    await this.validateSharePermission(fileId, options.userId);
    
    // 2. 生成分享令牌
    const shareToken = this.generateShareToken();
    
    // 3. 创建分享记录
    await this.createShareRecord({
      fileId,
      shareToken,
      shareType: options.shareType,
      expiresAt: options.expiresAt,
      password: options.password,
      allowDownload: options.allowDownload,
      createdBy: options.userId
    });
    
    // 4. 返回分享链接
    return this.buildShareUrl(shareToken);
  }
  
  // 验证分享访问
  async validateShareAccess(shareToken: string, password?: string): Promise<FileInfo> {
    // 1. 获取分享记录
    const shareRecord = await this.getShareRecord(shareToken);
    if (!shareRecord) {
      throw new Error('分享链接不存在');
    }
    
    // 2. 检查过期时间
    if (shareRecord.expiresAt && shareRecord.expiresAt < new Date()) {
      throw new Error('分享链接已过期');
    }
    
    // 3. 验证密码
    if (shareRecord.password && shareRecord.password !== password) {
      throw new Error('分享密码错误');
    }
    
    // 4. 获取文件信息
    const file = await this.getFileInfo(shareRecord.fileId);
    if (!file || file.status !== 'completed') {
      throw new Error('文件不存在或不可用');
    }
    
    // 5. 记录访问日志
    await this.logShareAccess(shareRecord.id);
    
    return file;
  }
}
```

## 5. 前端界面设计

### 5.1 管理后台界面

#### 5.1.1 文件管理页面
- **文件列表视图**
  - 支持列表和网格两种显示模式
  - 文件搜索和高级筛选（类型、大小、时间、所有者）
  - 批量操作（下载、删除、移动、设置权限）
  - 文件预览功能（图片、文档、视频）

- **文件上传组件**
  - 拖拽上传支持
  - 多文件同时上传
  - 上传进度显示
  - 大文件分片上传
  - 上传失败重试

#### 5.1.2 存储管理页面
- **存储配置管理**
  - 多存储源配置（本地、OSS、COS等）
  - 存储策略设置
  - CDN配置管理

- **存储统计分析**
  - 存储使用量统计
  - 文件类型分布
  - 访问热度分析
  - 成本分析报表

#### 5.1.3 权限管理页面
- **文件权限设置**
  - 用户/角色权限配置
  - 批量权限设置
  - 权限继承规则

- **分享管理**
  - 分享链接管理
  - 分享统计分析
  - 分享安全设置

### 5.2 用户端界面

#### 5.2.1 文件上传组件
- **简洁上传界面**
  - 一键上传按钮
  - 拖拽上传区域
  - 上传进度提示
  - 上传结果反馈

#### 5.2.2 文件管理界面
- **个人文件管理**
  - 文件分类浏览
  - 文件搜索功能
  - 文件预览和下载
  - 文件分享功能

## 6. 性能优化

### 6.1 上传优化
- **分片上传**：大文件自动分片上传，支持断点续传
- **并发上传**：多文件并发上传，提高上传效率
- **压缩优化**：图片自动压缩和格式转换
- **去重机制**：基于文件哈希的智能去重

### 6.2 存储优化
- **分层存储**：根据访问频率自动分层存储
- **CDN加速**：静态文件CDN分发加速
- **缓存策略**：文件元数据和访问权限缓存
- **预签名URL**：减少服务器中转，直接访问存储

### 6.3 访问优化
- **图片处理**：实时图片缩放、裁剪、格式转换
- **预览优化**：文档在线预览，视频流媒体播放
- **带宽控制**：下载速度限制和流量控制
- **访问统计**：实时访问统计和热点分析

## 7. 安全与防护

### 7.1 上传安全
- **文件类型检查**：严格的文件类型和扩展名验证
- **文件大小限制**：防止恶意大文件上传
- **病毒扫描**：集成杀毒引擎进行文件安全扫描
- **内容检测**：敏感内容和恶意代码检测

### 7.2 访问安全
- **权限控制**：细粒度的文件访问权限控制
- **访问令牌**：临时访问令牌和签名验证
- **防盗链**：Referer检查和访问来源验证
- **访问限制**：IP白名单和访问频率限制

### 7.3 存储安全
- **数据加密**：敏感文件存储加密
- **备份策略**：多地域备份和灾难恢复
- **访问日志**：完整的文件访问审计日志
- **数据销毁**：安全的文件删除和数据销毁

## 8. 监控与告警

### 8.1 性能监控
- **上传性能**：上传速度、成功率、失败原因监控
- **存储性能**：存储读写性能、可用性监控
- **CDN性能**：CDN命中率、响应时间监控
- **带宽使用**：上传下载带宽使用情况监控

### 8.2 安全监控
- **异常访问**：异常访问模式和可疑行为监控
- **病毒检测**：病毒文件检测和处理监控
- **权限变更**：文件权限变更审计和告警
- **存储安全**：存储服务安全状态监控

### 8.3 业务监控
- **存储使用**：存储空间使用量和增长趋势
- **文件统计**：文件上传、下载、删除统计
- **用户行为**：用户文件操作行为分析
- **成本分析**：存储和CDN成本分析

## 9. 阿里云ECS部署优化方案

### 9.1 ECS环境架构设计

#### 9.1.1 服务器配置建议
```yaml
# 推荐ECS实例配置
生产环境:
  实例规格: ecs.c6.2xlarge (8核16GB)
  系统盘: ESSD云盘 100GB
  数据盘: ESSD云盘 500GB (用于临时文件存储)
  网络: 专有网络VPC
  带宽: 100Mbps (可根据业务需求调整)

测试环境:
  实例规格: ecs.c6.large (2核4GB)
  系统盘: 高效云盘 40GB
  数据盘: 高效云盘 200GB
  网络: 专有网络VPC
  带宽: 10Mbps
```

#### 9.1.2 存储架构设计
```typescript
// ECS混合存储策略配置
interface ECSStorageConfig {
  // 本地存储配置
  localStorage: {
    tempPath: '/data/temp',           // 临时文件目录
    cachePath: '/data/cache',         // 缓存文件目录
    maxLocalSize: '50GB',             // 本地存储最大容量
    cleanupInterval: '1h',            // 清理间隔
    retentionDays: 7                  // 临时文件保留天数
  };
  
  // OSS存储配置
  ossStorage: {
    endpoint: 'oss-cn-hangzhou.aliyuncs.com',
    bucket: 'l2c-files-prod',
    region: 'cn-hangzhou',
    internalEndpoint: 'oss-cn-hangzhou-internal.aliyuncs.com', // 内网访问
    cdnDomain: 'files.l2c.com',
    storageClass: 'Standard'          // Standard/IA/Archive
  };
  
  // 存储策略
  storageStrategy: {
    smallFiles: 'local',              // <1MB 文件本地存储
    mediumFiles: 'oss',               // 1MB-100MB 文件OSS存储
    largeFiles: 'oss',                // >100MB 文件OSS存储
    tempFiles: 'local',               // 临时文件本地存储
    backupFiles: 'oss'                // 备份文件OSS存储
  };
}
```

### 9.2 阿里云OSS集成优化

#### 9.2.1 OSS配置优化
```typescript
// 优化的OSS存储适配器
class OptimizedOSSAdapter implements StorageAdapter {
  private client: OSS;
  private internalClient: OSS;
  
  constructor(config: OSSConfig) {
    // 外网访问客户端
    this.client = new OSS({
      region: config.region,
      accessKeyId: config.accessKeyId,
      accessKeySecret: config.accessKeySecret,
      bucket: config.bucket,
      endpoint: config.endpoint,
      timeout: 60000,
      secure: true
    });
    
    // 内网访问客户端（ECS内网访问OSS，免流量费）
    this.internalClient = new OSS({
      region: config.region,
      accessKeyId: config.accessKeyId,
      accessKeySecret: config.accessKeySecret,
      bucket: config.bucket,
      endpoint: config.internalEndpoint,
      timeout: 60000,
      secure: true
    });
  }
  
  async upload(file: File, path: string): Promise<UploadResult> {
    try {
      // 使用内网端点上传，节省流量费用
      const result = await this.internalClient.put(path, file, {
        headers: {
          'Cache-Control': 'max-age=31536000',
          'Content-Disposition': `attachment; filename="${encodeURIComponent(file.name)}"`,
          'x-oss-storage-class': this.getStorageClass(file.size)
        }
      });
      
      return {
        path: result.name,
        url: result.url,
        cdnUrl: this.getCdnUrl(result.name),
        etag: result.etag
      };
    } catch (error) {
      console.error('OSS上传失败:', error);
      throw new Error(`OSS上传失败: ${error.message}`);
    }
  }
  
  // 根据文件大小选择存储类型
  private getStorageClass(fileSize: number): string {
    if (fileSize > 100 * 1024 * 1024) { // >100MB
      return 'IA'; // 低频访问存储，成本更低
    }
    return 'Standard'; // 标准存储
  }
  
  // 生成CDN加速URL
  private getCdnUrl(path: string): string {
    return `https://files.l2c.com/${path}`;
  }
  
  // 批量上传优化
  async batchUpload(files: File[], basePath: string): Promise<UploadResult[]> {
    const uploadPromises = files.map(async (file, index) => {
      const filePath = `${basePath}/${Date.now()}_${index}_${file.name}`;
      return this.upload(file, filePath);
    });
    
    // 并发上传，但限制并发数量
    const results = await this.limitConcurrency(uploadPromises, 5);
    return results;
  }
  
  private async limitConcurrency<T>(promises: Promise<T>[], limit: number): Promise<T[]> {
    const results: T[] = [];
    for (let i = 0; i < promises.length; i += limit) {
      const batch = promises.slice(i, i + limit);
      const batchResults = await Promise.all(batch);
      results.push(...batchResults);
    }
    return results;
  }
}
```

#### 9.2.2 ECS本地存储服务
```typescript
// ECS本地存储适配器
class ECSLocalStorageAdapter implements StorageAdapter {
  private basePath: string;
  private maxSize: number;
  
  constructor(config: LocalStorageConfig) {
    this.basePath = config.basePath || '/data/files';
    this.maxSize = config.maxSize || 50 * 1024 * 1024 * 1024; // 50GB
    this.ensureDirectoryExists();
  }
  
  async upload(file: File, path: string): Promise<UploadResult> {
    // 检查存储空间
    await this.checkStorageSpace(file.size);
    
    const fullPath = this.getFullPath(path);
    const directory = dirname(fullPath);
    
    // 确保目录存在
    await fs.ensureDir(directory);
    
    // 写入文件
    await fs.writeFile(fullPath, file.buffer);
    
    // 设置文件权限
    await fs.chmod(fullPath, 0o644);
    
    return {
      path: path,
      url: this.getLocalUrl(path),
      cdnUrl: null,
      size: file.size
    };
  }
  
  async delete(path: string): Promise<void> {
    const fullPath = this.getFullPath(path);
    await fs.remove(fullPath);
  }
  
  // 存储空间检查
  private async checkStorageSpace(fileSize: number): Promise<void> {
    const stats = await fs.stat(this.basePath);
    const currentSize = await this.getDirectorySize(this.basePath);
    
    if (currentSize + fileSize > this.maxSize) {
      // 触发清理策略
      await this.cleanupOldFiles();
      
      // 再次检查
      const newSize = await this.getDirectorySize(this.basePath);
      if (newSize + fileSize > this.maxSize) {
        throw new Error('本地存储空间不足');
      }
    }
  }
  
  // 清理旧文件
  private async cleanupOldFiles(): Promise<void> {
    const files = await this.getFilesByAge();
    const targetSize = this.maxSize * 0.8; // 清理到80%容量
    let currentSize = await this.getDirectorySize(this.basePath);
    
    for (const file of files) {
      if (currentSize <= targetSize) break;
      
      await fs.remove(file.path);
      currentSize -= file.size;
    }
  }
}
```

### 9.3 CDN集成配置

#### 9.3.1 阿里云CDN配置
```yaml
# CDN域名配置
cdn_config:
  domain: files.l2c.com
  origin:
    type: oss
    domain: l2c-files-prod.oss-cn-hangzhou.aliyuncs.com
  
  # 缓存规则
  cache_rules:
    - path: "*.jpg,*.png,*.gif,*.webp"
      ttl: 31536000  # 1年
    - path: "*.pdf,*.doc,*.docx"
      ttl: 86400     # 1天
    - path: "*.mp4,*.avi,*.mov"
      ttl: 604800    # 1周
  
  # 访问控制
  access_control:
    referer_whitelist:
      - "*.l2c.com"
      - "l2c.com"
    ip_blacklist: []
    
  # HTTPS配置
  https:
    enabled: true
    force_redirect: true
    certificate: "your-ssl-cert"
```

#### 9.3.2 CDN集成服务
```typescript
class CDNService {
  private cdnClient: CDNClient;
  
  constructor(config: CDNConfig) {
    this.cdnClient = new CDNClient({
      accessKeyId: config.accessKeyId,
      accessKeySecret: config.accessKeySecret,
      endpoint: 'https://cdn.aliyuncs.com'
    });
  }
  
  // 预热CDN缓存
  async preloadUrls(urls: string[]): Promise<void> {
    try {
      await this.cdnClient.pushObjectCache({
        ObjectPath: urls.join('\n'),
        ObjectType: 'File'
      });
    } catch (error) {
      console.error('CDN预热失败:', error);
    }
  }
  
  // 刷新CDN缓存
  async refreshUrls(urls: string[]): Promise<void> {
    try {
      await this.cdnClient.refreshObjectCaches({
        ObjectPath: urls.join('\n'),
        ObjectType: 'File'
      });
    } catch (error) {
      console.error('CDN刷新失败:', error);
    }
  }
  
  // 获取CDN统计数据
  async getCDNStats(domain: string, startTime: Date, endTime: Date): Promise<CDNStats> {
    const response = await this.cdnClient.describeDomainBpsData({
      DomainName: domain,
      StartTime: startTime.toISOString(),
      EndTime: endTime.toISOString()
    });
    
    return {
      bandwidth: response.BpsDataPerInterval,
      traffic: response.TotalTraffic,
      requests: response.TotalRequests
    };
  }
}
```

### 9.4 ECS安全加固

#### 9.4.1 系统安全配置
```bash
#!/bin/bash
# ECS安全加固脚本

# 1. 更新系统
yum update -y

# 2. 安装安全工具
yum install -y fail2ban clamav clamav-update

# 3. 配置防火墙
systemctl enable firewalld
systemctl start firewalld

# 开放必要端口
firewall-cmd --permanent --add-port=80/tcp
firewall-cmd --permanent --add-port=443/tcp
firewall-cmd --permanent --add-port=22/tcp
firewall-cmd --reload

# 4. 配置fail2ban
cat > /etc/fail2ban/jail.local << EOF
[DEFAULT]
bantime = 3600
findtime = 600
maxretry = 5

[sshd]
enabled = true
port = ssh
logpath = /var/log/secure
maxretry = 3
EOF

systemctl enable fail2ban
systemctl start fail2ban

# 5. 配置文件权限
chmod 700 /data
chown -R app:app /data
```

#### 9.4.2 应用安全配置
```typescript
// 文件安全扫描服务
class FileSecurityService {
  private clamAV: ClamAVClient;
  
  constructor() {
    this.clamAV = new ClamAVClient({
      host: 'localhost',
      port: 3310
    });
  }
  
  // 病毒扫描
  async scanFile(filePath: string): Promise<ScanResult> {
    try {
      const result = await this.clamAV.scanFile(filePath);
      return {
        isClean: result.isClean,
        virus: result.virus,
        scanTime: new Date()
      };
    } catch (error) {
      console.error('病毒扫描失败:', error);
      return {
        isClean: false,
        virus: 'SCAN_ERROR',
        scanTime: new Date()
      };
    }
  }
  
  // 文件类型验证
  async validateFileType(file: File): Promise<boolean> {
    const allowedTypes = [
      'image/jpeg', 'image/png', 'image/gif', 'image/webp',
      'application/pdf', 'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'video/mp4', 'video/avi', 'video/quicktime'
    ];
    
    // MIME类型检查
    if (!allowedTypes.includes(file.type)) {
      return false;
    }
    
    // 文件头检查
    const fileHeader = await this.getFileHeader(file);
    return this.validateFileHeader(fileHeader, file.type);
  }
  
  private async getFileHeader(file: File): Promise<Buffer> {
    const buffer = Buffer.alloc(512);
    const stream = file.stream();
    const reader = stream.getReader();
    const { value } = await reader.read();
    return Buffer.from(value.slice(0, 512));
  }
  
  private validateFileHeader(header: Buffer, mimeType: string): boolean {
    const signatures = {
      'image/jpeg': [0xFF, 0xD8, 0xFF],
      'image/png': [0x89, 0x50, 0x4E, 0x47],
      'image/gif': [0x47, 0x49, 0x46],
      'application/pdf': [0x25, 0x50, 0x44, 0x46]
    };
    
    const signature = signatures[mimeType];
    if (!signature) return true;
    
    return signature.every((byte, index) => header[index] === byte);
  }
}
```

### 9.5 监控与运维

#### 9.5.1 ECS监控配置
```typescript
// ECS资源监控
class ECSMonitoringService {
  private cloudMonitor: CloudMonitorClient;
  
  constructor(config: MonitoringConfig) {
    this.cloudMonitor = new CloudMonitorClient({
      accessKeyId: config.accessKeyId,
      accessKeySecret: config.accessKeySecret,
      endpoint: 'https://cms.aliyuncs.com'
    });
  }
  
  // 设置监控告警
  async setupAlerts(): Promise<void> {
    const alerts = [
      {
        name: 'ECS-CPU-High',
        metric: 'CPUUtilization',
        threshold: 80,
        comparison: 'GreaterThanThreshold'
      },
      {
        name: 'ECS-Memory-High',
        metric: 'MemoryUtilization',
        threshold: 85,
        comparison: 'GreaterThanThreshold'
      },
      {
        name: 'ECS-Disk-High',
        metric: 'DiskUtilization',
        threshold: 90,
        comparison: 'GreaterThanThreshold'
      }
    ];
    
    for (const alert of alerts) {
      await this.createAlert(alert);
    }
  }
  
  // 获取ECS性能指标
  async getECSMetrics(instanceId: string, period: string): Promise<ECSMetrics> {
    const endTime = new Date();
    const startTime = new Date(endTime.getTime() - this.parsePeriod(period));
    
    const [cpu, memory, disk, network] = await Promise.all([
      this.getMetric('acs_ecs_dashboard', 'CPUUtilization', instanceId, startTime, endTime),
      this.getMetric('acs_ecs_dashboard', 'MemoryUtilization', instanceId, startTime, endTime),
      this.getMetric('acs_ecs_dashboard', 'DiskUtilization', instanceId, startTime, endTime),
      this.getMetric('acs_ecs_dashboard', 'InternetInRate', instanceId, startTime, endTime)
    ]);
    
    return { cpu, memory, disk, network };
  }
}
```

#### 9.5.2 自动化运维脚本
```bash
#!/bin/bash
# 文件管理模块运维脚本

# 日志清理
cleanup_logs() {
    echo "清理应用日志..."
    find /var/log/app -name "*.log" -mtime +7 -delete
    
    echo "清理临时文件..."
    find /data/temp -type f -mtime +1 -delete
    
    echo "清理缓存文件..."
    find /data/cache -type f -mtime +3 -delete
}

# 健康检查
health_check() {
    echo "检查应用服务状态..."
    systemctl is-active --quiet app-server || {
        echo "应用服务异常，尝试重启..."
        systemctl restart app-server
    }
    
    echo "检查磁盘空间..."
    DISK_USAGE=$(df /data | awk 'NR==2 {print $5}' | sed 's/%//')
    if [ $DISK_USAGE -gt 90 ]; then
        echo "磁盘空间不足，执行清理..."
        cleanup_logs
    fi
    
    echo "检查内存使用..."
    MEM_USAGE=$(free | awk 'NR==2{printf "%.0f", $3*100/$2}')
    if [ $MEM_USAGE -gt 90 ]; then
        echo "内存使用过高，重启应用..."
        systemctl restart app-server
    fi
}

# 备份数据
backup_data() {
    echo "备份重要数据到OSS..."
    DATE=$(date +%Y%m%d)
    
    # 备份数据库
    mysqldump -u root -p$DB_PASSWORD l2c_db > /tmp/db_backup_$DATE.sql
    ossutil cp /tmp/db_backup_$DATE.sql oss://l2c-backup/database/
    
    # 备份配置文件
    tar -czf /tmp/config_backup_$DATE.tar.gz /etc/app/
    ossutil cp /tmp/config_backup_$DATE.tar.gz oss://l2c-backup/config/
    
    # 清理本地备份文件
    rm -f /tmp/*backup*
}

# 定时任务
case "$1" in
    cleanup)
        cleanup_logs
        ;;
    health)
        health_check
        ;;
    backup)
        backup_data
        ;;
    *)
        echo "Usage: $0 {cleanup|health|backup}"
        exit 1
        ;;
esac
```

### 9.6 部署配置文件

#### 9.6.1 Docker配置
```dockerfile
# Dockerfile for ECS deployment
FROM node:18-alpine

WORKDIR /app

# 安装系统依赖
RUN apk add --no-cache \
    imagemagick \
    ffmpeg \
    clamav \
    clamav-daemon

# 复制应用文件
COPY package*.json ./
RUN npm ci --only=production

COPY . .

# 创建数据目录
RUN mkdir -p /data/temp /data/cache /data/files

# 设置权限
RUN addgroup -g 1001 -S app && \
    adduser -S app -u 1001 -G app && \
    chown -R app:app /app /data

USER app

EXPOSE 3000

CMD ["npm", "start"]
```

#### 9.6.2 环境配置
```yaml
# docker-compose.yml for ECS
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DB_HOST=rm-xxxxxx.mysql.rds.aliyuncs.com
      - DB_PORT=3306
      - DB_NAME=l2c_db
      - DB_USER=${DB_USER}
      - DB_PASSWORD=${DB_PASSWORD}
      - OSS_REGION=cn-hangzhou
      - OSS_BUCKET=l2c-files-prod
      - OSS_ACCESS_KEY_ID=${OSS_ACCESS_KEY_ID}
      - OSS_ACCESS_KEY_SECRET=${OSS_ACCESS_KEY_SECRET}
      - CDN_DOMAIN=files.l2c.com
      - REDIS_HOST=r-xxxxxx.redis.rds.aliyuncs.com
      - REDIS_PORT=6379
      - REDIS_PASSWORD=${REDIS_PASSWORD}
    volumes:
      - /data:/data
      - /var/log/app:/app/logs
    restart: unless-stopped
    
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app
    restart: unless-stopped
```

## 10. 总结

针对阿里云ECS部署的文件管理模块优化方案提供了完整的部署架构、存储策略、安全配置和运维方案。通过合理利用阿里云的OSS、CDN、监控等服务，结合ECS的计算能力，能够构建高性能、高可用、安全可靠的文件管理系统。

该方案特别针对ECS环境进行了优化，包括：
- **混合存储策略**：本地存储+OSS云存储，平衡性能和成本
- **内网优化**：利用阿里云内网传输，降低流量成本
- **CDN加速**：提供全国范围的文件访问加速
- **安全加固**：多层次的安全防护措施
- **自动化运维**：完善的监控告警和自动化运维脚本

通过这些优化措施，能够为L2C平台在阿里云ECS环境下提供稳定、高效、安全的文件管理服务。
