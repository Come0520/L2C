# 罗莱L2C销售管理系统 - 用户认证模块设计

## 1. 模块概述

### 1.1 功能目标
用户认证模块是整个L2C销售管理系统的安全基础，负责用户身份验证、会话管理、安全控制等核心功能。

**主要目标：**
- **安全认证**：提供多种认证方式，确保用户身份安全
- **会话管理**：管理用户登录状态和会话生命周期
- **多端支持**：支持Web端、移动端、小程序等多平台认证
- **单点登录**：实现跨平台的统一认证体验
- **安全防护**：防止暴力破解、会话劫持等安全威胁
- **审计追踪**：记录所有认证相关的操作日志

### 1.2 支持的认证方式
- **用户名密码认证**：传统的账号密码登录
- **手机号验证码认证**：短信验证码快速登录
- **微信授权登录**：微信小程序、公众号授权登录
- **扫码登录**：移动端扫码登录Web端
- **生物识别**：指纹、面部识别（移动端）

### 1.3 用户角色体系
支持8种用户角色的认证和权限管理：
- **超级管理员**：系统最高权限
- **区域经理**：区域管理权限
- **门店店长**：门店管理权限
- **销售顾问**：销售业务权限
- **圣都设计师**：设计服务权限
- **圣都导购**：导购服务权限
- **测量师**：测量服务权限
- **安装工**：安装服务权限

## 2. 数据库设计

### 2.1 用户表 (users)
```sql
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE,
    phone VARCHAR(15) UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    salt VARCHAR(32) NOT NULL,
    real_name VARCHAR(50) NOT NULL,
    avatar_url VARCHAR(500),
    role_type VARCHAR(20) NOT NULL, -- 用户角色类型
    status VARCHAR(20) DEFAULT 'active', -- active, inactive, locked, deleted
    city_id BIGINT,
    store_id BIGINT,
    department_id BIGINT,
    employee_id VARCHAR(50), -- 员工编号
    last_login_at TIMESTAMP,
    last_login_ip INET,
    login_count INTEGER DEFAULT 0,
    password_changed_at TIMESTAMP,
    email_verified_at TIMESTAMP,
    phone_verified_at TIMESTAMP,
    two_factor_enabled BOOLEAN DEFAULT false,
    two_factor_secret VARCHAR(32),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);

-- 索引
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_phone ON users(phone);
CREATE INDEX idx_users_role_type ON users(role_type);
CREATE INDEX idx_users_status ON users(status);
CREATE INDEX idx_users_city_store ON users(city_id, store_id);
```

### 2.2 用户会话表 (user_sessions)
```sql
CREATE TABLE user_sessions (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id),
    session_token VARCHAR(255) UNIQUE NOT NULL,
    refresh_token VARCHAR(255) UNIQUE,
    device_type VARCHAR(20) NOT NULL, -- web, mobile, miniprogram
    device_id VARCHAR(100),
    device_info JSONB,
    ip_address INET,
    user_agent TEXT,
    location_info JSONB,
    expires_at TIMESTAMP NOT NULL,
    last_activity_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_sessions_user_id ON user_sessions(user_id);
CREATE INDEX idx_sessions_token ON user_sessions(session_token);
CREATE INDEX idx_sessions_refresh_token ON user_sessions(refresh_token);
CREATE INDEX idx_sessions_expires_at ON user_sessions(expires_at);
CREATE INDEX idx_sessions_device_type ON user_sessions(device_type);
```

### 2.3 登录日志表 (login_logs)
```sql
CREATE TABLE login_logs (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT REFERENCES users(id),
    username VARCHAR(50),
    login_type VARCHAR(20) NOT NULL, -- password, sms, wechat, qrcode, biometric
    login_result VARCHAR(20) NOT NULL, -- success, failed, blocked
    failure_reason VARCHAR(100),
    ip_address INET,
    user_agent TEXT,
    device_type VARCHAR(20),
    device_id VARCHAR(100),
    location_info JSONB,
    session_id BIGINT REFERENCES user_sessions(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_login_logs_user_id ON login_logs(user_id);
CREATE INDEX idx_login_logs_username ON login_logs(username);
CREATE INDEX idx_login_logs_ip_address ON login_logs(ip_address);
CREATE INDEX idx_login_logs_created_at ON login_logs(created_at);
CREATE INDEX idx_login_logs_login_result ON login_logs(login_result);
```

### 2.4 密码重置表 (password_resets)
```sql
CREATE TABLE password_resets (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id),
    reset_token VARCHAR(255) UNIQUE NOT NULL,
    reset_type VARCHAR(20) NOT NULL, -- email, sms
    contact_info VARCHAR(100) NOT NULL, -- 邮箱或手机号
    expires_at TIMESTAMP NOT NULL,
    used_at TIMESTAMP,
    ip_address INET,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_password_resets_token ON password_resets(reset_token);
CREATE INDEX idx_password_resets_user_id ON password_resets(user_id);
CREATE INDEX idx_password_resets_expires_at ON password_resets(expires_at);
```

### 2.5 第三方授权表 (oauth_accounts)
```sql
CREATE TABLE oauth_accounts (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id),
    provider VARCHAR(20) NOT NULL, -- wechat, alipay
    provider_user_id VARCHAR(100) NOT NULL,
    provider_username VARCHAR(100),
    provider_avatar VARCHAR(500),
    access_token TEXT,
    refresh_token TEXT,
    expires_at TIMESTAMP,
    scope TEXT,
    raw_data JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(provider, provider_user_id)
);

-- 索引
CREATE INDEX idx_oauth_accounts_user_id ON oauth_accounts(user_id);
CREATE INDEX idx_oauth_accounts_provider ON oauth_accounts(provider, provider_user_id);
```

### 2.6 安全设置表 (security_settings)
```sql
CREATE TABLE security_settings (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT UNIQUE NOT NULL REFERENCES users(id),
    password_policy JSONB, -- 密码策略配置
    login_restrictions JSONB, -- 登录限制配置
    two_factor_settings JSONB, -- 双因子认证配置
    security_questions JSONB, -- 安全问题配置
    trusted_devices JSONB, -- 信任设备列表
    notification_settings JSONB, -- 安全通知设置
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## 3. API接口设计

### 3.1 用户认证接口

#### 3.1.1 用户名密码登录
```typescript
POST /api/auth/login
Content-Type: application/json

// 请求体
{
  "username": "string",      // 用户名/邮箱/手机号
  "password": "string",      // 密码
  "deviceType": "web|mobile|miniprogram",
  "deviceId": "string",      // 设备唯一标识
  "rememberMe": boolean,     // 是否记住登录
  "captcha": "string",       // 验证码（可选）
  "captchaToken": "string"   // 验证码令牌（可选）
}

// 响应体
{
  "code": 200,
  "message": "登录成功",
  "data": {
    "accessToken": "string",
    "refreshToken": "string",
    "expiresIn": 7200,
    "user": {
      "id": 1,
      "username": "string",
      "realName": "string",
      "avatar": "string",
      "roleType": "string",
      "permissions": ["string"],
      "cityId": 1,
      "storeId": 1
    }
  }
}
```

#### 3.1.2 短信验证码登录
```typescript
POST /api/auth/sms_login
Content-Type: application/json

// 请求体
{
  "phone": "string",         // 手机号
  "smsCode": "string",       // 短信验证码
  "deviceType": "web|mobile|miniprogram",
  "deviceId": "string"
}

// 响应体
{
  "code": 200,
  "message": "登录成功",
  "data": {
    "accessToken": "string",
    "refreshToken": "string",
    "expiresIn": 7200,
    "user": UserInfo
  }
}
```

#### 3.1.3 微信授权登录
```typescript
POST /api/auth/wechat_login
Content-Type: application/json

// 请求体
{
  "code": "string",          // 微信授权码
  "platform": "miniprogram|h5",
  "deviceType": "mobile",
  "deviceId": "string"
}

// 响应体
{
  "code": 200,
  "message": "登录成功",
  "data": {
    "accessToken": "string",
    "refreshToken": "string",
    "expiresIn": 7200,
    "user": UserInfo,
    "isNewUser": boolean
  }
}
```

#### 3.1.4 扫码登录
```typescript
// 生成登录二维码
GET /api/auth/qrcode
{
  "code": 200,
  "data": {
    "qrcodeToken": "string",
    "qrcodeUrl": "string",
    "expiresIn": 300
  }
}

// 扫码确认登录
POST /api/auth/qrcode_confirm
{
  "qrcodeToken": "string",
  "accessToken": "string"  // 移动端用户的token
}

// 轮询登录状态
GET /api/auth/qrcode_status?token=string
{
  "code": 200,
  "data": {
    "status": "pending|scanned|confirmed|expired",
    "accessToken": "string",  // 确认后返回
    "user": UserInfo
  }
}
```

### 3.2 会话管理接口

#### 3.2.1 刷新Token
```typescript
POST /api/auth/refresh
Content-Type: application/json

// 请求体
{
  "refreshToken": "string"
}

// 响应体
{
  "code": 200,
  "data": {
    "accessToken": "string",
    "refreshToken": "string",
    "expiresIn": 7200
  }
}
```

#### 3.2.2 退出登录
```typescript
POST /api/auth/logout
Authorization: Bearer {accessToken}

// 响应体
{
  "code": 200,
  "message": "退出成功"
}
```

#### 3.2.3 获取当前用户信息
```typescript
GET /api/auth/me
Authorization: Bearer {accessToken}

// 响应体
{
  "code": 200,
  "data": {
    "user": UserInfo,
    "permissions": ["string"],
    "roles": ["string"]
  }
}
```

### 3.3 密码管理接口

#### 3.3.1 修改密码
```typescript
PUT /api/auth/password
Authorization: Bearer {accessToken}

// 请求体
{
  "oldPassword": "string",
  "newPassword": "string",
  "confirmPassword": "string"
}

// 响应体
{
  "code": 200,
  "message": "密码修改成功"
}
```

#### 3.3.2 忘记密码
```typescript
POST /api/auth/forgot_password
Content-Type: application/json

// 请求体
{
  "contact": "string",       // 邮箱或手机号
  "type": "email|sms"        // 重置方式
}

// 响应体
{
  "code": 200,
  "message": "重置链接已发送"
}
```

#### 3.3.3 重置密码
```typescript
POST /api/auth/reset_password
Content-Type: application/json

// 请求体
{
  "resetToken": "string",
  "newPassword": "string",
  "confirmPassword": "string"
}

// 响应体
{
  "code": 200,
  "message": "密码重置成功"
}
```

### 3.4 安全管理接口

#### 3.4.1 获取登录历史
```typescript
GET /api/auth/login_history?page=1&limit=20
Authorization: Bearer {accessToken}

// 响应体
{
  "code": 200,
  "data": {
    "list": [
      {
        "id": 1,
        "loginType": "password",
        "loginResult": "success",
        "ipAddress": "192.168.1.1",
        "deviceType": "web",
        "location": "北京市",
        "createdAt": "2024-01-01T10:00:00Z"
      }
    ],
    "total": 100,
    "page": 1,
    "limit": 20
  }
}
```

#### 3.4.2 管理活跃会话
```typescript
GET /api/auth/sessions
Authorization: Bearer {accessToken}

// 响应体
{
  "code": 200,
  "data": [
    {
      "id": 1,
      "deviceType": "web",
      "deviceInfo": "Chrome 120.0",
      "ipAddress": "192.168.1.1",
      "location": "北京市",
      "lastActivity": "2024-01-01T10:00:00Z",
      "isCurrent": true
    }
  ]
}

// 终止指定会话
DELETE /api/auth/sessions/{sessionId}
Authorization: Bearer {accessToken}
```

## 4. 核心业务逻辑

### 4.1 认证服务 (AuthService)

```typescript
@Injectable()
export class AuthService {
  constructor(
    private userRepository: UserRepository,
    private sessionRepository: SessionRepository,
    private jwtService: JwtService,
    private hashService: HashService,
    private smsService: SmsService,
    private wechatService: WechatService
  ) {}

  /**
   * 用户名密码登录
   */
  async loginWithPassword(loginDto: PasswordLoginDto): Promise<AuthResult> {
    // 1. 验证用户存在性
    const user = await this.userRepository.findByUsername(loginDto.username);
    if (!user) {
      throw new UnauthorizedException('用户名或密码错误');
    }

    // 2. 检查用户状态
    this.validateUserStatus(user);

    // 3. 验证密码
    const isPasswordValid = await this.hashService.verify(
      loginDto.password,
      user.passwordHash,
      user.salt
    );
    if (!isPasswordValid) {
      await this.recordLoginFailure(user, 'invalid_password', loginDto);
      throw new UnauthorizedException('用户名或密码错误');
    }

    // 4. 检查登录限制
    await this.checkLoginRestrictions(user, loginDto);

    // 5. 生成会话
    const session = await this.createSession(user, loginDto);

    // 6. 记录登录成功
    await this.recordLoginSuccess(user, session, loginDto);

    // 7. 更新用户登录信息
    await this.updateUserLoginInfo(user, loginDto);

    return {
      accessToken: session.accessToken,
      refreshToken: session.refreshToken,
      expiresIn: session.expiresIn,
      user: this.formatUserInfo(user)
    };
  }

  /**
   * 短信验证码登录
   */
  async loginWithSms(smsLoginDto: SmsLoginDto): Promise<AuthResult> {
    // 1. 验证短信验证码
    const isCodeValid = await this.smsService.verifyCode(
      smsLoginDto.phone,
      smsLoginDto.smsCode
    );
    if (!isCodeValid) {
      throw new UnauthorizedException('验证码错误或已过期');
    }

    // 2. 查找或创建用户
    let user = await this.userRepository.findByPhone(smsLoginDto.phone);
    if (!user) {
      user = await this.createUserByPhone(smsLoginDto.phone);
    }

    // 3. 检查用户状态
    this.validateUserStatus(user);

    // 4. 生成会话
    const session = await this.createSession(user, smsLoginDto);

    // 5. 记录登录成功
    await this.recordLoginSuccess(user, session, smsLoginDto);

    return {
      accessToken: session.accessToken,
      refreshToken: session.refreshToken,
      expiresIn: session.expiresIn,
      user: this.formatUserInfo(user)
    };
  }

  /**
   * 微信授权登录
   */
  async loginWithWechat(wechatLoginDto: WechatLoginDto): Promise<AuthResult> {
    // 1. 获取微信用户信息
    const wechatUser = await this.wechatService.getUserInfo(
      wechatLoginDto.code,
      wechatLoginDto.platform
    );

    // 2. 查找或创建用户
    let user = await this.findOrCreateWechatUser(wechatUser);

    // 3. 检查用户状态
    this.validateUserStatus(user);

    // 4. 生成会话
    const session = await this.createSession(user, wechatLoginDto);

    // 5. 记录登录成功
    await this.recordLoginSuccess(user, session, wechatLoginDto);

    return {
      accessToken: session.accessToken,
      refreshToken: session.refreshToken,
      expiresIn: session.expiresIn,
      user: this.formatUserInfo(user),
      isNewUser: user.createdAt > new Date(Date.now() - 60000) // 1分钟内创建
    };
  }

  /**
   * 刷新Token
   */
  async refreshToken(refreshToken: string): Promise<TokenResult> {
    // 1. 验证refresh token
    const session = await this.sessionRepository.findByRefreshToken(refreshToken);
    if (!session || !session.isActive || session.expiresAt < new Date()) {
      throw new UnauthorizedException('无效的刷新令牌');
    }

    // 2. 获取用户信息
    const user = await this.userRepository.findById(session.userId);
    if (!user) {
      throw new UnauthorizedException('用户不存在');
    }

    // 3. 检查用户状态
    this.validateUserStatus(user);

    // 4. 生成新的token
    const newTokens = await this.generateTokens(user, session);

    // 5. 更新会话
    await this.sessionRepository.update(session.id, {
      sessionToken: newTokens.accessToken,
      refreshToken: newTokens.refreshToken,
      expiresAt: newTokens.expiresAt,
      lastActivityAt: new Date()
    });

    return {
      accessToken: newTokens.accessToken,
      refreshToken: newTokens.refreshToken,
      expiresIn: newTokens.expiresIn
    };
  }

  /**
   * 退出登录
   */
  async logout(sessionToken: string): Promise<void> {
    const session = await this.sessionRepository.findByToken(sessionToken);
    if (session) {
      await this.sessionRepository.deactivate(session.id);
    }
  }

  /**
   * 验证用户状态
   */
  private validateUserStatus(user: User): void {
    if (user.status === 'inactive') {
      throw new UnauthorizedException('账户已被禁用');
    }
    if (user.status === 'locked') {
      throw new UnauthorizedException('账户已被锁定');
    }
    if (user.status === 'deleted') {
      throw new UnauthorizedException('账户不存在');
    }
  }

  /**
   * 创建会话
   */
  private async createSession(user: User, loginDto: any): Promise<SessionInfo> {
    const tokens = await this.generateTokens(user);
    
    const session = await this.sessionRepository.create({
      userId: user.id,
      sessionToken: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      deviceType: loginDto.deviceType,
      deviceId: loginDto.deviceId,
      deviceInfo: this.parseDeviceInfo(loginDto.userAgent),
      ipAddress: loginDto.ipAddress,
      userAgent: loginDto.userAgent,
      expiresAt: tokens.expiresAt
    });

    return {
      ...tokens,
      sessionId: session.id
    };
  }

  /**
   * 生成JWT Token
   */
  private async generateTokens(user: User, existingSession?: Session): Promise<TokenInfo> {
    const payload = {
      sub: user.id,
      username: user.username,
      roleType: user.roleType,
      cityId: user.cityId,
      storeId: user.storeId
    };

    const accessToken = await this.jwtService.signAsync(payload, {
      expiresIn: '2h'
    });

    const refreshToken = await this.jwtService.signAsync(
      { sub: user.id, type: 'refresh' },
      { expiresIn: '7d' }
    );

    return {
      accessToken,
      refreshToken,
      expiresIn: 7200,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
    };
  }
}
```

### 4.2 密码服务 (PasswordService)

```typescript
@Injectable()
export class PasswordService {
  constructor(
    private userRepository: UserRepository,
    private hashService: HashService,
    private emailService: EmailService,
    private smsService: SmsService,
    private redisService: RedisService
  ) {}

  /**
   * 修改密码
   */
  async changePassword(
    userId: number,
    changePasswordDto: ChangePasswordDto
  ): Promise<void> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundException('用户不存在');
    }

    // 验证旧密码
    const isOldPasswordValid = await this.hashService.verify(
      changePasswordDto.oldPassword,
      user.passwordHash,
      user.salt
    );
    if (!isOldPasswordValid) {
      throw new UnauthorizedException('原密码错误');
    }

    // 验证新密码强度
    this.validatePasswordStrength(changePasswordDto.newPassword);

    // 生成新密码哈希
    const salt = this.hashService.generateSalt();
    const passwordHash = await this.hashService.hash(
      changePasswordDto.newPassword,
      salt
    );

    // 更新密码
    await this.userRepository.update(userId, {
      passwordHash,
      salt,
      passwordChangedAt: new Date()
    });

    // 使所有会话失效（除当前会话外）
    await this.sessionRepository.deactivateUserSessions(userId, {
      excludeCurrentSession: true
    });
  }

  /**
   * 忘记密码
   */
  async forgotPassword(forgotPasswordDto: ForgotPasswordDto): Promise<void> {
    const user = await this.userRepository.findByContact(
      forgotPasswordDto.contact
    );
    if (!user) {
      // 为了安全，不暴露用户是否存在
      return;
    }

    // 生成重置令牌
    const resetToken = this.generateResetToken();
    const expiresAt = new Date(Date.now() + 30 * 60 * 1000); // 30分钟

    // 保存重置记录
    await this.passwordResetRepository.create({
      userId: user.id,
      resetToken,
      resetType: forgotPasswordDto.type,
      contactInfo: forgotPasswordDto.contact,
      expiresAt
    });

    // 发送重置链接
    if (forgotPasswordDto.type === 'email') {
      await this.emailService.sendPasswordResetEmail(
        user.email,
        resetToken
      );
    } else {
      await this.smsService.sendPasswordResetSms(
        user.phone,
        resetToken
      );
    }
  }

  /**
   * 重置密码
   */
  async resetPassword(resetPasswordDto: ResetPasswordDto): Promise<void> {
    // 验证重置令牌
    const resetRecord = await this.passwordResetRepository.findByToken(
      resetPasswordDto.resetToken
    );
    if (!resetRecord || resetRecord.usedAt || resetRecord.expiresAt < new Date()) {
      throw new UnauthorizedException('重置令牌无效或已过期');
    }

    // 验证新密码强度
    this.validatePasswordStrength(resetPasswordDto.newPassword);

    // 生成新密码哈希
    const salt = this.hashService.generateSalt();
    const passwordHash = await this.hashService.hash(
      resetPasswordDto.newPassword,
      salt
    );

    // 更新密码
    await this.userRepository.update(resetRecord.userId, {
      passwordHash,
      salt,
      passwordChangedAt: new Date()
    });

    // 标记重置令牌已使用
    await this.passwordResetRepository.markAsUsed(resetRecord.id);

    // 使所有会话失效
    await this.sessionRepository.deactivateUserSessions(resetRecord.userId);
  }

  /**
   * 验证密码强度
   */
  private validatePasswordStrength(password: string): void {
    const minLength = 8;
    const hasUpperCase = /[A-Z]/.test(password);
    const hasLowerCase = /[a-z]/.test(password);
    const hasNumbers = /\d/.test(password);
    const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);

    if (password.length < minLength) {
      throw new BadRequestException('密码长度至少8位');
    }

    const strengthScore = [hasUpperCase, hasLowerCase, hasNumbers, hasSpecialChar]
      .filter(Boolean).length;

    if (strengthScore < 3) {
      throw new BadRequestException(
        '密码强度不足，需包含大小写字母、数字、特殊字符中的至少3种'
      );
    }
  }
}
```

## 5. 前端界面设计

### 5.1 Web端登录界面

#### 5.1.1 登录页面组件
```typescript
// components/auth/LoginForm.tsx
import React, { useState } from 'react';
import { Form, Input, Button, Tabs, message } from 'antd';
import { UserOutlined, LockOutlined, MobileOutlined } from '@ant-design/icons';

const LoginForm: React.FC = () => {
  const [activeTab, setActiveTab] = useState('password');
  const [loading, setLoading] = useState(false);

  const handlePasswordLogin = async (values: any) => {
    setLoading(true);
    try {
      const result = await authService.loginWithPassword(values);
      message.success('登录成功');
      // 跳转到首页
    } catch (error) {
      message.error(error.message);
    } finally {
      setLoading(false);
    }
  };

  const handleSmsLogin = async (values: any) => {
    setLoading(true);
    try {
      const result = await authService.loginWithSms(values);
      message.success('登录成功');
    } catch (error) {
      message.error(error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="login-container">
      <div className="login-form">
        <div className="login-header">
          <h1>罗莱L2C销售管理系统</h1>
          <p>欢迎登录</p>
        </div>

        <Tabs activeKey={activeTab} onChange={setActiveTab}>
          <Tabs.TabPane tab="密码登录" key="password">
            <Form onFinish={handlePasswordLogin}>
              <Form.Item
                name="username"
                rules={[{ required: true, message: '请输入用户名' }]}
              >
                <Input
                  prefix={<UserOutlined />}
                  placeholder="用户名/邮箱/手机号"
                  size="large"
                />
              </Form.Item>
              
              <Form.Item
                name="password"
                rules={[{ required: true, message: '请输入密码' }]}
              >
                <Input.Password
                  prefix={<LockOutlined />}
                  placeholder="密码"
                  size="large"
                />
              </Form.Item>

              <Form.Item>
                <Button
                  type="primary"
                  htmlType="submit"
                  loading={loading}
                  size="large"
                  block
                >
                  登录
                </Button>
              </Form.Item>
            </Form>
          </Tabs.TabPane>

          <Tabs.TabPane tab="短信登录" key="sms">
            <SmsLoginForm onSubmit={handleSmsLogin} loading={loading} />
          </Tabs.TabPane>
        </Tabs>

        <div className="login-footer">
          <a href="/forgot-password">忘记密码？</a>
        </div>
      </div>
    </div>
  );
};
```

#### 5.1.2 短信登录组件
```typescript
// components/auth/SmsLoginForm.tsx
const SmsLoginForm: React.FC<Props> = ({ onSubmit, loading }) => {
  const [countdown, setCountdown] = useState(0);

  const sendSmsCode = async (phone: string) => {
    try {
      await authService.sendSmsCode(phone);
      message.success('验证码已发送');
      setCountdown(60);
    } catch (error) {
      message.error(error.message);
    }
  };

  return (
    <Form onFinish={onSubmit}>
      <Form.Item
        name="phone"
        rules={[
          { required: true, message: '请输入手机号' },
          { pattern: /^1[3-9]\d{9}$/, message: '手机号格式不正确' }
        ]}
      >
        <Input
          prefix={<MobileOutlined />}
          placeholder="手机号"
          size="large"
        />
      </Form.Item>

      <Form.Item>
        <Input.Group compact>
          <Form.Item
            name="smsCode"
            noStyle
            rules={[{ required: true, message: '请输入验证码' }]}
          >
            <Input
              style={{ width: '60%' }}
              placeholder="验证码"
              size="large"
            />
          </Form.Item>
          <Button
            style={{ width: '40%' }}
            size="large"
            disabled={countdown > 0}
            onClick={() => {
              const phone = form.getFieldValue('phone');
              if (phone) sendSmsCode(phone);
            }}
          >
            {countdown > 0 ? `${countdown}s` : '获取验证码'}
          </Button>
        </Input.Group>
      </Form.Item>

      <Form.Item>
        <Button
          type="primary"
          htmlType="submit"
          loading={loading}
          size="large"
          block
        >
          登录
        </Button>
      </Form.Item>
    </Form>
  );
};
```

### 5.2 移动端登录界面

#### 5.2.1 移动端登录页面
```typescript
// pages/auth/login.tsx (Taro)
import { View, Button, Input } from '@tarojs/components';
import { useState } from 'react';
import Taro from '@tarojs/taro';

const LoginPage = () => {
  const [loginType, setLoginType] = useState('password');
  const [formData, setFormData] = useState({
    username: '',
    password: '',
    phone: '',
    smsCode: ''
  });

  const handleLogin = async () => {
    try {
      let result;
      if (loginType === 'password') {
        result = await authService.loginWithPassword({
          username: formData.username,
          password: formData.password,
          deviceType: 'mobile'
        });
      } else {
        result = await authService.loginWithSms({
          phone: formData.phone,
          smsCode: formData.smsCode,
          deviceType: 'mobile'
        });
      }

      Taro.setStorageSync('accessToken', result.accessToken);
      Taro.setStorageSync('userInfo', result.user);
      
      Taro.showToast({ title: '登录成功', icon: 'success' });
      Taro.redirectTo({ url: '/pages/index/index' });
    } catch (error) {
      Taro.showToast({ title: error.message, icon: 'error' });
    }
  };

  const handleWechatLogin = async () => {
    try {
      const { code } = await Taro.login();
      const result = await authService.loginWithWechat({
        code,
        platform: 'miniprogram',
        deviceType: 'mobile'
      });

      Taro.setStorageSync('accessToken', result.accessToken);
      Taro.setStorageSync('userInfo', result.user);
      
      Taro.showToast({ title: '登录成功', icon: 'success' });
      Taro.redirectTo({ url: '/pages/index/index' });
    } catch (error) {
      Taro.showToast({ title: error.message, icon: 'error' });
    }
  };

  return (
    <View className="login-page">
      <View className="login-header">
        <View className="logo">罗莱L2C</View>
        <View className="title">销售管理系统</View>
      </View>

      <View className="login-form">
        {loginType === 'password' ? (
          <View>
            <Input
              placeholder="用户名/手机号"
              value={formData.username}
              onInput={(e) => setFormData({...formData, username: e.detail.value})}
            />
            <Input
              placeholder="密码"
              password
              value={formData.password}
              onInput={(e) => setFormData({...formData, password: e.detail.value})}
            />
          </View>
        ) : (
          <View>
            <Input
              placeholder="手机号"
              value={formData.phone}
              onInput={(e) => setFormData({...formData, phone: e.detail.value})}
            />
            <View className="sms-input">
              <Input
                placeholder="验证码"
                value={formData.smsCode}
                onInput={(e) => setFormData({...formData, smsCode: e.detail.value})}
              />
              <Button size="mini" onClick={sendSmsCode}>获取验证码</Button>
            </View>
          </View>
        )}

        <Button type="primary" onClick={handleLogin}>
          登录
        </Button>

        <Button onClick={handleWechatLogin}>
          微信快速登录
        </Button>

        <View className="login-switch">
          <Button
            size="mini"
            onClick={() => setLoginType(loginType === 'password' ? 'sms' : 'password')}
          >
            {loginType === 'password' ? '短信登录' : '密码登录'}
          </Button>
        </View>
      </View>
    </View>
  );
};
```

## 6. 安全和权限控制

### 6.1 安全策略

#### 6.1.1 密码安全
- **密码强度要求**：至少8位，包含大小写字母、数字、特殊字符中的3种
- **密码哈希**：使用bcrypt + salt进行密码哈希存储
- **密码历史**：防止重复使用最近5次密码
- **密码过期**：强制定期更换密码（可配置）

#### 6.1.2 会话安全
- **JWT Token**：使用RS256算法签名
- **Token过期**：访问令牌2小时，刷新令牌7天
- **会话绑定**：Token与设备、IP绑定
- **并发控制**：限制同一用户的并发会话数

#### 6.1.3 登录安全
- **登录限制**：连续失败5次后锁定账户30分钟
- **验证码**：失败3次后要求验证码
- **设备识别**：记录和识别登录设备
- **异地登录**：异地登录时发送安全通知

### 6.2 权限控制

#### 6.2.1 角色权限矩阵
```typescript
const ROLE_PERMISSIONS = {
  'super_admin': ['*'], // 所有权限
  'region_manager': [
    'user:read', 'user:create', 'user:update',
    'store:read', 'store:create', 'store:update',
    'lead:read', 'lead:create', 'lead:update', 'lead:delete',
    'order:read', 'order:create', 'order:update',
    'report:read', 'report:export'
  ],
  'store_manager': [
    'user:read', 'user:update',
    'lead:read', 'lead:create', 'lead:update', 'lead:assign',
    'order:read', 'order:create', 'order:update',
    'product:read',
    'report:read'
  ],
  'sales_consultant': [
    'lead:read', 'lead:create', 'lead:update',
    'order:read', 'order:create', 'order:update',
    'customer:read', 'customer:create', 'customer:update',
    'product:read',
    'points:read'
  ],
  'designer': [
    'measurement:read', 'measurement:update',
    'order:read',
    'customer:read',
    'product:read',
    'points:read'
  ],
  'guide': [
    'lead:read', 'lead:create',
    'customer:read', 'customer:create',
    'product:read',
    'points:read'
  ],
  'measurer': [
    'measurement:read', 'measurement:update',
    'schedule:read', 'schedule:update',
    'points:read'
  ],
  'installer': [
    'installation:read', 'installation:update',
    'schedule:read', 'schedule:update',
    'points:read'
  ]
};
```

#### 6.2.2 数据权限控制
```typescript
@Injectable()
export class DataPermissionService {
  /**
   * 获取用户数据权限范围
   */
  getDataScope(user: User): DataScope {
    switch (user.roleType) {
      case 'super_admin':
        return { type: 'all' };
      
      case 'region_manager':
        return { 
          type: 'region',
          cityIds: user.managedCityIds 
        };
      
      case 'store_manager':
        return { 
          type: 'store',
          storeIds: [user.storeId] 
        };
      
      case 'sales_consultant':
      case 'designer':
      case 'guide':
        return { 
          type: 'self',
          userId: user.id 
        };
      
      case 'measurer':
      case 'installer':
        return { 
          type: 'assigned',
          userId: user.id 
        };
      
      default:
        return { type: 'none' };
    }
  }

  /**
   * 应用数据权限过滤
   */
  applyDataFilter(query: any, user: User): any {
    const scope = this.getDataScope(user);
    
    switch (scope.type) {
      case 'all':
        return query;
      
      case 'region':
        return query.where('cityId', 'in', scope.cityIds);
      
      case 'store':
        return query.where('storeId', 'in', scope.storeIds);
      
      case 'self':
        return query.where('createdBy', scope.userId);
      
      case 'assigned':
        return query.where('assignedTo', scope.userId);
      
      default:
        return query.where('1', '0'); // 无权限
    }
  }
}
```

## 7. 监控和告警

### 7.1 认证监控指标

#### 7.1.1 登录监控
- **登录成功率**：成功登录次数 / 总登录尝试次数
- **登录失败率**：失败登录次数 / 总登录尝试次数
- **平均登录时间**：从请求到响应的平均时间
- **异常登录检测**：异地、异常时间、异常设备登录

#### 7.1.2 会话监控
- **活跃会话数**：当前活跃的用户会话数量
- **会话时长分布**：用户会话持续时间分布
- **Token刷新频率**：Token刷新的频率和成功率
- **并发用户数**：同时在线的用户数量

#### 7.1.3 安全监控
- **暴力破解检测**：短时间内大量失败登录尝试
- **账户锁定监控**：账户锁定的频率和原因
- **密码重置监控**：密码重置请求的频率
- **权限异常监控**：权限提升、越权访问等异常

### 7.2 告警配置

```typescript
// 监控告警配置
const ALERT_RULES = {
  // 登录失败率过高
  high_login_failure_rate: {
    metric: 'login_failure_rate',
    threshold: 0.1, // 10%
    duration: '5m',
    severity: 'warning'
  },
  
  // 暴力破解攻击
  brute_force_attack: {
    metric: 'failed_login_attempts',
    threshold: 50,
    duration: '1m',
    severity: 'critical'
  },
  
  // 异常登录
  suspicious_login: {
    metric: 'unusual_login_location',
    threshold: 1,
    duration: '1m',
    severity: 'warning'
  },
  
  // 会话异常
  session_anomaly: {
    metric: 'concurrent_sessions_per_user',
    threshold: 5,
    duration: '1m',
    severity: 'warning'
  }
};
```

## 8. 总结

用户认证模块作为L2C销售管理系统的安全基础，提供了完整的身份认证、会话管理、权限控制解决方案。通过多种认证方式、严格的安全策略、细粒度的权限控制，确保系统的安全性和可用性。

**核心特性：**
- 支持多种认证方式（密码、短信、微信、扫码、生物识别）
- 完整的会话生命周期管理
- 基于角色的权限控制（RBAC）
- 数据权限的细粒度控制
- 全面的安全防护机制
- 实时监控和告警

该模块为整个L2C系统的8种用户角色提供了统一、安全、便捷的认证服务，支持Web端、移动端、小程序等多平台接入。
