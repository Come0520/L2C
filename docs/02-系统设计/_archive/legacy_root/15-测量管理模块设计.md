# 测量管理模块设计

## 1. 模块概述

### 1.1 功能目标
测量管理模块负责管理从订单确认到产品生产前的现场测量环节，确保产品尺寸准确性和安装可行性。

**核心目标**：
- **精确测量**：确保现场测量数据的准确性和完整性
- **流程管控**：规范测量预约、执行、确认的完整流程
- **质量保证**：通过多重验证确保测量质量
- **效率提升**：优化测量师傅调度和路线规划
- **数据管理**：建立完整的测量数据档案
- **异常处理**：及时处理测量异常和重测需求

### 1.2 业务流程
```
订单确认 → 测量预约 → 测量师傅分配 → 现场测量 → 数据录入 → 测量确认 → 生产排期
    ↓         ↓         ↓           ↓         ↓         ↓         ↓
  通知客户   安排时间   路线优化    实地操作   质量检查   客户签字   开始生产
```

### 1.3 测量类型
- **标准测量**：常规产品的基础尺寸测量
- **复杂测量**：异形产品或特殊安装环境的详细测量
- **复测**：因数据异常或客户要求的重新测量
- **补测**：遗漏项目的补充测量

## 2. 数据库设计

### 2.1 测量订单表 (measurement_orders)
```sql
CREATE TABLE measurement_orders (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  measurement_no VARCHAR(32) NOT NULL UNIQUE COMMENT '测量单号',
  order_id BIGINT NOT NULL COMMENT '关联销售订单ID',
  order_no VARCHAR(32) NOT NULL COMMENT '销售订单号',
  
  -- 客户信息
  customer_id BIGINT NOT NULL COMMENT '客户ID',
  customer_name VARCHAR(100) NOT NULL COMMENT '客户姓名',
  customer_phone VARCHAR(15) NOT NULL COMMENT '客户电话',
  
  -- 测量地址
  measurement_address TEXT NOT NULL COMMENT '测量地址',
  measurement_contact VARCHAR(100) COMMENT '现场联系人',
  measurement_phone VARCHAR(15) COMMENT '现场联系电话',
  
  -- 测量安排
  measurer_id BIGINT COMMENT '测量师傅ID',
  measurer_name VARCHAR(100) COMMENT '测量师傅姓名',
  measurer_phone VARCHAR(15) COMMENT '测量师傅电话',
  appointment_date DATE COMMENT '预约测量日期',
  appointment_time_slot VARCHAR(20) COMMENT '预约时间段',
  appointment_notes TEXT COMMENT '预约备注',
  
  -- 测量执行
  actual_start_time DATETIME COMMENT '实际开始时间',
  actual_end_time DATETIME COMMENT '实际结束时间',
  measurement_duration INT COMMENT '测量耗时(分钟)',
  
  -- 测量状态
  measurement_status ENUM('pending', 'scheduled', 'in_progress', 'completed', 'cancelled', 'rework') 
    NOT NULL DEFAULT 'pending' COMMENT '测量状态',
  measurement_type ENUM('standard', 'complex', 'remeasure', 'supplement') 
    NOT NULL DEFAULT 'standard' COMMENT '测量类型',
  
  -- 测量结果
  measurement_result TEXT COMMENT '测量结果JSON',
  measurement_photos JSON COMMENT '测量照片',
  measurement_drawings JSON COMMENT '测量图纸',
  quality_rating TINYINT COMMENT '质量评分(1-5)',
  customer_satisfaction TINYINT COMMENT '客户满意度(1-5)',
  
  -- 异常处理
  exception_reason TEXT COMMENT '异常原因',
  rework_reason TEXT COMMENT '重测原因',
  rework_count INT DEFAULT 0 COMMENT '重测次数',
  
  -- 费用信息
  measurement_fee DECIMAL(10,2) DEFAULT 0.00 COMMENT '测量费用',
  additional_fee DECIMAL(10,2) DEFAULT 0.00 COMMENT '额外费用',
  fee_notes TEXT COMMENT '费用说明',
  
  -- 审核信息
  reviewed_by BIGINT COMMENT '审核人ID',
  reviewed_at DATETIME COMMENT '审核时间',
  review_notes TEXT COMMENT '审核备注',
  
  -- 系统字段
  created_by BIGINT NOT NULL COMMENT '创建人ID',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  
  -- 外键约束
  FOREIGN KEY (order_id) REFERENCES sales_orders(id),
  FOREIGN KEY (customer_id) REFERENCES customers(id),
  FOREIGN KEY (measurer_id) REFERENCES measurers(id),
  FOREIGN KEY (reviewed_by) REFERENCES users(id),
  FOREIGN KEY (created_by) REFERENCES users(id),
  
  INDEX idx_order_id (order_id),
  INDEX idx_customer_id (customer_id),
  INDEX idx_measurer_id (measurer_id),
  INDEX idx_appointment_date (appointment_date),
  INDEX idx_measurement_status (measurement_status),
  INDEX idx_created_at (created_at)
) COMMENT='测量订单表';
```

### 2.2 测量项目表 (measurement_items)
```sql
CREATE TABLE measurement_items (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  measurement_id BIGINT NOT NULL COMMENT '测量订单ID',
  order_item_id BIGINT NOT NULL COMMENT '订单商品ID',
  
  -- 商品信息
  product_id BIGINT NOT NULL COMMENT '产品ID',
  product_name VARCHAR(200) NOT NULL COMMENT '产品名称',
  product_sku VARCHAR(100) NOT NULL COMMENT '产品SKU',
  product_category VARCHAR(100) COMMENT '产品分类',
  
  -- 测量要求
  measurement_requirements JSON COMMENT '测量要求',
  measurement_points JSON COMMENT '测量点位',
  special_notes TEXT COMMENT '特殊说明',
  
  -- 测量数据
  measurement_data JSON COMMENT '测量数据',
  calculated_area DECIMAL(10,4) COMMENT '计算面积',
  calculated_volume DECIMAL(10,4) COMMENT '计算体积',
  
  -- 安装环境
  installation_environment JSON COMMENT '安装环境信息',
  environmental_photos JSON COMMENT '环境照片',
  
  -- 状态
  item_status ENUM('pending', 'measuring', 'completed', 'exception') 
    NOT NULL DEFAULT 'pending' COMMENT '项目状态',
  
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  -- 外键约束
  FOREIGN KEY (measurement_id) REFERENCES measurement_orders(id) ON DELETE CASCADE,
  FOREIGN KEY (order_item_id) REFERENCES order_items(id),
  FOREIGN KEY (product_id) REFERENCES products(id),
  
  INDEX idx_measurement_id (measurement_id),
  INDEX idx_order_item_id (order_item_id),
  INDEX idx_product_id (product_id)
) COMMENT='测量项目表';
```

### 2.3 测量师傅表 (measurers)
```sql
CREATE TABLE measurers (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  measurer_no VARCHAR(32) NOT NULL UNIQUE COMMENT '测量师傅编号',
  name VARCHAR(100) NOT NULL COMMENT '姓名',
  phone VARCHAR(15) NOT NULL COMMENT '电话',
  id_card VARCHAR(18) COMMENT '身份证号',
  
  -- 基本信息
  gender ENUM('male', 'female') COMMENT '性别',
  birth_date DATE COMMENT '出生日期',
  address TEXT COMMENT '住址',
  emergency_contact VARCHAR(100) COMMENT '紧急联系人',
  emergency_phone VARCHAR(15) COMMENT '紧急联系电话',
  
  -- 工作信息
  employee_type ENUM('full_time', 'part_time', 'outsource') 
    NOT NULL DEFAULT 'full_time' COMMENT '员工类型',
  work_city VARCHAR(50) COMMENT '工作城市',
  work_areas JSON COMMENT '工作区域',
  skill_level ENUM('junior', 'intermediate', 'senior', 'expert') 
    NOT NULL DEFAULT 'junior' COMMENT '技能等级',
  specialties JSON COMMENT '专业特长',
  
  -- 认证信息
  certifications JSON COMMENT '认证证书',
  training_records JSON COMMENT '培训记录',
  
  -- 工作状态
  work_status ENUM('available', 'busy', 'leave', 'inactive') 
    NOT NULL DEFAULT 'available' COMMENT '工作状态',
  max_daily_orders INT DEFAULT 8 COMMENT '每日最大接单量',
  
  -- 评价信息
  total_orders INT DEFAULT 0 COMMENT '总订单数',
  completed_orders INT DEFAULT 0 COMMENT '完成订单数',
  average_rating DECIMAL(3,2) DEFAULT 0.00 COMMENT '平均评分',
  customer_satisfaction DECIMAL(3,2) DEFAULT 0.00 COMMENT '客户满意度',
  
  -- 系统字段
  status ENUM('active', 'inactive') NOT NULL DEFAULT 'active' COMMENT '状态',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  INDEX idx_phone (phone),
  INDEX idx_work_city (work_city),
  INDEX idx_work_status (work_status),
  INDEX idx_skill_level (skill_level)
) COMMENT='测量师傅表';
```

### 2.4 测量模板表 (measurement_templates)
```sql
CREATE TABLE measurement_templates (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  template_name VARCHAR(200) NOT NULL COMMENT '模板名称',
  product_category VARCHAR(100) NOT NULL COMMENT '适用产品分类',
  
  -- 模板内容
  measurement_points JSON NOT NULL COMMENT '测量点位定义',
  measurement_rules JSON COMMENT '测量规则',
  calculation_formulas JSON COMMENT '计算公式',
  quality_standards JSON COMMENT '质量标准',
  
  -- 模板状态
  template_status ENUM('active', 'inactive') NOT NULL DEFAULT 'active',
  version VARCHAR(20) NOT NULL DEFAULT '1.0' COMMENT '版本号',
  
  created_by BIGINT NOT NULL,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  -- 外键约束
  FOREIGN KEY (created_by) REFERENCES users(id),
  
  INDEX idx_product_category (product_category),
  INDEX idx_template_status (template_status)
) COMMENT='测量模板表';
```

### 2.5 测量日志表 (measurement_logs)
```sql
CREATE TABLE measurement_logs (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  measurement_id BIGINT NOT NULL COMMENT '测量订单ID',
  
  -- 日志信息
  log_type ENUM('status_change', 'data_update', 'exception', 'note') 
    NOT NULL COMMENT '日志类型',
  from_status VARCHAR(50) COMMENT '原状态',
  to_status VARCHAR(50) COMMENT '新状态',
  operation VARCHAR(100) NOT NULL COMMENT '操作',
  description TEXT COMMENT '描述',
  
  -- 操作人信息
  operator_id BIGINT NOT NULL COMMENT '操作人ID',
  operator_name VARCHAR(100) NOT NULL COMMENT '操作人姓名',
  operator_role VARCHAR(50) COMMENT '操作人角色',
  
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  
  -- 外键约束
  FOREIGN KEY (measurement_id) REFERENCES measurement_orders(id) ON DELETE CASCADE,
  FOREIGN KEY (operator_id) REFERENCES users(id),
  
  INDEX idx_measurement_id (measurement_id),
  INDEX idx_log_type (log_type),
  INDEX idx_created_at (created_at)
) COMMENT='测量日志表';
```

### 2.6 外键约束说明

#### 2.6.1 外键约束的作用
- **数据完整性**：确保引用的数据存在，防止无效的关联关系
- **引用完整性**：维护表之间的关联关系，确保数据的一致性
- **业务逻辑保障**：通过数据库层面的约束确保业务规则的执行

#### 2.6.2 主要外键约束关系

| 表名 | 字段名 | 引用表 | 引用字段 | 说明 |
|------|--------|--------|----------|------|
| measurement_orders | order_id | sales_orders | id | 关联的销售订单 |
| measurement_orders | customer_id | customers | id | 测量订单关联的客户 |
| measurement_orders | measurer_id | measurers | id | 分配的测量师傅 |
| measurement_orders | reviewed_by | users | id | 审核人 |
| measurement_orders | created_by | users | id | 创建人 |
| measurement_items | measurement_id | measurement_orders | id | 所属测量订单 |
| measurement_items | order_item_id | order_items | id | 关联的订单项 |
| measurement_items | product_id | products | id | 测量的产品 |
| measurement_templates | created_by | users | id | 模板创建人 |
| measurement_logs | measurement_id | measurement_orders | id | 关联的测量订单 |
| measurement_logs | operator_id | users | id | 操作人 |

#### 2.6.3 外键约束的好处
1. **防止数据不一致**：避免插入不存在的关联数据
2. **提高数据质量**：确保所有关联关系都是有效的
3. **简化查询逻辑**：可以安全地进行表连接操作
4. **支持级联操作**：可以配置级联删除或更新操作

## 3. API接口设计

### 3.1 测量订单管理

#### 3.1.1 创建测量订单
```typescript
POST /api/measurements
Content-Type: application/json

{
  "orderId": 12345,
  "measurementType": "standard",
  "appointmentDate": "2024-01-15",
  "appointmentTimeSlot": "09:00-12:00",
  "measurementAddress": "北京市朝阳区xxx小区xxx号楼xxx室",
  "measurementContact": "张先生",
  "measurementPhone": "13800138000",
  "appointmentNotes": "客户要求上午测量",
  "specialRequirements": ["需要测量阳台", "注意保护地板"]
}

Response:
{
  "code": 200,
  "message": "success",
  "data": {
    "id": 67890,
    "measurementNo": "M202401150001",
    "status": "pending",
    "createdAt": "2024-01-10T10:00:00Z"
  }
}
```

#### 3.1.2 获取测量订单列表
```typescript
GET /api/measurements?page=1&page_size=20&status=pending&measurer_id=123&start_date=2024-01-01&end_date=2024-01-31

Response:
{
  "code": 200,
  "message": "success",
  "data": {
    "list": [
      {
        "id": 67890,
        "measurementNo": "M202401150001",
        "orderNo": "SO202401100001",
        "customerName": "张三",
        "customerPhone": "13800138000",
        "measurementAddress": "北京市朝阳区xxx小区",
        "appointmentDate": "2024-01-15",
        "appointmentTimeSlot": "09:00-12:00",
        "measurerName": "李师傅",
        "measurementStatus": "scheduled",
        "measurementType": "standard",
        "createdAt": "2024-01-10T10:00:00Z"
      }
    ],
    "pagination": {
      "page": 1,
      "pageSize": 20,
      "total": 100,
      "totalPages": 5
    }
  }
}
```

#### 3.1.3 获取测量订单详情
```typescript
GET /api/measurements/{id}

Response:
{
  "code": 200,
  "message": "success",
  "data": {
    "id": 67890,
    "measurementNo": "M202401150001",
    "orderId": 12345,
    "orderNo": "SO202401100001",
    "customerInfo": {
      "customerId": 123,
      "customerName": "张三",
      "customerPhone": "13800138000"
    },
    "measurementAddress": "北京市朝阳区xxx小区xxx号楼xxx室",
    "measurementContact": "张先生",
    "measurementPhone": "13800138000",
    "measurer": {
      "measurerId": 456,
      "measurerName": "李师傅",
      "measurerPhone": "13900139000"
    },
    "appointmentDate": "2024-01-15",
    "appointmentTimeSlot": "09:00-12:00",
    "actualStartTime": "2024-01-15T09:15:00Z",
    "actualEndTime": "2024-01-15T11:30:00Z",
    "measurementStatus": "completed",
    "measurementType": "standard",
    "measurementResult": {
      "totalArea": 85.5,
      "rooms": [
        {
          "roomName": "客厅",
          "area": 35.2,
          "measurements": {
            "length": 5.2,
            "width": 6.8,
            "height": 2.8
          }
        }
      ]
    },
    "measurementPhotos": [
      "https://example.com/photo1.jpg",
      "https://example.com/photo2.jpg"
    ],
    "qualityRating": 5,
    "customerSatisfaction": 5,
    "measurementFee": 100.00,
    "items": [
      {
        "id": 1,
        "productName": "定制衣柜",
        "productSku": "YG001",
        "measurementData": {
          "width": 2.4,
          "height": 2.8,
          "depth": 0.6
        },
        "calculatedArea": 6.72,
        "itemStatus": "completed"
      }
    ]
  }
}
```

### 3.2 测量师傅管理

#### 3.2.1 分配测量师傅
```typescript
POST /api/measurements/{id}/assign
Content-Type: application/json

{
  "measurerId": 456,
  "appointmentDate": "2024-01-15",
  "appointmentTimeSlot": "09:00-12:00",
  "notes": "客户要求准时到达"
}

Response:
{
  "code": 200,
  "message": "测量师傅分配成功",
  "data": {
    "measurementId": 67890,
    "measurerInfo": {
      "measurerId": 456,
      "measurerName": "李师傅",
      "measurerPhone": "13900139000"
    },
    "appointmentInfo": {
      "appointmentDate": "2024-01-15",
      "appointmentTimeSlot": "09:00-12:00"
    }
  }
}
```

#### 3.2.2 获取可用测量师傅
```typescript
GET /api/measurers/available?date=2024-01-15&time_slot=09:00-12:00&city=北京&skill_level=intermediate

Response:
{
  "code": 200,
  "message": "success",
  "data": [
    {
      "measurerId": 456,
      "measurerName": "李师傅",
      "measurerPhone": "13900139000",
      "skillLevel": "senior",
      "averageRating": 4.8,
      "completedOrders": 156,
      "workAreas": ["朝阳区", "海淀区"],
      "specialties": ["复杂测量", "异形产品"],
      "estimatedTravelTime": 30
    }
  ]
}
```

### 3.3 测量执行

#### 3.3.1 开始测量
```typescript
POST /api/measurements/{id}/start
Content-Type: application/json

{
  "actualStartTime": "2024-01-15T09:15:00Z",
  "environmentNotes": "现场环境良好，光线充足"
}

Response:
{
  "code": 200,
  "message": "测量已开始",
  "data": {
    "measurementId": 67890,
    "status": "in_progress",
    "actualStartTime": "2024-01-15T09:15:00Z"
  }
}
```

#### 3.3.2 提交测量数据
```typescript
POST /api/measurements/{id}/submit_data
Content-Type: application/json

{
  "measurementData": {
    "totalArea": 85.5,
    "rooms": [
      {
        "roomName": "客厅",
        "area": 35.2,
        "measurements": {
          "length": 5.2,
          "width": 6.8,
          "height": 2.8
        },
        "photos": ["photo1.jpg", "photo2.jpg"]
      }
    ]
  },
  "items": [
    {
      "orderItemId": 1,
      "measurementData": {
        "width": 2.4,
        "height": 2.8,
        "depth": 0.6
      },
      "installationEnvironment": {
        "wallType": "承重墙",
        "powerOutlet": true,
        "obstacles": []
      }
    }
  ],
  "measurementPhotos": ["photo1.jpg", "photo2.jpg", "photo3.jpg"],
  "notes": "测量完成，数据准确"
}

Response:
{
  "code": 200,
  "message": "测量数据提交成功",
  "data": {
    "measurementId": 67890,
    "status": "data_submitted",
    "submittedAt": "2024-01-15T11:30:00Z"
  }
}
```

#### 3.3.3 完成测量
```typescript
POST /api/measurements/{id}/complete
Content-Type: application/json

{
  "actualEndTime": "2024-01-15T11:30:00Z",
  "qualityRating": 5,
  "customerSatisfaction": 5,
  "completionNotes": "测量顺利完成，客户满意",
  "additionalFee": 0,
  "customerSignature": "signature_image_base64"
}

Response:
{
  "code": 200,
  "message": "测量完成",
  "data": {
    "measurementId": 67890,
    "status": "completed",
    "completedAt": "2024-01-15T11:30:00Z",
    "nextStep": "production_scheduling"
  }
}
```

## 4. 核心业务逻辑

### 4.1 测量服务 (MeasurementService)

```typescript
@Injectable()
export class MeasurementService {
  constructor(
    private measurementRepository: MeasurementRepository,
    private measurerRepository: MeasurerRepository,
    private orderRepository: OrderRepository,
    private notificationService: NotificationService,
    private schedulingService: SchedulingService
  ) {}

  /**
   * 创建测量订单
   */
  async createMeasurement(
    createDto: CreateMeasurementDto,
    userId: number
  ): Promise<Measurement> {
    // 1. 验证销售订单状态
    const order = await this.validateOrderForMeasurement(createDto.orderId);

    // 2. 生成测量单号
    const measurementNo = await this.generateMeasurementNo();

    // 3. 创建测量订单
    const measurement = await this.measurementRepository.create({
      measurementNo,
      orderId: createDto.orderId,
      orderNo: order.orderNo,
      customerId: order.customerId,
      customerName: order.customerName,
      customerPhone: order.customerPhone,
      measurementAddress: createDto.measurementAddress,
      measurementContact: createDto.measurementContact,
      measurementPhone: createDto.measurementPhone,
      appointmentDate: createDto.appointmentDate,
      appointmentTimeSlot: createDto.appointmentTimeSlot,
      appointmentNotes: createDto.appointmentNotes,
      measurementType: createDto.measurementType,
      measurementStatus: 'pending',
      createdBy: userId
    });

    // 4. 创建测量项目
    await this.createMeasurementItems(measurement.id, order.items);

    // 5. 更新订单状态
    await this.orderRepository.update(createDto.orderId, {
      measurementStatus: 'scheduled',
      measurementId: measurement.id
    });

    // 6. 发送通知
    await this.notificationService.sendMeasurementCreatedNotification(
      measurement
    );

    return measurement;
  }

  /**
   * 自动分配测量师傅
   */
  async autoAssignMeasurer(
    measurementId: number,
    criteria: AssignmentCriteria
  ): Promise<void> {
    const measurement = await this.measurementRepository.findById(measurementId);
    if (!measurement) {
      throw new NotFoundException('测量订单不存在');
    }

    // 1. 获取可用测量师傅
    const availableMeasurers = await this.getAvailableMeasurers(
      criteria.date,
      criteria.timeSlot,
      criteria.city,
      criteria.skillLevel
    );

    if (availableMeasurers.length === 0) {
      throw new BadRequestException('暂无可用测量师傅');
    }

    // 2. 智能分配算法
    const selectedMeasurer = await this.selectOptimalMeasurer(
      availableMeasurers,
      measurement
    );

    // 3. 分配测量师傅
    await this.assignMeasurer(measurementId, selectedMeasurer.id, criteria);
  }

  /**
   * 智能选择最优测量师傅
   */
  private async selectOptimalMeasurer(
    availableMeasurers: Measurer[],
    measurement: Measurement
  ): Promise<Measurer> {
    // 评分算法：综合考虑距离、技能、评分、工作量
    const scoredMeasurers = await Promise.all(
      availableMeasurers.map(async (measurer) => {
        const score = await this.calculateMeasurerScore(measurer, measurement);
        return { measurer, score };
      })
    );

    // 按评分排序，选择最高分
    scoredMeasurers.sort((a, b) => b.score - a.score);
    return scoredMeasurers[0].measurer;
  }

  /**
   * 计算测量师傅评分
   */
  private async calculateMeasurerScore(
    measurer: Measurer,
    measurement: Measurement
  ): Promise<number> {
    let score = 0;

    // 1. 技能匹配度 (30%)
    const skillScore = this.calculateSkillScore(measurer, measurement);
    score += skillScore * 0.3;

    // 2. 历史评分 (25%)
    const ratingScore = measurer.averageRating * 20; // 5分制转100分制
    score += ratingScore * 0.25;

    // 3. 距离因素 (20%)
    const distanceScore = await this.calculateDistanceScore(measurer, measurement);
    score += distanceScore * 0.2;

    // 4. 工作负载 (15%)
    const workloadScore = await this.calculateWorkloadScore(measurer);
    score += workloadScore * 0.15;

    // 5. 客户满意度 (10%)
    const satisfactionScore = measurer.customerSatisfaction * 20;
    score += satisfactionScore * 0.1;

    return score;
  }

  /**
   * 开始测量
   */
  async startMeasurement(
    measurementId: number,
    startDto: StartMeasurementDto,
    userId: number
  ): Promise<void> {
    const measurement = await this.measurementRepository.findById(measurementId);
    if (!measurement) {
      throw new NotFoundException('测量订单不存在');
    }

    if (measurement.measurementStatus !== 'scheduled') {
      throw new BadRequestException('测量订单状态不正确');
    }

    // 更新测量状态
    await this.measurementRepository.update(measurementId, {
      measurementStatus: 'in_progress',
      actualStartTime: startDto.actualStartTime || new Date()
    });

    // 记录日志
    await this.logMeasurementOperation(
      measurementId,
      'status_change',
      'scheduled',
      'in_progress',
      '开始测量',
      userId
    );

    // 发送通知
    await this.notificationService.sendMeasurementStartNotification(
      measurement
    );
  }

  /**
   * 提交测量数据
   */
  async submitMeasurementData(
    measurementId: number,
    dataDto: SubmitMeasurementDataDto,
    userId: number
  ): Promise<void> {
    const measurement = await this.measurementRepository.findById(measurementId);
    if (!measurement) {
      throw new NotFoundException('测量订单不存在');
    }

    // 1. 验证测量数据
    await this.validateMeasurementData(dataDto);

    // 2. 更新测量结果
    await this.measurementRepository.update(measurementId, {
      measurementResult: dataDto.measurementData,
      measurementPhotos: dataDto.measurementPhotos
    });

    // 3. 更新测量项目数据
    await this.updateMeasurementItems(measurementId, dataDto.items);

    // 4. 质量检查
    const qualityCheck = await this.performQualityCheck(dataDto);
    if (!qualityCheck.passed) {
      await this.handleQualityIssues(measurementId, qualityCheck.issues);
      return;
    }

    // 5. 记录日志
    await this.logMeasurementOperation(
      measurementId,
      'data_update',
      null,
      null,
      '提交测量数据',
      userId
    );
  }

  /**
   * 完成测量
   */
  async completeMeasurement(
    measurementId: number,
    completeDto: CompleteMeasurementDto,
    userId: number
  ): Promise<void> {
    const measurement = await this.measurementRepository.findById(measurementId);
    if (!measurement) {
      throw new NotFoundException('测量订单不存在');
    }

    // 1. 最终质量检查
    const finalCheck = await this.performFinalQualityCheck(measurementId);
    if (!finalCheck.passed) {
      throw new BadRequestException('测量数据质量检查未通过');
    }

    // 2. 更新测量状态
    await this.measurementRepository.update(measurementId, {
      measurementStatus: 'completed',
      actualEndTime: completeDto.actualEndTime || new Date(),
      qualityRating: completeDto.qualityRating,
      customerSatisfaction: completeDto.customerSatisfaction,
      additionalFee: completeDto.additionalFee || 0,
      reviewedBy: userId,
      reviewedAt: new Date()
    });

    // 3. 更新订单状态
    await this.orderRepository.update(measurement.orderId, {
      measurementStatus: 'completed',
      status: 'production_ready'
    });

    // 4. 触发生产排期
    await this.schedulingService.scheduleProduction(measurement.orderId);

    // 5. 更新测量师傅统计
    await this.updateMeasurerStats(measurement.measurerId, completeDto);

    // 6. 发送完成通知
    await this.notificationService.sendMeasurementCompleteNotification(
      measurement
    );
  }

  /**
   * 质量检查
   */
  private async performQualityCheck(
    dataDto: SubmitMeasurementDataDto
  ): Promise<QualityCheckResult> {
    const issues: string[] = [];

    // 1. 数据完整性检查
    if (!dataDto.measurementData || !dataDto.measurementPhotos) {
      issues.push('测量数据或照片缺失');
    }

    // 2. 数据合理性检查
    const reasonabilityCheck = await this.checkDataReasonability(dataDto);
    if (!reasonabilityCheck.passed) {
      issues.push(...reasonabilityCheck.issues);
    }

    // 3. 照片质量检查
    const photoCheck = await this.checkPhotoQuality(dataDto.measurementPhotos);
    if (!photoCheck.passed) {
      issues.push(...photoCheck.issues);
    }

    return {
      passed: issues.length === 0,
      issues
    };
  }

  /**
   * 生成测量单号
   */
  private async generateMeasurementNo(): Promise<string> {
    const today = new Date();
    const dateStr = today.toISOString().slice(0, 10).replace(/-/g, '');
    
    const count = await this.measurementRepository.countByDate(today);
    const sequence = (count + 1).toString().padStart(4, '0');
    
    return `M${dateStr}${sequence}`;
  }
}
```

### 4.2 测量师傅调度服务 (MeasurerSchedulingService)

```typescript
@Injectable()
export class MeasurerSchedulingService {
  constructor(
    private measurerRepository: MeasurerRepository,
    private measurementRepository: MeasurementRepository,
    private geoService: GeoService
  ) {}

  /**
   * 获取可用测量师傅
   */
  async getAvailableMeasurers(
    date: Date,
    timeSlot: string,
    city: string,
    skillLevel?: string
  ): Promise<Measurer[]> {
    // 1. 基础筛选条件
    const baseConditions = {
      workStatus: 'available',
      workCity: city,
      status: 'active'
    };

    if (skillLevel) {
      baseConditions['skillLevel'] = skillLevel;
    }

    // 2. 获取符合条件的测量师傅
    const measurers = await this.measurerRepository.findByConditions(baseConditions);

    // 3. 检查时间可用性
    const availableMeasurers = await Promise.all(
      measurers.map(async (measurer) => {
        const isAvailable = await this.checkTimeAvailability(
          measurer.id,
          date,
          timeSlot
        );
        return isAvailable ? measurer : null;
      })
    );

    return availableMeasurers.filter(Boolean);
  }

  /**
   * 检查时间可用性
   */
  private async checkTimeAvailability(
    measurerId: number,
    date: Date,
    timeSlot: string
  ): Promise<boolean> {
    // 1. 检查当日已安排的测量任务
    const existingMeasurements = await this.measurementRepository.findByMeasurerAndDate(
      measurerId,
      date
    );

    // 2. 检查时间冲突
    const [startTime, endTime] = timeSlot.split('-');
    for (const measurement of existingMeasurements) {
      if (this.hasTimeConflict(
        measurement.appointmentTimeSlot,
        timeSlot
      )) {
        return false;
      }
    }

    // 3. 检查每日最大接单量
    const measurer = await this.measurerRepository.findById(measurerId);
    if (existingMeasurements.length >= measurer.maxDailyOrders) {
      return false;
    }

    return true;
  }

  /**
   * 优化路线规划
   */
  async optimizeRoute(
    measurerId: number,
    date: Date
  ): Promise<RouteOptimizationResult> {
    // 1. 获取当日所有测量任务
    const measurements = await this.measurementRepository.findByMeasurerAndDate(
      measurerId,
      date
    );

    if (measurements.length <= 1) {
      return { optimized: false, originalRoute: measurements };
    }

    // 2. 计算地址间距离矩阵
    const addresses = measurements.map(m => m.measurementAddress);
    const distanceMatrix = await this.geoService.calculateDistanceMatrix(addresses);

    // 3. 使用TSP算法优化路线
    const optimizedOrder = this.solveTSP(distanceMatrix);

    // 4. 重新排序测量任务
    const optimizedMeasurements = optimizedOrder.map(index => measurements[index]);

    // 5. 计算优化效果
    const originalDistance = this.calculateTotalDistance(measurements, distanceMatrix);
    const optimizedDistance = this.calculateTotalDistance(optimizedMeasurements, distanceMatrix);

    return {
      optimized: true,
      originalRoute: measurements,
      optimizedRoute: optimizedMeasurements,
      distanceSaved: originalDistance - optimizedDistance,
      timeSaved: Math.round((originalDistance - optimizedDistance) / 40 * 60) // 假设平均速度40km/h
    };
  }

  /**
   * TSP算法求解最短路径
   */
  private solveTSP(distanceMatrix: number[][]): number[] {
    const n = distanceMatrix.length;
    if (n <= 2) return Array.from({ length: n }, (_, i) => i);

    // 使用贪心算法的简化版本
    const visited = new Array(n).fill(false);
    const route = [0]; // 从第一个点开始
    visited[0] = true;

    for (let i = 1; i < n; i++) {
      let minDistance = Infinity;
      let nextCity = -1;

      for (let j = 0; j < n; j++) {
        if (!visited[j] && distanceMatrix[route[route.length - 1]][j] < minDistance) {
          minDistance = distanceMatrix[route[route.length - 1]][j];
          nextCity = j;
        }
      }

      if (nextCity !== -1) {
        route.push(nextCity);
        visited[nextCity] = true;
      }
    }

    return route;
  }
}
```

## 5. 前端界面设计

### 5.1 Web端界面 (Ant Design)

#### 5.1.1 测量订单列表页面
```typescript
// MeasurementList.tsx
import React, { useState, useEffect } from 'react';
import {
  Table,
  Card,
  Form,
  Input,
  Select,
  DatePicker,
  Button,
  Space,
  Tag,
  Modal,
  message
} from 'antd';
import { SearchOutlined, PlusOutlined, EyeOutlined, UserOutlined } from '@ant-design/icons';

const { RangePicker } = DatePicker;
const { Option } = Select;

const MeasurementList: React.FC = () => {
  const [measurements, setMeasurements] = useState([]);
  const [loading, setLoading] = useState(false);
  const [assignModalVisible, setAssignModalVisible] = useState(false);
  const [selectedMeasurement, setSelectedMeasurement] = useState(null);

  const columns = [
    {
      title: '测量单号',
      dataIndex: 'measurementNo',
      key: 'measurementNo',
      render: (text: string, record: any) => (
        <Button type="link" onClick={() => viewMeasurement(record.id)}>
          {text}
        </Button>
      )
    },
    {
      title: '关联订单',
      dataIndex: 'orderNo',
      key: 'orderNo'
    },
    {
      title: '客户信息',
      key: 'customer',
      render: (record: any) => (
        <div>
          <div>{record.customerName}</div>
          <div style={{ color: '#666', fontSize: '12px' }}>
            {record.customerPhone}
          </div>
        </div>
      )
    },
    {
      title: '测量地址',
      dataIndex: 'measurementAddress',
      key: 'measurementAddress',
      ellipsis: true
    },
    {
      title: '预约时间',
      key: 'appointment',
      render: (record: any) => (
        <div>
          <div>{record.appointmentDate}</div>
          <div style={{ color: '#666', fontSize: '12px' }}>
            {record.appointmentTimeSlot}
          </div>
        </div>
      )
    },
    {
      title: '测量师傅',
      key: 'measurer',
      render: (record: any) => (
        record.measurerName ? (
          <div>
            <div>{record.measurerName}</div>
            <div style={{ color: '#666', fontSize: '12px' }}>
              {record.measurerPhone}
            </div>
          </div>
        ) : (
          <Button 
            type="link" 
            icon={<UserOutlined />}
            onClick={() => assignMeasurer(record)}
          >
            分配师傅
          </Button>
        )
      )
    },
    {
      title: '测量状态',
      dataIndex: 'measurementStatus',
      key: 'measurementStatus',
      render: (status: string) => {
        const statusConfig = {
          pending: { color: 'orange', text: '待安排' },
          scheduled: { color: 'blue', text: '已安排' },
          in_progress: { color: 'purple', text: '测量中' },
          completed: { color: 'green', text: '已完成' },
          cancelled: { color: 'red', text: '已取消' },
          rework: { color: 'volcano', text: '重测' }
        };
        const config = statusConfig[status] || { color: 'default', text: status };
        return <Tag color={config.color}>{config.text}</Tag>;
      }
    },
    {
      title: '测量类型',
      dataIndex: 'measurementType',
      key: 'measurementType',
      render: (type: string) => {
        const typeConfig = {
          standard: '标准测量',
          complex: '复杂测量',
          remeasure: '重新测量',
          supplement: '补充测量'
        };
        return typeConfig[type] || type;
      }
    },
    {
      title: '创建时间',
      dataIndex: 'createdAt',
      key: 'createdAt'
    },
    {
      title: '操作',
      key: 'action',
      render: (record: any) => (
        <Space>
          <Button
            type="link"
            icon={<EyeOutlined />}
            onClick={() => viewMeasurement(record.id)}
          >
            查看
          </Button>
        </Space>
      )
    }
  ];

  const assignMeasurer = (measurement: any) => {
    setSelectedMeasurement(measurement);
    setAssignModalVisible(true);
  };

  const viewMeasurement = (measurementId: number) => {
    window.location.href = `/measurements/${measurementId}`;
  };

  return (
    <Card title="测量管理">
      <Form layout="inline" style={{ marginBottom: 16 }}>
        <Form.Item name="measurementNo" label="测量单号">
          <Input placeholder="请输入测量单号" />
        </Form.Item>
        <Form.Item name="orderNo" label="订单编号">
          <Input placeholder="请输入订单编号" />
        </Form.Item>
        <Form.Item name="customerPhone" label="客户电话">
          <Input placeholder="请输入客户电话" />
        </Form.Item>
        <Form.Item name="measurementStatus" label="测量状态">
          <Select placeholder="请选择状态" style={{ width: 120 }}>
            <Option value="">全部</Option>
            <Option value="pending">待安排</Option>
            <Option value="scheduled">已安排</Option>
            <Option value="in_progress">测量中</Option>
            <Option value="completed">已完成</Option>
            <Option value="cancelled">已取消</Option>
          </Select>
        </Form.Item>
        <Form.Item name="dateRange" label="预约时间">
          <RangePicker />
        </Form.Item>
        <Form.Item>
          <Button type="primary" icon={<SearchOutlined />}>
            搜索
          </Button>
        </Form.Item>
      </Form>

      <Table
        columns={columns}
        dataSource={measurements}
        loading={loading}
        rowKey="id"
        scroll={{ x: 1200 }}
      />

      <Modal
        title="分配测量师傅"
        visible={assignModalVisible}
        onCancel={() => setAssignModalVisible(false)}
        footer={null}
        width={600}
      >
        <AssignMeasurerForm
          measurement={selectedMeasurement}
          onSuccess={() => {
            setAssignModalVisible(false);
            message.success('分配成功');
            // 刷新列表
          }}
        />
      </Modal>
    </Card>
  );
};

export default MeasurementList;
```

#### 5.1.2 测量详情页面
```typescript
// MeasurementDetail.tsx
import React, { useState, useEffect } from 'react';
import {
  Card,
  Descriptions,
  Steps,
  Timeline,
  Button,
  Modal,
  Form,
  Input,
  Upload,
  message,
  Tabs,
  Tag,
  Space,
  Image,
  Table
} from 'antd';
import { UploadOutlined, CameraOutlined } from '@ant-design/icons';

const { Step } = Steps;
const { TabPane } = Tabs;
const { TextArea } = Input;

const MeasurementDetail: React.FC = () => {
  const [measurement, setMeasurement] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const [dataModalVisible, setDataModalVisible] = useState(false);

  const measurementSteps = [
    { title: '创建测量单', status: 'finish' },
    { title: '分配师傅', status: 'finish' },
    { title: '现场测量', status: 'process' },
    { title: '数据确认', status: 'wait' },
    { title: '测量完成', status: 'wait' }
  ];

  const itemColumns = [
    {
      title: '产品信息',
      key: 'product',
      render: (record: any) => (
        <div>
          <div style={{ fontWeight: 'bold' }}>{record.productName}</div>
          <div style={{ color: '#666', fontSize: '12px' }}>
            SKU: {record.productSku}
          </div>
        </div>
      )
    },
    {
      title: '测量数据',
      key: 'measurementData',
      render: (record: any) => (
        record.measurementData ? (
          <div>
            <div>宽: {record.measurementData.width}m</div>
            <div>高: {record.measurementData.height}m</div>
            <div>深: {record.measurementData.depth}m</div>
          </div>
        ) : (
          <span style={{ color: '#999' }}>待测量</span>
        )
      )
    },
    {
      title: '计算面积',
      dataIndex: 'calculatedArea',
      key: 'calculatedArea',
      render: (area: number) => area ? `${area}㎡` : '-'
    },
    {
      title: '项目状态',
      dataIndex: 'itemStatus',
      key: 'itemStatus',
      render: (status: string) => {
        const statusConfig = {
          pending: { color: 'orange', text: '待测量' },
          measuring: { color: 'blue', text: '测量中' },
          completed: { color: 'green', text: '已完成' },
          exception: { color: 'red', text: '异常' }
        };
        const config = statusConfig[status] || { color: 'default', text: status };
        return <Tag color={config.color}>{config.text}</Tag>;
      }
    }
  ];

  return (
    <div>
      <Card title={`测量详情 - ${measurement?.measurementNo}`} style={{ marginBottom: 16 }}>
        <Steps current={2} style={{ marginBottom: 24 }}>
          {measurementSteps.map((step, index) => (
            <Step key={index} title={step.title} status={step.status} />
          ))}
        </Steps>

        <Descriptions column={3} bordered>
          <Descriptions.Item label="测量单号">{measurement?.measurementNo}</Descriptions.Item>
          <Descriptions.Item label="关联订单">{measurement?.orderNo}</Descriptions.Item>
          <Descriptions.Item label="测量状态">
            <Tag color="blue">{measurement?.measurementStatus}</Tag>
          </Descriptions.Item>
          <Descriptions.Item label="客户姓名">{measurement?.customerName}</Descriptions.Item>
          <Descriptions.Item label="客户电话">{measurement?.customerPhone}</Descriptions.Item>
          <Descriptions.Item label="测量类型">{measurement?.measurementType}</Descriptions.Item>
          <Descriptions.Item label="测量地址" span={2}>{measurement?.measurementAddress}</Descriptions.Item>
          <Descriptions.Item label="现场联系人">{measurement?.measurementContact}</Descriptions.Item>
          <Descriptions.Item label="联系电话">{measurement?.measurementPhone}</Descriptions.Item>
          <Descriptions.Item label="测量师傅">{measurement?.measurerName}</Descriptions.Item>
          <Descriptions.Item label="师傅电话">{measurement?.measurerPhone}</Descriptions.Item>
          <Descriptions.Item label="预约日期">{measurement?.appointmentDate}</Descriptions.Item>
          <Descriptions.Item label="预约时段">{measurement?.appointmentTimeSlot}</Descriptions.Item>
          <Descriptions.Item label="实际开始">{measurement?.actualStartTime}</Descriptions.Item>
          <Descriptions.Item label="实际结束">{measurement?.actualEndTime}</Descriptions.Item>
          <Descriptions.Item label="测量费用">¥{measurement?.measurementFee?.toFixed(2)}</Descriptions.Item>
        </Descriptions>

        <div style={{ marginTop: 16 }}>
          <Space>
            <Button type="primary" onClick={() => setDataModalVisible(true)}>
              录入数据
            </Button>
            <Button>开始测量</Button>
            <Button>完成测量</Button>
            <Button>申请重测</Button>
          </Space>
        </div>
      </Card>

      <Tabs defaultActiveKey="items">
        <TabPane tab="测量项目" key="items">
          <Table
            columns={itemColumns}
            dataSource={measurement?.items || []}
            pagination={false}
            rowKey="id"
          />
        </TabPane>

        <TabPane tab="测量照片" key="photos">
          <div style={{ display: 'flex', flexWrap: 'wrap', gap: '16px' }}>
            {measurement?.measurementPhotos?.map((photo: string, index: number) => (
              <Image
                key={index}
                width={200}
                height={150}
                src={photo}
                style={{ objectFit: 'cover' }}
              />
            ))}
          </div>
        </TabPane>

        <TabPane tab="操作日志" key="logs">
          <Timeline>
            {measurement?.logs?.map((log: any, index: number) => (
              <Timeline.Item key={index}>
                <div>
                  <strong>{log.operation}</strong> - {log.description}
                </div>
                <div style={{ color: '#666', fontSize: '12px' }}>
                  {log.operatorName} · {log.createdAt}
                </div>
              </Timeline.Item>
            ))}
          </Timeline>
        </TabPane>
      </Tabs>

      <Modal
        title="录入测量数据"
        visible={dataModalVisible}
        onCancel={() => setDataModalVisible(false)}
        footer={null}
        width={800}
      >
        <MeasurementDataForm
          measurement={measurement}
          onSuccess={() => {
            setDataModalVisible(false);
            message.success('数据录入成功');
          }}
        />
      </Modal>
    </div>
  );
};

export default MeasurementDetail;
```

### 5.2 移动端界面 (Taro + Taro UI)

#### 5.2.1 测量师傅工作台
```typescript
// MeasurerWorkbench.tsx (Mobile)
import React, { useState, useEffect } from 'react';
import { View, Text } from '@tarojs/components';
import { AtList, AtListItem, AtTag, AtButton, AtCard, AtTabs, AtTabsPane } from 'taro-ui';
import Taro from '@tarojs/taro';

const MeasurerWorkbench: React.FC = () => {
  const [measurements, setMeasurements] = useState([]);
  const [activeTab, setActiveTab] = useState(0);

  const tabList = [
    { title: '今日任务' },
    { title: '进行中' },
    { title: '已完成' }
  ];

  const getStatusTag = (status: string) => {
    const statusConfig = {
      scheduled: { color: 'blue', text: '已安排' },
      in_progress: { color: 'orange', text: '进行中' },
      completed: { color: 'green', text: '已完成' }
    };
    const config = statusConfig[status] || { color: 'default', text: status };
    return <AtTag type="primary" size="small">{config.text}</AtTag>;
  };

  const startMeasurement = (measurementId: number) => {
    Taro.navigateTo({
      url: `/pages/measurement/execute?id=${measurementId}`
    });
  };

  const viewMeasurement = (measurementId: number) => {
    Taro.navigateTo({
      url: `/pages/measurement/detail?id=${measurementId}`
    });
  };

  return (
    <View className="measurer-workbench">
      <AtCard title="今日概况">
        <View className="stats-row">
          <View className="stat-item">
            <Text className="stat-number">5</Text>
            <Text className="stat-label">待测量</Text>
          </View>
          <View className="stat-item">
            <Text className="stat-number">2</Text>
            <Text className="stat-label">进行中</Text>
          </View>
          <View className="stat-item">
            <Text className="stat-number">8</Text>
            <Text className="stat-label">已完成</Text>
          </View>
        </View>
      </AtCard>

      <AtTabs current={activeTab} tabList={tabList} onClick={setActiveTab}>
        <AtTabsPane current={activeTab} index={0}>
          <AtList>
            {measurements.map((measurement: any) => (
              <AtListItem
                key={measurement.id}
                title={
                  <View>
                    <Text className="measurement-no">{measurement.measurementNo}</Text>
                    {getStatusTag(measurement.measurementStatus)}
                  </View>
                }
                note={
                  <View>
                    <Text className="customer-info">
                      {measurement.customerName} · {measurement.customerPhone}
                    </Text>
                    <Text className="address">{measurement.measurementAddress}</Text>
                    <Text className="time">
                      {measurement.appointmentDate} {measurement.appointmentTimeSlot}
                    </Text>
                  </View>
                }
                extraText={
                  <AtButton
                    type="primary"
                    size="small"
                    onClick={() => startMeasurement(measurement.id)}
                  >
                    开始测量
                  </AtButton>
                }
                arrow="right"
                onClick={() => viewMeasurement(measurement.id)}
              />
            ))}
          </AtList>
        </AtTabsPane>
      </AtTabs>
    </View>
  );
};

export default MeasurerWorkbench;
```

## 6. 性能优化

### 6.1 数据库优化
- **索引优化**：为常用查询字段创建复合索引
- **分页查询**：使用游标分页提高大数据量查询性能
- **读写分离**：测量查询使用只读副本
- **数据归档**：定期归档历史测量数据

### 6.2 缓存策略
- **Redis缓存**：缓存测量师傅信息和可用性数据
- **地理位置缓存**：缓存地址坐标和距离计算结果
- **模板缓存**：缓存测量模板和计算公式

### 6.3 异步处理
- **消息队列**：异步处理测量通知和状态同步
- **批量操作**：批量更新测量师傅统计数据
- **定时任务**：定时优化路线规划和工作安排

## 7. 安全与权限控制

### 7.1 数据权限
- **角色权限**：基于用户角色控制测量数据访问
- **城市隔离**：不同城市用户只能访问本城市测量订单
- **师傅隔离**：测量师傅只能访问分配给自己的任务

### 7.2 操作权限
- **测量创建**：销售人员、店长
- **师傅分配**：调度员、店长
- **数据录入**：测量师傅、质检员
- **状态变更**：相关角色人员

### 7.3 数据安全
- **照片加密**：测量照片加密存储
- **数据备份**：定期备份测量数据
- **访问日志**：记录所有数据访问操作

## 8. 监控与告警

### 8.1 业务监控
- **测量完成率**：按时完成测量的比例
- **数据准确率**：测量数据质量评分
- **客户满意度**：测量服务满意度评分
- **师傅效率**：平均测量时间和日完成量

### 8.2 系统监控
- **API性能**：测量相关API响应时间
- **数据库性能**：测量表查询性能
- **文件上传**：照片上传成功率

### 8.3 告警规则
```yaml
ALERT_RULES:
  - name: "测量延期告警"
    condition: "overdue_measurements_count > 5"
    severity: "warning"
    message: "测量延期任务过多"
  
  - name: "师傅工作量告警"
    condition: "measurer_daily_workload > 10"
    severity: "warning"
    message: "测量师傅工作量过大"
  
  - name: "数据质量告警"
    condition: "measurement_quality_score < 4.0"
    severity: "critical"
    message: "测量数据质量下降"
  
  - name: "照片上传失败"
    condition: "photo_upload_failure_rate > 5%"
    severity: "warning"
    message: "测量照片上传失败率过高"
```

---

**文档版本**: v1.0  
**创建时间**: 2024-01-01  
**最后更新**: 2024-01-01
