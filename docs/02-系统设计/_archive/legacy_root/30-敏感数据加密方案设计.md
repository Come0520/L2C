# 敏感数据加密方案设计

## 1. 概述

### 1.1 设计目标
- 保护客户隐私信息，如电话、地址、身份证号等敏感数据
- 实现字段级别的细粒度加密控制
- 确保加密性能和系统可用性的平衡
- 支持密钥轮换和版本管理
- 满足数据保护法规要求（如GDPR、个人信息保护法）

### 1.2 加密范围
- **客户信息**：电话号码、地址、身份证号、邮箱
- **订单信息**：收货地址、联系电话
- **员工信息**：个人电话、家庭地址、身份证号
- **财务信息**：银行账号、支付信息
- **业务敏感信息**：合同金额、报价信息

## 2. 加密架构设计

### 2.1 整体架构
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   应用层        │    │   加密服务层     │    │   密钥管理层     │
│                 │    │                 │    │                 │
│ - 业务逻辑      │◄──►│ - 加密/解密     │◄──►│ - 密钥生成      │
│ - 数据访问      │    │ - 字段识别      │    │ - 密钥轮换      │
│ - 权限控制      │    │ - 算法选择      │    │ - 密钥存储      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   数据存储层     │    │   审计日志层     │    │   HSM/KMS      │
│                 │    │                 │    │                 │
│ - 加密数据存储  │    │ - 操作记录      │    │ - 硬件安全模块  │
│ - 索引优化      │    │ - 访问审计      │    │ - 云密钥管理    │
│ - 备份恢复      │    │ - 合规报告      │    │ - 密钥备份      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 2.2 加密策略
- **透明加密**：应用层无感知的自动加密/解密
- **字段级加密**：针对特定敏感字段进行加密
- **格式保留加密**：保持原数据格式，便于索引和查询
- **确定性加密**：相同明文产生相同密文，支持精确查询
- **随机加密**：相同明文产生不同密文，提供更高安全性

## 3. 数据库设计

### 3.1 加密配置表 (encryption_configs)
```sql
CREATE TABLE encryption_configs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    table_name VARCHAR(100) NOT NULL COMMENT '表名',
    field_name VARCHAR(100) NOT NULL COMMENT '字段名',
    encryption_type ENUM('deterministic', 'randomized', 'format_preserving') NOT NULL COMMENT '加密类型',
    algorithm VARCHAR(50) NOT NULL COMMENT '加密算法',
    key_version INT NOT NULL DEFAULT 1 COMMENT '密钥版本',
    is_searchable BOOLEAN DEFAULT FALSE COMMENT '是否支持搜索',
    masking_rule VARCHAR(100) COMMENT '脱敏规则',
    data_classification ENUM('public', 'internal', 'confidential', 'restricted') NOT NULL COMMENT '数据分类',
    compliance_tags JSON COMMENT '合规标签',
    is_active BOOLEAN DEFAULT TRUE COMMENT '是否启用',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_table_field (table_name, field_name),
    INDEX idx_table_name (table_name),
    INDEX idx_data_classification (data_classification)
);
```

### 3.2 密钥管理表 (encryption_keys)
```sql
CREATE TABLE encryption_keys (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    key_id VARCHAR(100) NOT NULL UNIQUE COMMENT '密钥ID',
    key_version INT NOT NULL COMMENT '密钥版本',
    algorithm VARCHAR(50) NOT NULL COMMENT '加密算法',
    key_purpose ENUM('data_encryption', 'key_encryption', 'signing') NOT NULL COMMENT '密钥用途',
    key_status ENUM('active', 'inactive', 'revoked', 'expired') NOT NULL COMMENT '密钥状态',
    encrypted_key TEXT NOT NULL COMMENT '加密后的密钥',
    key_checksum VARCHAR(64) NOT NULL COMMENT '密钥校验和',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP NULL COMMENT '过期时间',
    rotated_at TIMESTAMP NULL COMMENT '轮换时间',
    created_by BIGINT COMMENT '创建人',
    INDEX idx_key_id_version (key_id, key_version),
    INDEX idx_key_status (key_status),
    INDEX idx_expires_at (expires_at)
);
```

### 3.3 加密操作日志表 (encryption_audit_logs)
```sql
CREATE TABLE encryption_audit_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    operation_type ENUM('encrypt', 'decrypt', 'key_access', 'key_rotation') NOT NULL COMMENT '操作类型',
    table_name VARCHAR(100) COMMENT '表名',
    field_name VARCHAR(100) COMMENT '字段名',
    record_id VARCHAR(100) COMMENT '记录ID',
    key_id VARCHAR(100) COMMENT '密钥ID',
    key_version INT COMMENT '密钥版本',
    user_id BIGINT COMMENT '操作用户',
    ip_address VARCHAR(45) COMMENT 'IP地址',
    user_agent TEXT COMMENT '用户代理',
    operation_result ENUM('success', 'failure') NOT NULL COMMENT '操作结果',
    error_message TEXT COMMENT '错误信息',
    operation_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '操作时间',
    INDEX idx_operation_type (operation_type),
    INDEX idx_table_field (table_name, field_name),
    INDEX idx_user_id (user_id),
    INDEX idx_operation_time (operation_time)
);
```

### 3.4 数据脱敏规则表 (data_masking_rules)
```sql
CREATE TABLE data_masking_rules (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    rule_name VARCHAR(100) NOT NULL UNIQUE COMMENT '规则名称',
    rule_type ENUM('phone', 'email', 'id_card', 'address', 'name', 'custom') NOT NULL COMMENT '规则类型',
    masking_pattern VARCHAR(200) NOT NULL COMMENT '脱敏模式',
    preserve_length BOOLEAN DEFAULT TRUE COMMENT '是否保持长度',
    preserve_format BOOLEAN DEFAULT TRUE COMMENT '是否保持格式',
    replacement_char VARCHAR(10) DEFAULT '*' COMMENT '替换字符',
    rule_expression TEXT COMMENT '自定义规则表达式',
    description TEXT COMMENT '规则描述',
    is_active BOOLEAN DEFAULT TRUE COMMENT '是否启用',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_rule_type (rule_type)
);
```

## 4. 加密算法选择

### 4.1 对称加密算法
- **AES-256-GCM**：主要用于随机加密，提供认证加密
- **AES-256-SIV**：用于确定性加密，支持重复查询
- **ChaCha20-Poly1305**：高性能流密码，适用于移动端

### 4.2 格式保留加密 (FPE)
- **FF1/FF3-1**：NIST标准的格式保留加密算法
- **适用场景**：电话号码、身份证号等需要保持格式的数据

### 4.3 密钥派生函数
- **PBKDF2**：基于密码的密钥派生
- **Argon2**：现代密钥派生函数，抗侧信道攻击
- **HKDF**：基于HMAC的密钥派生函数

## 5. 密钥管理方案

### 5.1 密钥层次结构
```
主密钥 (Master Key)
    │
    ├── 数据加密密钥 (DEK)
    │   ├── 客户信息加密密钥
    │   ├── 订单信息加密密钥
    │   └── 员工信息加密密钥
    │
    ├── 密钥加密密钥 (KEK)
    │   ├── DEK加密密钥
    │   └── 备份加密密钥
    │
    └── 签名密钥
        ├── 数据完整性签名
        └── 审计日志签名
```

### 5.2 密钥轮换策略
- **定期轮换**：每90天自动轮换数据加密密钥
- **事件触发轮换**：安全事件或人员变动时立即轮换
- **版本管理**：保留历史密钥版本用于解密旧数据
- **平滑迁移**：新数据使用新密钥，旧数据逐步重加密

### 5.3 密钥存储
- **HSM存储**：主密钥存储在硬件安全模块中
- **云KMS**：使用云服务商的密钥管理服务
- **本地加密**：DEK使用KEK加密后存储在数据库
- **密钥分片**：关键密钥采用分片存储，提高安全性

## 6. 加密服务实现

### 6.1 加密服务接口
```typescript
interface EncryptionService {
  // 字段加密
  encryptField(tableName: string, fieldName: string, plaintext: string): Promise<string>;
  
  // 字段解密
  decryptField(tableName: string, fieldName: string, ciphertext: string): Promise<string>;
  
  // 批量加密
  encryptBatch(data: FieldData[]): Promise<EncryptedData[]>;
  
  // 批量解密
  decryptBatch(data: EncryptedData[]): Promise<FieldData[]>;
  
  // 搜索加密（确定性加密）
  encryptForSearch(tableName: string, fieldName: string, searchValue: string): Promise<string>;
  
  // 数据脱敏
  maskData(data: string, maskingRule: string): string;
  
  // 密钥轮换
  rotateKey(keyId: string): Promise<void>;
  
  // 重加密数据
  reencryptData(tableName: string, fieldName: string, oldKeyVersion: number, newKeyVersion: number): Promise<void>;
}
```

### 6.2 数据访问层拦截器
```typescript
class EncryptionInterceptor {
  // 写入拦截
  async beforeInsert(tableName: string, data: any): Promise<any> {
    const encryptedData = { ...data };
    const encryptionConfigs = await this.getEncryptionConfigs(tableName);
    
    for (const config of encryptionConfigs) {
      if (data[config.fieldName]) {
        encryptedData[config.fieldName] = await this.encryptionService.encryptField(
          tableName, 
          config.fieldName, 
          data[config.fieldName]
        );
      }
    }
    
    return encryptedData;
  }
  
  // 读取拦截
  async afterSelect(tableName: string, data: any[], userPermissions: string[]): Promise<any[]> {
    const encryptionConfigs = await this.getEncryptionConfigs(tableName);
    
    return data.map(row => {
      const decryptedRow = { ...row };
      
      for (const config of encryptionConfigs) {
        if (row[config.fieldName] && this.hasDecryptPermission(config.fieldName, userPermissions)) {
          decryptedRow[config.fieldName] = this.encryptionService.decryptField(
            tableName, 
            config.fieldName, 
            row[config.fieldName]
          );
        } else if (row[config.fieldName]) {
          // 应用脱敏规则
          decryptedRow[config.fieldName] = this.encryptionService.maskData(
            row[config.fieldName], 
            config.maskingRule
          );
        }
      }
      
      return decryptedRow;
    });
  }
}
```

## 7. 性能优化

### 7.1 缓存策略
- **密钥缓存**：将常用密钥缓存在内存中，减少HSM访问
- **加密结果缓存**：对于确定性加密，缓存加密结果
- **配置缓存**：缓存加密配置信息，避免频繁数据库查询

### 7.2 批量处理
- **批量加密**：一次性处理多个字段的加密操作
- **异步处理**：对于大量数据的重加密，采用异步队列处理
- **分页处理**：大数据集分页处理，避免内存溢出

### 7.3 索引优化
- **加密字段索引**：为确定性加密字段创建索引
- **部分索引**：只为常用查询条件创建索引
- **复合索引**：结合业务查询模式设计复合索引

## 8. 安全措施

### 8.1 访问控制
- **最小权限原则**：用户只能访问必要的解密数据
- **角色权限控制**：基于角色控制解密权限
- **时间窗口控制**：限制解密操作的时间窗口
- **IP白名单**：限制密钥访问的IP范围

### 8.2 审计监控
- **操作审计**：记录所有加密/解密操作
- **异常检测**：监控异常的解密请求
- **告警机制**：密钥访问异常时立即告警
- **合规报告**：定期生成合规审计报告

### 8.3 数据保护
- **传输加密**：API调用使用TLS加密
- **内存保护**：敏感数据在内存中及时清除
- **日志脱敏**：日志中不记录明文敏感信息
- **备份加密**：数据备份使用独立密钥加密

## 9. 合规性设计

### 9.1 法规要求
- **GDPR**：欧盟通用数据保护条例
- **个人信息保护法**：中国个人信息保护法
- **网络安全法**：中国网络安全法
- **行业标准**：ISO 27001、SOC 2等

### 9.2 数据分类
- **公开数据**：无需加密
- **内部数据**：基础加密保护
- **机密数据**：强加密+访问控制
- **限制数据**：最高级别加密+严格审计

### 9.3 数据生命周期
- **数据收集**：收集时即进行加密
- **数据处理**：处理过程中保持加密状态
- **数据存储**：长期存储使用强加密
- **数据销毁**：安全删除密钥实现数据销毁

## 10. 实施计划

### 10.1 第一阶段：基础设施搭建
- 部署密钥管理系统
- 实现基础加密服务
- 配置核心敏感字段加密

### 10.2 第二阶段：功能完善
- 实现数据脱敏功能
- 完善权限控制机制
- 建立审计监控体系

### 10.3 第三阶段：优化升级
- 性能优化和调优
- 扩展更多加密字段
- 完善合规性功能

## 11. 运维管理

### 11.1 密钥管理
- **密钥备份**：定期备份密钥到安全位置
- **密钥恢复**：建立密钥恢复流程
- **密钥轮换**：自动化密钥轮换流程
- **密钥销毁**：安全销毁过期密钥

### 11.2 监控告警
- **性能监控**：监控加密/解密性能
- **错误监控**：监控加密操作错误
- **容量监控**：监控密钥存储容量
- **安全监控**：监控异常访问行为

### 11.3 故障处理
- **服务降级**：加密服务故障时的降级策略
- **数据恢复**：加密数据的恢复流程
- **应急响应**：安全事件的应急处理流程
