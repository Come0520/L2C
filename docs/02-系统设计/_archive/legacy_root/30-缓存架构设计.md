# ç½—è±L2Cé”€å”®ç®¡ç†ç³»ç»Ÿ - ç¼“å­˜æ¶æ„è®¾è®¡

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

**é¡¹ç›®åç§°ï¼š** ç½—è±L2Cé”€å”®ç®¡ç†ç³»ç»Ÿç¼“å­˜æ¶æ„è®¾è®¡  
**æ–‡æ¡£ç‰ˆæœ¬ï¼š** v1.0  
**åˆ›å»ºæ—¥æœŸï¼š** 2024å¹´  
**è®¾è®¡ç›®æ ‡ï¼š** æ„å»ºç»Ÿä¸€ã€é«˜æ•ˆã€å¯æ‰©å±•çš„ç¼“å­˜æ¶æ„ï¼Œæå‡ç³»ç»Ÿæ€§èƒ½å’Œç”¨æˆ·ä½“éªŒ  

---

## ğŸ¯ è®¾è®¡ç›®æ ‡ä¸ä»·å€¼

### 1. æ ¸å¿ƒé—®é¢˜è§£å†³
- **ç¼“å­˜ç­–ç•¥ä¸ä¸€è‡´**ï¼šå„æ¨¡å—ç‹¬ç«‹ä½¿ç”¨ç¼“å­˜ï¼Œç¼ºä¹ç»Ÿä¸€è§„èŒƒ
- **æ•°æ®ä¸€è‡´æ€§é£é™©**ï¼šç¼“å­˜ä¸æ•°æ®åº“æ•°æ®ä¸åŒæ­¥
- **æ€§èƒ½ç“¶é¢ˆ**ï¼šé¢‘ç¹æ•°æ®åº“æŸ¥è¯¢å½±å“ç³»ç»Ÿå“åº”é€Ÿåº¦
- **èµ„æºæµªè´¹**ï¼šé‡å¤ç¼“å­˜ç›¸åŒæ•°æ®ï¼Œå†…å­˜ä½¿ç”¨æ•ˆç‡ä½

### 2. ä¸šåŠ¡ä»·å€¼
- **æ€§èƒ½æå‡**ï¼šå‡å°‘æ•°æ®åº“æŸ¥è¯¢ï¼Œæå‡APIå“åº”é€Ÿåº¦50%+
- **ç”¨æˆ·ä½“éªŒ**ï¼šé¡µé¢åŠ è½½é€Ÿåº¦æå‡ï¼Œå‡å°‘ç”¨æˆ·ç­‰å¾…æ—¶é—´
- **ç³»ç»Ÿç¨³å®šæ€§**ï¼šé™ä½æ•°æ®åº“å‹åŠ›ï¼Œæé«˜ç³»ç»Ÿå¹¶å‘å¤„ç†èƒ½åŠ›
- **æˆæœ¬ä¼˜åŒ–**ï¼šå‡å°‘æ•°æ®åº“èµ„æºæ¶ˆè€—ï¼Œé™ä½è¿ç»´æˆæœ¬

### 3. æŠ€æœ¯ç›®æ ‡
- **ç»Ÿä¸€æ¶æ„**ï¼šå»ºç«‹ç»Ÿä¸€çš„ç¼“å­˜æ¶æ„å’Œä½¿ç”¨è§„èŒƒ
- **æ•°æ®ä¸€è‡´æ€§**ï¼šç¡®ä¿ç¼“å­˜ä¸æ•°æ®åº“æ•°æ®çš„ä¸€è‡´æ€§
- **é«˜å¯ç”¨æ€§**ï¼šç¼“å­˜æœåŠ¡é«˜å¯ç”¨ï¼Œæ”¯æŒæ•…éšœè‡ªåŠ¨æ¢å¤
- **å¯æ‰©å±•æ€§**ï¼šæ”¯æŒæ°´å¹³æ‰©å±•ï¼Œé€‚åº”ä¸šåŠ¡å¢é•¿éœ€æ±‚

---

## ğŸ—ï¸ ç¼“å­˜æ¶æ„è®¾è®¡

### 1. æ•´ä½“æ¶æ„

#### 1.1 åˆ†å±‚ç¼“å­˜æ¶æ„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åº”ç”¨å±‚ (Application Layer)               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  å‰ç«¯åº”ç”¨   â”‚ â”‚  ç§»åŠ¨ç«¯åº”ç”¨ â”‚ â”‚  ç®¡ç†åå°   â”‚ â”‚ APIç½‘å…³ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    ç¼“å­˜å±‚ (Cache Layer)                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                L1 ç¼“å­˜ (æœ¬åœ°ç¼“å­˜)                        â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚ â”‚
â”‚  â”‚  â”‚ æµè§ˆå™¨ç¼“å­˜  â”‚ â”‚ åº”ç”¨å†…å­˜ç¼“å­˜â”‚ â”‚  CDNç¼“å­˜    â”‚       â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                L2 ç¼“å­˜ (åˆ†å¸ƒå¼ç¼“å­˜)                      â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚ â”‚
â”‚  â”‚  â”‚ Redisé›†ç¾¤   â”‚ â”‚ ä¼šè¯ç¼“å­˜    â”‚ â”‚ æŸ¥è¯¢ç¼“å­˜    â”‚       â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æœåŠ¡å±‚ (Service Layer)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  ç”¨æˆ·æœåŠ¡   â”‚ â”‚  è®¢å•æœåŠ¡   â”‚ â”‚  äº§å“æœåŠ¡   â”‚ â”‚ ç§¯åˆ†æœåŠ¡â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æ•°æ®å±‚ (Data Layer)                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ PostgreSQL  â”‚ â”‚   MongoDB   â”‚ â”‚ Elasticsearchâ”‚ â”‚ æ–‡ä»¶å­˜å‚¨â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 1.2 ç¼“å­˜æŠ€æœ¯é€‰å‹

| ç¼“å­˜å±‚çº§ | æŠ€æœ¯æ–¹æ¡ˆ | ç”¨é€” | TTL | å®¹é‡ |
|---------|---------|------|-----|------|
| **L1 æœ¬åœ°ç¼“å­˜** | Node.js Memory Cache | çƒ­ç‚¹æ•°æ®ã€è®¡ç®—ç»“æœ | 5-30åˆ†é’Ÿ | 100MB-1GB |
| **L2 åˆ†å¸ƒå¼ç¼“å­˜** | Redis Cluster | ä¼šè¯ã€æŸ¥è¯¢ç»“æœã€ä¸šåŠ¡æ•°æ® | 1å°æ—¶-24å°æ—¶ | 10GB-100GB |
| **L3 æŒä¹…åŒ–ç¼“å­˜** | Redis Persistence | é…ç½®æ•°æ®ã€å­—å…¸æ•°æ® | 7å¤©-30å¤© | 1GB-10GB |
| **CDNç¼“å­˜** | é˜¿é‡Œäº‘CDN/CloudFlare | é™æ€èµ„æºã€å›¾ç‰‡ | 24å°æ—¶-7å¤© | æ— é™åˆ¶ |

### 2. ç¼“å­˜åˆ†ç±»è®¾è®¡

#### 2.1 æŒ‰æ•°æ®ç±»å‹åˆ†ç±»

##### 2.1.1 ç”¨æˆ·æ•°æ®ç¼“å­˜
```typescript
// ç”¨æˆ·æ•°æ®ç¼“å­˜ç­–ç•¥
interface UserCacheStrategy {
  // ç”¨æˆ·åŸºæœ¬ä¿¡æ¯
  USER_PROFILE: {
    key: 'user:profile:{userId}',
    ttl: 3600, // 1å°æ—¶
    source: 'usersè¡¨',
    updateTrigger: ['ç”¨æˆ·ä¿¡æ¯æ›´æ–°', 'ç™»å½•çŠ¶æ€å˜æ›´']
  },
  
  // ç”¨æˆ·æƒé™ä¿¡æ¯
  USER_PERMISSIONS: {
    key: 'user:permissions:{userId}',
    ttl: 1800, // 30åˆ†é’Ÿ
    source: 'user_roles, role_permissionsè¡¨',
    updateTrigger: ['è§’è‰²å˜æ›´', 'æƒé™æ›´æ–°']
  },
  
  // ç”¨æˆ·ä¼šè¯ä¿¡æ¯
  USER_SESSION: {
    key: 'session:{sessionId}',
    ttl: 7200, // 2å°æ—¶
    source: 'ä¼šè¯å­˜å‚¨',
    updateTrigger: ['ç”¨æˆ·æ“ä½œ', 'ä¼šè¯åˆ·æ–°']
  },
  
  // ç”¨æˆ·åå¥½è®¾ç½®
  USER_PREFERENCES: {
    key: 'user:preferences:{userId}',
    ttl: 86400, // 24å°æ—¶
    source: 'user_preferencesè¡¨',
    updateTrigger: ['è®¾ç½®æ›´æ–°']
  }
}

// ç”¨æˆ·ç¼“å­˜ç®¡ç†å™¨
class UserCacheManager {
  async getUserProfile(userId: string): Promise<UserProfile> {
    const cacheKey = `user:profile:${userId}`;
    
    // å°è¯•ä»ç¼“å­˜è·å–
    let userProfile = await this.redis.get(cacheKey);
    if (userProfile) {
      return JSON.parse(userProfile);
    }
    
    // ä»æ•°æ®åº“è·å–
    userProfile = await this.userService.findById(userId);
    
    // å­˜å…¥ç¼“å­˜
    await this.redis.setex(cacheKey, 3600, JSON.stringify(userProfile));
    
    return userProfile;
  }
  
  async updateUserProfile(userId: string, profileData: Partial<UserProfile>) {
    // æ›´æ–°æ•°æ®åº“
    const updatedProfile = await this.userService.update(userId, profileData);
    
    // æ›´æ–°ç¼“å­˜
    const cacheKey = `user:profile:${userId}`;
    await this.redis.setex(cacheKey, 3600, JSON.stringify(updatedProfile));
    
    // å‘å¸ƒæ›´æ–°äº‹ä»¶
    await this.eventBus.publish('user.profile.updated', { userId, profile: updatedProfile });
    
    return updatedProfile;
  }
  
  async invalidateUserCache(userId: string) {
    const patterns = [
      `user:profile:${userId}`,
      `user:permissions:${userId}`,
      `user:preferences:${userId}`
    ];
    
    await Promise.all(patterns.map(pattern => this.redis.del(pattern)));
  }
}
```

##### 2.1.2 ä¸šåŠ¡æ•°æ®ç¼“å­˜
```typescript
// ä¸šåŠ¡æ•°æ®ç¼“å­˜ç­–ç•¥
interface BusinessCacheStrategy {
  // äº§å“ä¿¡æ¯ç¼“å­˜
  PRODUCT_INFO: {
    key: 'product:info:{productId}',
    ttl: 7200, // 2å°æ—¶
    source: 'productsè¡¨',
    updateTrigger: ['äº§å“ä¿¡æ¯æ›´æ–°', 'ä»·æ ¼å˜æ›´', 'åº“å­˜å˜æ›´']
  },
  
  // äº§å“åˆ—è¡¨ç¼“å­˜
  PRODUCT_LIST: {
    key: 'product:list:{category}:{page}:{size}',
    ttl: 1800, // 30åˆ†é’Ÿ
    source: 'productsè¡¨',
    updateTrigger: ['äº§å“ä¸Šä¸‹æ¶', 'åˆ†ç±»å˜æ›´']
  },
  
  // è®¢å•ä¿¡æ¯ç¼“å­˜
  ORDER_INFO: {
    key: 'order:info:{orderId}',
    ttl: 3600, // 1å°æ—¶
    source: 'ordersè¡¨',
    updateTrigger: ['è®¢å•çŠ¶æ€å˜æ›´', 'è®¢å•ä¿¡æ¯æ›´æ–°']
  },
  
  // åº“å­˜ä¿¡æ¯ç¼“å­˜
  INVENTORY_INFO: {
    key: 'inventory:info:{productId}:{warehouseId}',
    ttl: 300, // 5åˆ†é’Ÿ
    source: 'inventoryè¡¨',
    updateTrigger: ['åº“å­˜å˜æ›´', 'å…¥åº“å‡ºåº“']
  }
}

// ä¸šåŠ¡ç¼“å­˜ç®¡ç†å™¨
class BusinessCacheManager {
  async getProductInfo(productId: string): Promise<ProductInfo> {
    const cacheKey = `product:info:${productId}`;
    
    // å¤šçº§ç¼“å­˜æŸ¥è¯¢
    let productInfo = await this.localCache.get(cacheKey);
    if (productInfo) {
      return productInfo;
    }
    
    productInfo = await this.redis.get(cacheKey);
    if (productInfo) {
      const parsed = JSON.parse(productInfo);
      // å­˜å…¥æœ¬åœ°ç¼“å­˜
      await this.localCache.set(cacheKey, parsed, 300); // 5åˆ†é’Ÿ
      return parsed;
    }
    
    // ä»æ•°æ®åº“è·å–
    productInfo = await this.productService.findById(productId);
    
    // å­˜å…¥åˆ†å¸ƒå¼ç¼“å­˜
    await this.redis.setex(cacheKey, 7200, JSON.stringify(productInfo));
    
    // å­˜å…¥æœ¬åœ°ç¼“å­˜
    await this.localCache.set(cacheKey, productInfo, 300);
    
    return productInfo;
  }
  
  async getProductList(category: string, page: number, size: number): Promise<ProductList> {
    const cacheKey = `product:list:${category}:${page}:${size}`;
    
    let productList = await this.redis.get(cacheKey);
    if (productList) {
      return JSON.parse(productList);
    }
    
    // ä»æ•°æ®åº“è·å–
    productList = await this.productService.findByCategory(category, page, size);
    
    // å­˜å…¥ç¼“å­˜
    await this.redis.setex(cacheKey, 1800, JSON.stringify(productList));
    
    return productList;
  }
  
  async updateProductInfo(productId: string, productData: Partial<ProductInfo>) {
    // æ›´æ–°æ•°æ®åº“
    const updatedProduct = await this.productService.update(productId, productData);
    
    // æ›´æ–°ç¼“å­˜
    const cacheKey = `product:info:${productId}`;
    await this.redis.setex(cacheKey, 7200, JSON.stringify(updatedProduct));
    await this.localCache.set(cacheKey, updatedProduct, 300);
    
    // æ¸…é™¤ç›¸å…³åˆ—è¡¨ç¼“å­˜
    await this.invalidateProductListCache(updatedProduct.category);
    
    return updatedProduct;
  }
  
  async invalidateProductListCache(category?: string) {
    if (category) {
      const pattern = `product:list:${category}:*`;
      const keys = await this.redis.keys(pattern);
      if (keys.length > 0) {
        await this.redis.del(...keys);
      }
    } else {
      const pattern = 'product:list:*';
      const keys = await this.redis.keys(pattern);
      if (keys.length > 0) {
        await this.redis.del(...keys);
      }
    }
  }
}
```

##### 2.1.3 é…ç½®æ•°æ®ç¼“å­˜
```typescript
// é…ç½®æ•°æ®ç¼“å­˜ç­–ç•¥
interface ConfigCacheStrategy {
  // ç³»ç»Ÿé…ç½®
  SYSTEM_CONFIG: {
    key: 'config:system',
    ttl: 86400, // 24å°æ—¶
    source: 'system_configsè¡¨',
    updateTrigger: ['ç³»ç»Ÿé…ç½®æ›´æ–°']
  },
  
  // å­—å…¸æ•°æ®
  DICTIONARY_DATA: {
    key: 'dict:{type}',
    ttl: 604800, // 7å¤©
    source: 'dictionariesè¡¨',
    updateTrigger: ['å­—å…¸æ•°æ®æ›´æ–°']
  },
  
  // åœ°åŒºæ•°æ®
  REGION_DATA: {
    key: 'region:tree',
    ttl: 604800, // 7å¤©
    source: 'regionsè¡¨',
    updateTrigger: ['åœ°åŒºæ•°æ®æ›´æ–°']
  },
  
  // ç§¯åˆ†è§„åˆ™
  POINTS_RULES: {
    key: 'points:rules',
    ttl: 3600, // 1å°æ—¶
    source: 'points_rulesè¡¨',
    updateTrigger: ['ç§¯åˆ†è§„åˆ™æ›´æ–°']
  }
}

// é…ç½®ç¼“å­˜ç®¡ç†å™¨
class ConfigCacheManager {
  async getSystemConfig(): Promise<SystemConfig> {
    const cacheKey = 'config:system';
    
    let config = await this.redis.get(cacheKey);
    if (config) {
      return JSON.parse(config);
    }
    
    // ä»æ•°æ®åº“è·å–
    config = await this.configService.getSystemConfig();
    
    // å­˜å…¥ç¼“å­˜
    await this.redis.setex(cacheKey, 86400, JSON.stringify(config));
    
    return config;
  }
  
  async getDictionaryData(type: string): Promise<DictionaryItem[]> {
    const cacheKey = `dict:${type}`;
    
    let dictData = await this.redis.get(cacheKey);
    if (dictData) {
      return JSON.parse(dictData);
    }
    
    // ä»æ•°æ®åº“è·å–
    dictData = await this.dictionaryService.findByType(type);
    
    // å­˜å…¥ç¼“å­˜
    await this.redis.setex(cacheKey, 604800, JSON.stringify(dictData));
    
    return dictData;
  }
  
  async updateSystemConfig(configData: Partial<SystemConfig>) {
    // æ›´æ–°æ•°æ®åº“
    const updatedConfig = await this.configService.updateSystemConfig(configData);
    
    // æ›´æ–°ç¼“å­˜
    const cacheKey = 'config:system';
    await this.redis.setex(cacheKey, 86400, JSON.stringify(updatedConfig));
    
    // å‘å¸ƒé…ç½®æ›´æ–°äº‹ä»¶
    await this.eventBus.publish('system.config.updated', updatedConfig);
    
    return updatedConfig;
  }
}
```

#### 2.2 æŒ‰è®¿é—®æ¨¡å¼åˆ†ç±»

##### 2.2.1 è¯»å¤šå†™å°‘ç¼“å­˜
```typescript
// è¯»å¤šå†™å°‘æ•°æ®ç¼“å­˜ç­–ç•¥
class ReadHeavyCacheManager {
  // äº§å“è¯¦æƒ…é¡µç¼“å­˜ï¼ˆè¯»å¤šå†™å°‘ï¼‰
  async getProductDetail(productId: string): Promise<ProductDetail> {
    const cacheKey = `product:detail:${productId}`;
    
    // ä½¿ç”¨ Cache-Aside æ¨¡å¼
    let productDetail = await this.redis.get(cacheKey);
    if (productDetail) {
      // å¼‚æ­¥æ›´æ–°è®¿é—®ç»Ÿè®¡
      this.updateProductViewCount(productId);
      return JSON.parse(productDetail);
    }
    
    // é˜²æ­¢ç¼“å­˜å‡»ç©¿ - ä½¿ç”¨åˆ†å¸ƒå¼é”
    const lockKey = `lock:product:${productId}`;
    const lock = await this.redis.set(lockKey, '1', 'PX', 10000, 'NX');
    
    if (lock) {
      try {
        // å†æ¬¡æ£€æŸ¥ç¼“å­˜
        productDetail = await this.redis.get(cacheKey);
        if (productDetail) {
          return JSON.parse(productDetail);
        }
        
        // ä»æ•°æ®åº“è·å–
        productDetail = await this.productService.getDetailById(productId);
        
        // å­˜å…¥ç¼“å­˜ï¼Œè®¾ç½®è¾ƒé•¿TTL
        await this.redis.setex(cacheKey, 7200, JSON.stringify(productDetail));
        
        return productDetail;
      } finally {
        await this.redis.del(lockKey);
      }
    } else {
      // ç­‰å¾…å…¶ä»–çº¿ç¨‹åŠ è½½å®Œæˆ
      await new Promise(resolve => setTimeout(resolve, 100));
      return this.getProductDetail(productId);
    }
  }
  
  // ç”¨æˆ·ç§¯åˆ†ä¿¡æ¯ç¼“å­˜ï¼ˆè¯»å¤šå†™å°‘ï¼‰
  async getUserPoints(userId: string): Promise<UserPoints> {
    const cacheKey = `user:points:${userId}`;
    
    let userPoints = await this.redis.get(cacheKey);
    if (userPoints) {
      return JSON.parse(userPoints);
    }
    
    // ä»æ•°æ®åº“è·å–
    userPoints = await this.pointsService.getUserPoints(userId);
    
    // å­˜å…¥ç¼“å­˜
    await this.redis.setex(cacheKey, 3600, JSON.stringify(userPoints));
    
    return userPoints;
  }
}
```

##### 2.2.2 å†™å¤šè¯»å°‘ç¼“å­˜
```typescript
// å†™å¤šè¯»å°‘æ•°æ®ç¼“å­˜ç­–ç•¥
class WriteHeavyCacheManager {
  // ç”¨æˆ·è¡Œä¸ºæ—¥å¿—ç¼“å­˜ï¼ˆå†™å¤šè¯»å°‘ï¼‰
  async recordUserAction(userId: string, action: UserAction) {
    const cacheKey = `user:actions:${userId}`;
    
    // ä½¿ç”¨ Write-Behind æ¨¡å¼
    // å…ˆå†™å…¥ç¼“å­˜
    await this.redis.lpush(cacheKey, JSON.stringify(action));
    await this.redis.expire(cacheKey, 3600);
    
    // å¼‚æ­¥æ‰¹é‡å†™å…¥æ•°æ®åº“
    this.scheduleAsyncWrite(userId);
  }
  
  private async scheduleAsyncWrite(userId: string) {
    const batchKey = `batch:user:actions:${userId}`;
    
    // é˜²é‡å¤è°ƒåº¦
    const scheduled = await this.redis.set(batchKey, '1', 'PX', 30000, 'NX');
    if (!scheduled) return;
    
    // å»¶è¿Ÿæ‰¹é‡å†™å…¥
    setTimeout(async () => {
      await this.flushUserActions(userId);
      await this.redis.del(batchKey);
    }, 30000);
  }
  
  private async flushUserActions(userId: string) {
    const cacheKey = `user:actions:${userId}`;
    
    // è·å–æ‰€æœ‰å¾…å†™å…¥çš„è¡Œä¸ºè®°å½•
    const actions = await this.redis.lrange(cacheKey, 0, -1);
    if (actions.length === 0) return;
    
    // æ‰¹é‡å†™å…¥æ•°æ®åº“
    const actionObjects = actions.map(action => JSON.parse(action));
    await this.userActionService.batchInsert(actionObjects);
    
    // æ¸…é™¤ç¼“å­˜
    await this.redis.del(cacheKey);
  }
  
  // å®æ—¶ç»Ÿè®¡æ•°æ®ç¼“å­˜ï¼ˆå†™å¤šè¯»å°‘ï¼‰
  async updateStatistics(type: string, key: string, increment: number = 1) {
    const cacheKey = `stats:${type}:${key}`;
    
    // ä½¿ç”¨ Write-Through æ¨¡å¼
    // æ›´æ–°ç¼“å­˜
    await this.redis.incrby(cacheKey, increment);
    await this.redis.expire(cacheKey, 86400);
    
    // åŒæ­¥æ›´æ–°æ•°æ®åº“
    await this.statisticsService.increment(type, key, increment);
  }
}
```

### 3. ç¼“å­˜ä¸€è‡´æ€§ç­–ç•¥

#### 3.1 ç¼“å­˜æ›´æ–°ç­–ç•¥

##### 3.1.1 Cache-Aside æ¨¡å¼
```typescript
// Cache-Aside æ¨¡å¼å®ç°
class CacheAsideManager {
  async getData(key: string, loader: () => Promise<any>): Promise<any> {
    // 1. å…ˆæŸ¥ç¼“å­˜
    let data = await this.redis.get(key);
    if (data) {
      return JSON.parse(data);
    }
    
    // 2. ç¼“å­˜æœªå‘½ä¸­ï¼Œä»æ•°æ®æºåŠ è½½
    data = await loader();
    
    // 3. å°†æ•°æ®å†™å…¥ç¼“å­˜
    await this.redis.setex(key, this.getTTL(key), JSON.stringify(data));
    
    return data;
  }
  
  async updateData(key: string, updater: () => Promise<any>): Promise<any> {
    // 1. æ›´æ–°æ•°æ®æº
    const data = await updater();
    
    // 2. åˆ é™¤ç¼“å­˜ï¼ˆè®©ä¸‹æ¬¡è¯»å–æ—¶é‡æ–°åŠ è½½ï¼‰
    await this.redis.del(key);
    
    return data;
  }
}
```

##### 3.1.2 Write-Through æ¨¡å¼
```typescript
// Write-Through æ¨¡å¼å®ç°
class WriteThroughManager {
  async updateData(key: string, data: any, persister: (data: any) => Promise<any>): Promise<any> {
    // 1. åŒæ—¶æ›´æ–°ç¼“å­˜å’Œæ•°æ®æº
    const [cacheResult, dbResult] = await Promise.all([
      this.redis.setex(key, this.getTTL(key), JSON.stringify(data)),
      persister(data)
    ]);
    
    return dbResult;
  }
}
```

##### 3.1.3 Write-Behind æ¨¡å¼
```typescript
// Write-Behind æ¨¡å¼å®ç°
class WriteBehindManager {
  private writeQueue = new Map<string, any>();
  private flushInterval = 30000; // 30ç§’
  
  constructor() {
    // å®šæœŸåˆ·æ–°åˆ°æ•°æ®åº“
    setInterval(() => this.flushToDatabase(), this.flushInterval);
  }
  
  async updateData(key: string, data: any): Promise<void> {
    // 1. ç«‹å³æ›´æ–°ç¼“å­˜
    await this.redis.setex(key, this.getTTL(key), JSON.stringify(data));
    
    // 2. åŠ å…¥å†™å…¥é˜Ÿåˆ—
    this.writeQueue.set(key, data);
  }
  
  private async flushToDatabase() {
    if (this.writeQueue.size === 0) return;
    
    const entries = Array.from(this.writeQueue.entries());
    this.writeQueue.clear();
    
    // æ‰¹é‡å†™å…¥æ•°æ®åº“
    await Promise.all(
      entries.map(([key, data]) => this.persistData(key, data))
    );
  }
  
  private async persistData(key: string, data: any) {
    try {
      // æ ¹æ®keyç±»å‹é€‰æ‹©å¯¹åº”çš„æŒä¹…åŒ–æ–¹æ³•
      if (key.startsWith('user:')) {
        await this.userService.update(this.extractId(key), data);
      } else if (key.startsWith('product:')) {
        await this.productService.update(this.extractId(key), data);
      }
      // ... å…¶ä»–ç±»å‹
    } catch (error) {
      console.error(`æŒä¹…åŒ–æ•°æ®å¤±è´¥: ${key}`, error);
      // é‡æ–°åŠ å…¥é˜Ÿåˆ—é‡è¯•
      this.writeQueue.set(key, data);
    }
  }
}
```

#### 3.2 ç¼“å­˜å¤±æ•ˆç­–ç•¥

##### 3.2.1 åŸºäºäº‹ä»¶çš„ç¼“å­˜å¤±æ•ˆ
```typescript
// äº‹ä»¶é©±åŠ¨çš„ç¼“å­˜å¤±æ•ˆ
class EventDrivenCacheInvalidation {
  constructor(private eventBus: EventBus, private redis: Redis) {
    this.setupEventHandlers();
  }
  
  private setupEventHandlers() {
    // ç”¨æˆ·ä¿¡æ¯æ›´æ–°äº‹ä»¶
    this.eventBus.on('user.updated', async (event) => {
      await this.invalidateUserCache(event.userId);
    });
    
    // äº§å“ä¿¡æ¯æ›´æ–°äº‹ä»¶
    this.eventBus.on('product.updated', async (event) => {
      await this.invalidateProductCache(event.productId);
    });
    
    // è®¢å•çŠ¶æ€å˜æ›´äº‹ä»¶
    this.eventBus.on('order.status.changed', async (event) => {
      await this.invalidateOrderCache(event.orderId);
      await this.invalidateUserOrdersCache(event.userId);
    });
    
    // åº“å­˜å˜æ›´äº‹ä»¶
    this.eventBus.on('inventory.changed', async (event) => {
      await this.invalidateInventoryCache(event.productId, event.warehouseId);
      await this.invalidateProductCache(event.productId);
    });
  }
  
  private async invalidateUserCache(userId: string) {
    const patterns = [
      `user:profile:${userId}`,
      `user:permissions:${userId}`,
      `user:preferences:${userId}`,
      `user:orders:${userId}:*`
    ];
    
    for (const pattern of patterns) {
      if (pattern.includes('*')) {
        const keys = await this.redis.keys(pattern);
        if (keys.length > 0) {
          await this.redis.del(...keys);
        }
      } else {
        await this.redis.del(pattern);
      }
    }
  }
  
  private async invalidateProductCache(productId: string) {
    const patterns = [
      `product:info:${productId}`,
      `product:detail:${productId}`,
      `product:list:*`, // äº§å“åˆ—è¡¨å¯èƒ½åŒ…å«è¯¥äº§å“
      `inventory:info:${productId}:*`
    ];
    
    for (const pattern of patterns) {
      if (pattern.includes('*')) {
        const keys = await this.redis.keys(pattern);
        if (keys.length > 0) {
          await this.redis.del(...keys);
        }
      } else {
        await this.redis.del(pattern);
      }
    }
  }
}
```

##### 3.2.2 åŸºäºç‰ˆæœ¬çš„ç¼“å­˜å¤±æ•ˆ
```typescript
// ç‰ˆæœ¬æ§åˆ¶çš„ç¼“å­˜ç®¡ç†
class VersionedCacheManager {
  async getData(key: string, loader: () => Promise<any>): Promise<any> {
    const versionKey = `version:${key}`;
    const dataKey = `data:${key}`;
    
    // è·å–å½“å‰ç‰ˆæœ¬å’Œç¼“å­˜æ•°æ®
    const [version, cachedData] = await Promise.all([
      this.redis.get(versionKey),
      this.redis.get(dataKey)
    ]);
    
    if (version && cachedData) {
      const data = JSON.parse(cachedData);
      if (data.version === version) {
        return data.content;
      }
    }
    
    // ç‰ˆæœ¬ä¸åŒ¹é…æˆ–æ— ç¼“å­˜ï¼Œé‡æ–°åŠ è½½
    const content = await loader();
    const newVersion = Date.now().toString();
    
    // æ›´æ–°ç‰ˆæœ¬å’Œæ•°æ®
    await Promise.all([
      this.redis.set(versionKey, newVersion),
      this.redis.setex(dataKey, this.getTTL(key), JSON.stringify({
        version: newVersion,
        content
      }))
    ]);
    
    return content;
  }
  
  async invalidateByVersion(key: string) {
    const versionKey = `version:${key}`;
    // åªéœ€è¦æ›´æ–°ç‰ˆæœ¬å·ï¼Œä¸‹æ¬¡è®¿é—®æ—¶ä¼šè‡ªåŠ¨é‡æ–°åŠ è½½
    await this.redis.set(versionKey, Date.now().toString());
  }
}
```

### 4. ç¼“å­˜æ€§èƒ½ä¼˜åŒ–

#### 4.1 ç¼“å­˜é¢„çƒ­ç­–ç•¥

##### 4.1.1 åº”ç”¨å¯åŠ¨é¢„çƒ­
```typescript
// åº”ç”¨å¯åŠ¨æ—¶çš„ç¼“å­˜é¢„çƒ­
class CacheWarmupService {
  async warmupOnStartup() {
    console.log('å¼€å§‹ç¼“å­˜é¢„çƒ­...');
    
    await Promise.all([
      this.warmupSystemConfig(),
      this.warmupDictionaryData(),
      this.warmupHotProducts(),
      this.warmupRegionData()
    ]);
    
    console.log('ç¼“å­˜é¢„çƒ­å®Œæˆ');
  }
  
  private async warmupSystemConfig() {
    const config = await this.configService.getSystemConfig();
    await this.redis.setex('config:system', 86400, JSON.stringify(config));
  }
  
  private async warmupDictionaryData() {
    const dictTypes = ['order_status', 'product_category', 'user_level'];
    
    for (const type of dictTypes) {
      const dictData = await this.dictionaryService.findByType(type);
      await this.redis.setex(`dict:${type}`, 604800, JSON.stringify(dictData));
    }
  }
  
  private async warmupHotProducts() {
    // é¢„çƒ­çƒ­é—¨äº§å“æ•°æ®
    const hotProducts = await this.productService.getHotProducts(100);
    
    for (const product of hotProducts) {
      const cacheKey = `product:info:${product.id}`;
      await this.redis.setex(cacheKey, 7200, JSON.stringify(product));
    }
  }
  
  private async warmupRegionData() {
    const regionTree = await this.regionService.getRegionTree();
    await this.redis.setex('region:tree', 604800, JSON.stringify(regionTree));
  }
}
```

##### 4.1.2 å®šæ—¶é¢„çƒ­ç­–ç•¥
```typescript
// å®šæ—¶ç¼“å­˜é¢„çƒ­
class ScheduledCacheWarmup {
  constructor() {
    // æ¯å¤©å‡Œæ™¨2ç‚¹é¢„çƒ­çƒ­é—¨æ•°æ®
    this.scheduleJob('0 2 * * *', () => this.warmupHotData());
    
    // æ¯å°æ—¶é¢„çƒ­ç”¨æˆ·æ´»è·ƒæ•°æ®
    this.scheduleJob('0 * * * *', () => this.warmupActiveUserData());
  }
  
  private async warmupHotData() {
    // é¢„çƒ­çƒ­é—¨äº§å“
    const hotProducts = await this.analyticsService.getHotProducts(24); // 24å°æ—¶å†…çƒ­é—¨
    for (const product of hotProducts) {
      await this.cacheManager.getProductInfo(product.id);
    }
    
    // é¢„çƒ­çƒ­é—¨æœç´¢å…³é”®è¯
    const hotKeywords = await this.analyticsService.getHotSearchKeywords(24);
    for (const keyword of hotKeywords) {
      await this.searchService.search(keyword, 1, 20); // é¢„çƒ­æœç´¢ç»“æœ
    }
  }
  
  private async warmupActiveUserData() {
    // é¢„çƒ­æ´»è·ƒç”¨æˆ·æ•°æ®
    const activeUsers = await this.analyticsService.getActiveUsers(1); // 1å°æ—¶å†…æ´»è·ƒ
    for (const user of activeUsers) {
      await this.cacheManager.getUserProfile(user.id);
      await this.cacheManager.getUserPermissions(user.id);
    }
  }
}
```

#### 4.2 ç¼“å­˜å‹ç¼©ä¼˜åŒ–

##### 4.2.1 æ•°æ®å‹ç¼©
```typescript
// ç¼“å­˜æ•°æ®å‹ç¼©
class CompressedCacheManager {
  async set(key: string, data: any, ttl: number) {
    const jsonString = JSON.stringify(data);
    
    // å¤§äº1KBçš„æ•°æ®è¿›è¡Œå‹ç¼©
    if (jsonString.length > 1024) {
      const compressed = await this.compress(jsonString);
      await this.redis.setex(`${key}:compressed`, ttl, compressed);
      await this.redis.setex(`${key}:meta`, ttl, JSON.stringify({ compressed: true }));
    } else {
      await this.redis.setex(key, ttl, jsonString);
    }
  }
  
  async get(key: string): Promise<any> {
    // æ£€æŸ¥æ˜¯å¦ä¸ºå‹ç¼©æ•°æ®
    const meta = await this.redis.get(`${key}:meta`);
    if (meta && JSON.parse(meta).compressed) {
      const compressed = await this.redis.get(`${key}:compressed`);
      if (compressed) {
        const decompressed = await this.decompress(compressed);
        return JSON.parse(decompressed);
      }
    }
    
    // æ™®é€šæ•°æ®
    const data = await this.redis.get(key);
    return data ? JSON.parse(data) : null;
  }
  
  private async compress(data: string): Promise<string> {
    return new Promise((resolve, reject) => {
      zlib.gzip(data, (err, compressed) => {
        if (err) reject(err);
        else resolve(compressed.toString('base64'));
      });
    });
  }
  
  private async decompress(compressedData: string): Promise<string> {
    return new Promise((resolve, reject) => {
      const buffer = Buffer.from(compressedData, 'base64');
      zlib.gunzip(buffer, (err, decompressed) => {
        if (err) reject(err);
        else resolve(decompressed.toString());
      });
    });
  }
}
```

#### 4.3 ç¼“å­˜åˆ†ç‰‡ç­–ç•¥

##### 4.3.1 ä¸€è‡´æ€§å“ˆå¸Œåˆ†ç‰‡
```typescript
// ä¸€è‡´æ€§å“ˆå¸Œç¼“å­˜åˆ†ç‰‡
class ConsistentHashCacheManager {
  private hashRing: Map<number, string> = new Map();
  private nodes: string[] = [];
  private virtualNodes = 150; // æ¯ä¸ªç‰©ç†èŠ‚ç‚¹çš„è™šæ‹ŸèŠ‚ç‚¹æ•°
  
  constructor(nodes: string[]) {
    this.nodes = nodes;
    this.buildHashRing();
  }
  
  private buildHashRing() {
    this.hashRing.clear();
    
    for (const node of this.nodes) {
      for (let i = 0; i < this.virtualNodes; i++) {
        const virtualNodeKey = `${node}:${i}`;
        const hash = this.hash(virtualNodeKey);
        this.hashRing.set(hash, node);
      }
    }
  }
  
  private getNode(key: string): string {
    const hash = this.hash(key);
    const sortedHashes = Array.from(this.hashRing.keys()).sort((a, b) => a - b);
    
    // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºhashå€¼çš„èŠ‚ç‚¹
    for (const nodeHash of sortedHashes) {
      if (nodeHash >= hash) {
        return this.hashRing.get(nodeHash)!;
      }
    }
    
    // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œè¿”å›ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆç¯å½¢ç»“æ„ï¼‰
    return this.hashRing.get(sortedHashes[0])!;
  }
  
  async set(key: string, value: any, ttl: number) {
    const node = this.getNode(key);
    const redis = this.getRedisClient(node);
    await redis.setex(key, ttl, JSON.stringify(value));
  }
  
  async get(key: string): Promise<any> {
    const node = this.getNode(key);
    const redis = this.getRedisClient(node);
    const data = await redis.get(key);
    return data ? JSON.parse(data) : null;
  }
  
  private hash(key: string): number {
    // ç®€å•çš„å“ˆå¸Œå‡½æ•°ï¼Œå®é™…åº”ç”¨ä¸­å¯ä½¿ç”¨æ›´å¥½çš„å“ˆå¸Œç®—æ³•
    let hash = 0;
    for (let i = 0; i < key.length; i++) {
      hash = ((hash << 5) - hash + key.charCodeAt(i)) & 0xffffffff;
    }
    return Math.abs(hash);
  }
  
  private getRedisClient(node: string): Redis {
    // è¿”å›å¯¹åº”èŠ‚ç‚¹çš„Rediså®¢æˆ·ç«¯
    return this.redisClients.get(node)!;
  }
}
```

### 5. ç¼“å­˜ç›‘æ§ä¸è¿ç»´

#### 5.1 ç¼“å­˜ç›‘æ§æŒ‡æ ‡

##### 5.1.1 æ€§èƒ½ç›‘æ§
```typescript
// ç¼“å­˜æ€§èƒ½ç›‘æ§
class CacheMonitoringService {
  private metrics = {
    hitRate: 0,
    missRate: 0,
    avgResponseTime: 0,
    errorRate: 0,
    memoryUsage: 0,
    connectionCount: 0
  };
  
  async collectMetrics() {
    const redisInfo = await this.redis.info();
    const stats = this.parseRedisInfo(redisInfo);
    
    this.metrics = {
      hitRate: this.calculateHitRate(stats),
      missRate: this.calculateMissRate(stats),
      avgResponseTime: await this.measureResponseTime(),
      errorRate: this.calculateErrorRate(),
      memoryUsage: stats.used_memory / stats.maxmemory * 100,
      connectionCount: stats.connected_clients
    };
    
    // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
    await this.sendToPrometheus(this.metrics);
    
    // æ£€æŸ¥å‘Šè­¦æ¡ä»¶
    await this.checkAlerts();
    
    return this.metrics;
  }
  
  private calculateHitRate(stats: any): number {
    const hits = stats.keyspace_hits || 0;
    const misses = stats.keyspace_misses || 0;
    const total = hits + misses;
    return total > 0 ? (hits / total) * 100 : 0;
  }
  
  private async measureResponseTime(): Promise<number> {
    const start = Date.now();
    await this.redis.ping();
    return Date.now() - start;
  }
  
  private async checkAlerts() {
    // å‘½ä¸­ç‡è¿‡ä½å‘Šè­¦
    if (this.metrics.hitRate < 80) {
      await this.sendAlert('ç¼“å­˜å‘½ä¸­ç‡è¿‡ä½', this.metrics.hitRate);
    }
    
    // å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜å‘Šè­¦
    if (this.metrics.memoryUsage > 85) {
      await this.sendAlert('ç¼“å­˜å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜', this.metrics.memoryUsage);
    }
    
    // å“åº”æ—¶é—´è¿‡é•¿å‘Šè­¦
    if (this.metrics.avgResponseTime > 100) {
      await this.sendAlert('ç¼“å­˜å“åº”æ—¶é—´è¿‡é•¿', this.metrics.avgResponseTime);
    }
    
    // é”™è¯¯ç‡è¿‡é«˜å‘Šè­¦
    if (this.metrics.errorRate > 5) {
      await this.sendAlert('ç¼“å­˜é”™è¯¯ç‡è¿‡é«˜', this.metrics.errorRate);
    }
  }
}
```

##### 5.1.2 ä¸šåŠ¡ç›‘æ§
```typescript
// ä¸šåŠ¡ç¼“å­˜ç›‘æ§
class BusinessCacheMonitoring {
  async monitorCacheUsage() {
    const cacheUsage = {
      userCache: await this.analyzeUserCacheUsage(),
      productCache: await this.analyzeProductCacheUsage(),
      orderCache: await this.analyzeOrderCacheUsage(),
      configCache: await this.analyzeConfigCacheUsage()
    };
    
    // ç”Ÿæˆç¼“å­˜ä½¿ç”¨æŠ¥å‘Š
    await this.generateCacheReport(cacheUsage);
    
    return cacheUsage;
  }
  
  private async analyzeUserCacheUsage() {
    const userKeys = await this.redis.keys('user:*');
    const analysis = {
      totalKeys: userKeys.length,
      profileKeys: userKeys.filter(key => key.includes(':profile:')).length,
      sessionKeys: userKeys.filter(key => key.includes(':session:')).length,
      permissionKeys: userKeys.filter(key => key.includes(':permissions:')).length,
      avgTTL: 0,
      memoryUsage: 0
    };
    
    // è®¡ç®—å¹³å‡TTLå’Œå†…å­˜ä½¿ç”¨
    let totalTTL = 0;
    let totalMemory = 0;
    
    for (const key of userKeys.slice(0, 100)) { // é‡‡æ ·å‰100ä¸ªkey
      const ttl = await this.redis.ttl(key);
      const memory = await this.redis.memory('usage', key);
      
      if (ttl > 0) totalTTL += ttl;
      if (memory > 0) totalMemory += memory;
    }
    
    analysis.avgTTL = totalTTL / Math.min(userKeys.length, 100);
    analysis.memoryUsage = totalMemory;
    
    return analysis;
  }
  
  private async generateCacheReport(cacheUsage: any) {
    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        totalKeys: Object.values(cacheUsage).reduce((sum: number, cache: any) => sum + cache.totalKeys, 0),
        totalMemory: Object.values(cacheUsage).reduce((sum: number, cache: any) => sum + cache.memoryUsage, 0),
        avgHitRate: this.metrics.hitRate
      },
      details: cacheUsage,
      recommendations: this.generateRecommendations(cacheUsage)
    };
    
    // ä¿å­˜æŠ¥å‘Š
    await this.saveReport(report);
    
    return report;
  }
  
  private generateRecommendations(cacheUsage: any): string[] {
    const recommendations = [];
    
    // åŸºäºç¼“å­˜ä½¿ç”¨æƒ…å†µç”Ÿæˆå»ºè®®
    if (this.metrics.hitRate < 80) {
      recommendations.push('å»ºè®®ä¼˜åŒ–ç¼“å­˜ç­–ç•¥ï¼Œæé«˜å‘½ä¸­ç‡');
    }
    
    if (this.metrics.memoryUsage > 80) {
      recommendations.push('å»ºè®®å¢åŠ ç¼“å­˜å®¹é‡æˆ–ä¼˜åŒ–TTLè®¾ç½®');
    }
    
    if (cacheUsage.userCache.totalKeys > 10000) {
      recommendations.push('ç”¨æˆ·ç¼“å­˜æ•°é‡è¾ƒå¤šï¼Œå»ºè®®å®æ–½ç¼“å­˜æ¸…ç†ç­–ç•¥');
    }
    
    return recommendations;
  }
}
```

#### 5.2 ç¼“å­˜è¿ç»´å·¥å…·

##### 5.2.1 ç¼“å­˜ç®¡ç†å·¥å…·
```typescript
// ç¼“å­˜ç®¡ç†å·¥å…·
class CacheManagementTool {
  // æ‰¹é‡æ¸…ç†è¿‡æœŸç¼“å­˜
  async cleanupExpiredCache() {
    const patterns = [
      'user:*',
      'product:*',
      'order:*',
      'session:*'
    ];
    
    let totalCleaned = 0;
    
    for (const pattern of patterns) {
      const keys = await this.redis.keys(pattern);
      const expiredKeys = [];
      
      for (const key of keys) {
        const ttl = await this.redis.ttl(key);
        if (ttl === -1) { // æ²¡æœ‰è®¾ç½®è¿‡æœŸæ—¶é—´çš„key
          expiredKeys.push(key);
        }
      }
      
      if (expiredKeys.length > 0) {
        await this.redis.del(...expiredKeys);
        totalCleaned += expiredKeys.length;
      }
    }
    
    console.log(`æ¸…ç†äº† ${totalCleaned} ä¸ªè¿‡æœŸç¼“å­˜`);
    return totalCleaned;
  }
  
  // ç¼“å­˜æ•°æ®è¿ç§»
  async migrateCacheData(sourceRedis: Redis, targetRedis: Redis, pattern: string) {
    const keys = await sourceRedis.keys(pattern);
    let migratedCount = 0;
    
    for (const key of keys) {
      try {
        const [value, ttl] = await Promise.all([
          sourceRedis.get(key),
          sourceRedis.ttl(key)
        ]);
        
        if (value) {
          if (ttl > 0) {
            await targetRedis.setex(key, ttl, value);
          } else {
            await targetRedis.set(key, value);
          }
          migratedCount++;
        }
      } catch (error) {
        console.error(`è¿ç§»ç¼“å­˜å¤±è´¥: ${key}`, error);
      }
    }
    
    console.log(`è¿ç§»äº† ${migratedCount} ä¸ªç¼“å­˜æ•°æ®`);
    return migratedCount;
  }
  
  // ç¼“å­˜æ•°æ®å¤‡ä»½
  async backupCacheData(pattern: string): Promise<string> {
    const keys = await this.redis.keys(pattern);
    const backup = {
      timestamp: new Date().toISOString(),
      pattern,
      data: {} as Record<string, { value: string; ttl: number }>
    };
    
    for (const key of keys) {
      try {
        const [value, ttl] = await Promise.all([
          this.redis.get(key),
          this.redis.ttl(key)
        ]);
        
        if (value) {
          backup.data[key] = { value, ttl };
        }
      } catch (error) {
        console.error(`å¤‡ä»½ç¼“å­˜å¤±è´¥: ${key}`, error);
      }
    }
    
    // ä¿å­˜å¤‡ä»½æ–‡ä»¶
    const backupFile = `cache_backup_${Date.now()}.json`;
    await fs.writeFile(backupFile, JSON.stringify(backup, null, 2));
    
    console.log(`ç¼“å­˜å¤‡ä»½å®Œæˆ: ${backupFile}`);
    return backupFile;
  }
  
  // ä»å¤‡ä»½æ¢å¤ç¼“å­˜
  async restoreCacheData(backupFile: string) {
    const backupContent = await fs.readFile(backupFile, 'utf-8');
    const backup = JSON.parse(backupContent);
    
    let restoredCount = 0;
    
    for (const [key, data] of Object.entries(backup.data)) {
      try {
        const { value, ttl } = data as { value: string; ttl: number };
        
        if (ttl > 0) {
          await this.redis.setex(key, ttl, value);
        } else {
          await this.redis.set(key, value);
        }
        restoredCount++;
      } catch (error) {
        console.error(`æ¢å¤ç¼“å­˜å¤±è´¥: ${key}`, error);
      }
    }
    
    console.log(`æ¢å¤äº† ${restoredCount} ä¸ªç¼“å­˜æ•°æ®`);
    return restoredCount;
  }
}
```

---

## ğŸ“Š æ€»ç»“

æœ¬ç¼“å­˜æ¶æ„è®¾è®¡æ–‡æ¡£ä¸ºç½—è±L2Cé”€å”®ç®¡ç†ç³»ç»Ÿæä¾›äº†å®Œæ•´çš„ç¼“å­˜è§£å†³æ–¹æ¡ˆï¼Œè§£å†³äº†ç³»ç»Ÿä¸­ç¼“å­˜ç­–ç•¥ä¸ä¸€è‡´å’Œæ•°æ®ä¸€è‡´æ€§é£é™©çš„é—®é¢˜ã€‚

### ğŸ¯ æ ¸å¿ƒä»·å€¼

1. **ç»Ÿä¸€æ¶æ„**ï¼šå»ºç«‹äº†åˆ†å±‚ç¼“å­˜æ¶æ„ï¼Œæ˜ç¡®äº†ä¸åŒå±‚çº§çš„èŒè´£å’Œä½¿ç”¨åœºæ™¯
2. **æ•°æ®ä¸€è‡´æ€§**ï¼šé€šè¿‡å¤šç§ç¼“å­˜æ›´æ–°ç­–ç•¥å’Œå¤±æ•ˆæœºåˆ¶ï¼Œç¡®ä¿æ•°æ®ä¸€è‡´æ€§
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šé€šè¿‡ç¼“å­˜é¢„çƒ­ã€å‹ç¼©ã€åˆ†ç‰‡ç­‰ç­–ç•¥ï¼Œæ˜¾è‘—æå‡ç³»ç»Ÿæ€§èƒ½
4. **è¿ç»´å‹å¥½**ï¼šæä¾›å®Œå–„çš„ç›‘æ§æŒ‡æ ‡å’Œç®¡ç†å·¥å…·ï¼Œä¾¿äºè¿ç»´ç®¡ç†

### ğŸš€ è®¾è®¡äº®ç‚¹

- **åˆ†å±‚è®¾è®¡**ï¼šL1æœ¬åœ°ç¼“å­˜ + L2åˆ†å¸ƒå¼ç¼“å­˜ + L3æŒä¹…åŒ–ç¼“å­˜
- **å¤šç§ç­–ç•¥**ï¼šCache-Asideã€Write-Throughã€Write-Behindç­‰æ›´æ–°ç­–ç•¥
- **æ™ºèƒ½å¤±æ•ˆ**ï¼šåŸºäºäº‹ä»¶å’Œç‰ˆæœ¬çš„ç¼“å­˜å¤±æ•ˆæœºåˆ¶
- **æ€§èƒ½ä¼˜åŒ–**ï¼šé¢„çƒ­ã€å‹ç¼©ã€åˆ†ç‰‡ç­‰å¤šé‡ä¼˜åŒ–ç­–ç•¥
- **å®Œå–„ç›‘æ§**ï¼šæ€§èƒ½ç›‘æ§ã€ä¸šåŠ¡ç›‘æ§ã€å‘Šè­¦æœºåˆ¶

è¯¥ç¼“å­˜æ¶æ„è®¾è®¡ä¸ºL2Cé”€å”®ç®¡ç†ç³»ç»Ÿæä¾›äº†é«˜æ€§èƒ½ã€é«˜å¯ç”¨ã€æ˜“ç»´æŠ¤çš„ç¼“å­˜æœåŠ¡ï¼Œæ˜¾è‘—æå‡äº†ç³»ç»Ÿçš„æ•´ä½“æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒã€‚
