# ç½—è±L2Cé”€å”®ç®¡ç†ç³»ç»Ÿ - æœç´¢å¼•æ“è®¾è®¡

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

**é¡¹ç›®åç§°ï¼š** ç½—è±L2Cé”€å”®ç®¡ç†ç³»ç»Ÿæœç´¢å¼•æ“è®¾è®¡  
**æ–‡æ¡£ç‰ˆæœ¬ï¼š** v1.0  
**åˆ›å»ºæ—¥æœŸï¼š** 2024å¹´  
**è®¾è®¡ç›®æ ‡ï¼š** æ„å»ºç»Ÿä¸€ã€æ™ºèƒ½ã€é«˜æ•ˆçš„æœç´¢å¼•æ“ï¼Œæä¾›å…¨æ–¹ä½çš„æœç´¢æœåŠ¡  

---

## ğŸ¯ è®¾è®¡ç›®æ ‡ä¸ä»·å€¼

### 1. æ ¸å¿ƒé—®é¢˜è§£å†³
- **æœç´¢åŠŸèƒ½ç¼ºå¤±**ï¼šå„æ¨¡å—ç¼ºä¹ç»Ÿä¸€çš„æœç´¢èƒ½åŠ›
- **æœç´¢ä½“éªŒå·®**ï¼šç®€å•çš„æ•°æ®åº“æŸ¥è¯¢æ— æ³•æ»¡è¶³å¤æ‚æœç´¢éœ€æ±‚
- **æ€§èƒ½ç“¶é¢ˆ**ï¼šå¤§é‡æ•°æ®æŸ¥è¯¢å¯¼è‡´æ•°æ®åº“å‹åŠ›è¿‡å¤§
- **æœç´¢ç²¾åº¦ä½**ï¼šç¼ºä¹æ™ºèƒ½æœç´¢å’Œç›¸å…³æ€§æ’åº

### 2. ä¸šåŠ¡ä»·å€¼
- **ç”¨æˆ·ä½“éªŒæå‡**ï¼šæä¾›å¿«é€Ÿã€å‡†ç¡®ã€æ™ºèƒ½çš„æœç´¢ä½“éªŒ
- **ä¸šåŠ¡æ•ˆç‡æå‡**ï¼šå¸®åŠ©ç”¨æˆ·å¿«é€Ÿæ‰¾åˆ°æ‰€éœ€ä¿¡æ¯ï¼Œæé«˜å·¥ä½œæ•ˆç‡
- **æ•°æ®ä»·å€¼æŒ–æ˜**ï¼šé€šè¿‡æœç´¢åˆ†æç”¨æˆ·è¡Œä¸ºï¼ŒæŒ–æ˜ä¸šåŠ¡ä»·å€¼
- **ç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–**ï¼šå‡å°‘æ•°æ®åº“æŸ¥è¯¢å‹åŠ›ï¼Œæå‡ç³»ç»Ÿæ•´ä½“æ€§èƒ½

### 3. æŠ€æœ¯ç›®æ ‡
- **å…¨æ–‡æœç´¢**ï¼šæ”¯æŒä¸­æ–‡åˆ†è¯ã€æ¨¡ç³ŠåŒ¹é…ã€åŒä¹‰è¯æœç´¢
- **å¤šç»´æœç´¢**ï¼šæ”¯æŒå¤šå­—æ®µã€å¤šæ¡ä»¶ã€èŒƒå›´æœç´¢
- **å®æ—¶æœç´¢**ï¼šæ”¯æŒæœç´¢å»ºè®®ã€è‡ªåŠ¨è¡¥å…¨ã€å®æ—¶ç»“æœ
- **æ™ºèƒ½æ’åº**ï¼šåŸºäºç›¸å…³æ€§ã€æƒé‡ã€ç”¨æˆ·è¡Œä¸ºçš„æ™ºèƒ½æ’åº

---

## ğŸ—ï¸ æœç´¢å¼•æ“æ¶æ„è®¾è®¡

### 1. æ•´ä½“æ¶æ„

#### 1.1 æœç´¢å¼•æ“æ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç”¨æˆ·å±‚ (User Layer)                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Webå‰ç«¯    â”‚ â”‚  ç§»åŠ¨ç«¯APP  â”‚ â”‚  ç®¡ç†åå°   â”‚ â”‚ APIæ¥å£ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æ¥å…¥å±‚ (Gateway Layer)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                   æœç´¢ç½‘å…³æœåŠ¡                          â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚ â”‚
â”‚  â”‚  â”‚ è¯·æ±‚è·¯ç”±    â”‚ â”‚ æƒé™éªŒè¯    â”‚ â”‚ é™æµæ§åˆ¶    â”‚       â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æœåŠ¡å±‚ (Service Layer)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                   æœç´¢æœåŠ¡é›†ç¾¤                          â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚ â”‚
â”‚  â”‚  â”‚ æŸ¥è¯¢æœåŠ¡    â”‚ â”‚ ç´¢å¼•æœåŠ¡    â”‚ â”‚ åˆ†ææœåŠ¡    â”‚       â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                   ä¸šåŠ¡æœç´¢æœåŠ¡                          â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚ â”‚
â”‚  â”‚  â”‚ äº§å“æœç´¢    â”‚ â”‚ è®¢å•æœç´¢    â”‚ â”‚ ç”¨æˆ·æœç´¢    â”‚       â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    å¼•æ“å±‚ (Engine Layer)                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                 Elasticsearché›†ç¾¤                      â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚ â”‚
â”‚  â”‚  â”‚ ä¸»èŠ‚ç‚¹      â”‚ â”‚ æ•°æ®èŠ‚ç‚¹    â”‚ â”‚ åè°ƒèŠ‚ç‚¹    â”‚       â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æ•°æ®å±‚ (Data Layer)                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ PostgreSQL  â”‚ â”‚   MongoDB   â”‚ â”‚   Redis     â”‚ â”‚ æ–‡ä»¶å­˜å‚¨â”‚ â”‚
â”‚  â”‚   (ä¸»æ•°æ®)  â”‚ â”‚  (æ—¥å¿—æ•°æ®) â”‚ â”‚  (ç¼“å­˜æ•°æ®) â”‚ â”‚ (é™„ä»¶)  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 1.2 æŠ€æœ¯é€‰å‹

| ç»„ä»¶ | æŠ€æœ¯æ–¹æ¡ˆ | ç”¨é€” | ç‰¹ç‚¹ |
|------|---------|------|------|
| **æœç´¢å¼•æ“** | Elasticsearch 8.x | å…¨æ–‡æœç´¢ã€æ•°æ®åˆ†æ | åˆ†å¸ƒå¼ã€é«˜æ€§èƒ½ã€å®æ—¶æœç´¢ |
| **ä¸­æ–‡åˆ†è¯** | IK Analyzer | ä¸­æ–‡æ–‡æœ¬åˆ†è¯ | æ”¯æŒè‡ªå®šä¹‰è¯å…¸ã€æ™ºèƒ½åˆ†è¯ |
| **æ•°æ®åŒæ­¥** | Logstash + Canal | æ•°æ®å®æ—¶åŒæ­¥ | æ”¯æŒå¤šæ•°æ®æºã€å®æ—¶åŒæ­¥ |
| **æœç´¢ç¼“å­˜** | Redis | çƒ­é—¨æœç´¢ç¼“å­˜ | é«˜æ€§èƒ½ã€æ”¯æŒè¿‡æœŸç­–ç•¥ |
| **æ¶ˆæ¯é˜Ÿåˆ—** | RabbitMQ | å¼‚æ­¥ç´¢å¼•æ›´æ–° | å¯é æ¶ˆæ¯ä¼ é€’ã€å‰Šå³°å¡«è°· |

### 2. æœç´¢åŠŸèƒ½è®¾è®¡

#### 2.1 äº§å“æœç´¢åŠŸèƒ½

##### 2.1.1 äº§å“ç´¢å¼•ç»“æ„
```json
{
  "mappings": {
    "properties": {
      "id": {
        "type": "keyword"
      },
      "name": {
        "type": "text",
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart",
        "fields": {
          "keyword": {
            "type": "keyword"
          },
          "pinyin": {
            "type": "text",
            "analyzer": "pinyin_analyzer"
          }
        }
      },
      "description": {
        "type": "text",
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart"
      },
      "category": {
        "type": "nested",
        "properties": {
          "id": { "type": "keyword" },
          "name": { "type": "keyword" },
          "level": { "type": "integer" }
        }
      },
      "brand": {
        "type": "keyword"
      },
      "price": {
        "type": "double"
      },
      "stock": {
        "type": "integer"
      },
      "status": {
        "type": "keyword"
      },
      "tags": {
        "type": "keyword"
      },
      "attributes": {
        "type": "nested",
        "properties": {
          "name": { "type": "keyword" },
          "value": { "type": "keyword" }
        }
      },
      "sales_count": {
        "type": "integer"
      },
      "rating": {
        "type": "float"
      },
      "created_at": {
        "type": "date"
      },
      "updated_at": {
        "type": "date"
      },
      "search_keywords": {
        "type": "text",
        "analyzer": "ik_max_word"
      },
      "popularity_score": {
        "type": "float"
      }
    }
  }
}
```

##### 2.1.2 äº§å“æœç´¢æœåŠ¡
```typescript
// äº§å“æœç´¢æœåŠ¡
class ProductSearchService {
  private esClient: Client;
  private indexName = 'products';
  
  constructor(esClient: Client) {
    this.esClient = esClient;
  }
  
  // ç»¼åˆæœç´¢
  async search(params: ProductSearchParams): Promise<ProductSearchResult> {
    const query = this.buildSearchQuery(params);
    
    const response = await this.esClient.search({
      index: this.indexName,
      body: {
        query,
        sort: this.buildSortQuery(params.sort),
        aggs: this.buildAggregations(),
        highlight: this.buildHighlight(),
        from: (params.page - 1) * params.size,
        size: params.size
      }
    });
    
    return this.formatSearchResult(response);
  }
  
  // æ„å»ºæœç´¢æŸ¥è¯¢
  private buildSearchQuery(params: ProductSearchParams) {
    const must = [];
    const filter = [];
    const should = [];
    
    // å…³é”®è¯æœç´¢
    if (params.keyword) {
      must.push({
        multi_match: {
          query: params.keyword,
          fields: [
            'name^3',           // äº§å“åç§°æƒé‡æœ€é«˜
            'name.pinyin^2',    // æ‹¼éŸ³æœç´¢
            'description^1',    // æè¿°
            'search_keywords^2', // æœç´¢å…³é”®è¯
            'brand^2'           // å“ç‰Œ
          ],
          type: 'best_fields',
          fuzziness: 'AUTO',
          prefix_length: 1
        }
      });
      
      // ç²¾ç¡®åŒ¹é…åŠ åˆ†
      should.push({
        term: {
          'name.keyword': {
            value: params.keyword,
            boost: 5
          }
        }
      });
    }
    
    // åˆ†ç±»ç­›é€‰
    if (params.categoryId) {
      filter.push({
        nested: {
          path: 'category',
          query: {
            term: { 'category.id': params.categoryId }
          }
        }
      });
    }
    
    // å“ç‰Œç­›é€‰
    if (params.brands && params.brands.length > 0) {
      filter.push({
        terms: { brand: params.brands }
      });
    }
    
    // ä»·æ ¼èŒƒå›´ç­›é€‰
    if (params.priceRange) {
      const priceFilter: any = { range: { price: {} } };
      if (params.priceRange.min !== undefined) {
        priceFilter.range.price.gte = params.priceRange.min;
      }
      if (params.priceRange.max !== undefined) {
        priceFilter.range.price.lte = params.priceRange.max;
      }
      filter.push(priceFilter);
    }
    
    // å±æ€§ç­›é€‰
    if (params.attributes && params.attributes.length > 0) {
      params.attributes.forEach(attr => {
        filter.push({
          nested: {
            path: 'attributes',
            query: {
              bool: {
                must: [
                  { term: { 'attributes.name': attr.name } },
                  { terms: { 'attributes.value': attr.values } }
                ]
              }
            }
          }
        });
      });
    }
    
    // åº“å­˜ç­›é€‰
    if (params.inStock) {
      filter.push({
        range: { stock: { gt: 0 } }
      });
    }
    
    // çŠ¶æ€ç­›é€‰
    filter.push({
      term: { status: 'active' }
    });
    
    return {
      bool: {
        must,
        filter,
        should,
        minimum_should_match: should.length > 0 ? 1 : 0
      }
    };
  }
  
  // æ„å»ºæ’åºæŸ¥è¯¢
  private buildSortQuery(sort?: string) {
    const sortOptions = {
      relevance: [{ _score: { order: 'desc' } }],
      price_asc: [{ price: { order: 'asc' } }, { _score: { order: 'desc' } }],
      price_desc: [{ price: { order: 'desc' } }, { _score: { order: 'desc' } }],
      sales: [{ sales_count: { order: 'desc' } }, { _score: { order: 'desc' } }],
      rating: [{ rating: { order: 'desc' } }, { _score: { order: 'desc' } }],
      newest: [{ created_at: { order: 'desc' } }, { _score: { order: 'desc' } }],
      popularity: [{ popularity_score: { order: 'desc' } }, { _score: { order: 'desc' } }]
    };
    
    return sortOptions[sort || 'relevance'] || sortOptions.relevance;
  }
  
  // æ„å»ºèšåˆæŸ¥è¯¢
  private buildAggregations() {
    return {
      categories: {
        nested: { path: 'category' },
        aggs: {
          category_names: {
            terms: {
              field: 'category.name',
              size: 20
            }
          }
        }
      },
      brands: {
        terms: {
          field: 'brand',
          size: 20
        }
      },
      price_ranges: {
        range: {
          field: 'price',
          ranges: [
            { to: 100 },
            { from: 100, to: 500 },
            { from: 500, to: 1000 },
            { from: 1000, to: 5000 },
            { from: 5000 }
          ]
        }
      },
      attributes: {
        nested: { path: 'attributes' },
        aggs: {
          attribute_names: {
            terms: {
              field: 'attributes.name',
              size: 10
            },
            aggs: {
              attribute_values: {
                terms: {
                  field: 'attributes.value',
                  size: 20
                }
              }
            }
          }
        }
      }
    };
  }
  
  // æ„å»ºé«˜äº®æŸ¥è¯¢
  private buildHighlight() {
    return {
      fields: {
        name: {
          pre_tags: ['<em class="highlight">'],
          post_tags: ['</em>'],
          fragment_size: 100
        },
        description: {
          pre_tags: ['<em class="highlight">'],
          post_tags: ['</em>'],
          fragment_size: 200,
          number_of_fragments: 2
        }
      }
    };
  }
  
  // æœç´¢å»ºè®®
  async suggest(keyword: string): Promise<string[]> {
    const response = await this.esClient.search({
      index: this.indexName,
      body: {
        suggest: {
          product_suggest: {
            prefix: keyword,
            completion: {
              field: 'suggest',
              size: 10,
              skip_duplicates: true
            }
          }
        }
      }
    });
    
    return response.body.suggest.product_suggest[0].options.map(
      (option: any) => option.text
    );
  }
  
  // çƒ­é—¨æœç´¢è¯
  async getHotKeywords(limit: number = 10): Promise<string[]> {
    // ä»Redisç¼“å­˜è·å–çƒ­é—¨æœç´¢è¯
    const cacheKey = 'search:hot_keywords';
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached).slice(0, limit);
    }
    
    // ä»æœç´¢æ—¥å¿—åˆ†æçƒ­é—¨è¯
    const hotKeywords = await this.analyzeHotKeywords();
    
    // ç¼“å­˜ç»“æœ
    await this.redis.setex(cacheKey, 3600, JSON.stringify(hotKeywords));
    
    return hotKeywords.slice(0, limit);
  }
}
```

#### 2.2 è®¢å•æœç´¢åŠŸèƒ½

##### 2.2.1 è®¢å•ç´¢å¼•ç»“æ„
```json
{
  "mappings": {
    "properties": {
      "id": {
        "type": "keyword"
      },
      "order_no": {
        "type": "keyword"
      },
      "user_id": {
        "type": "keyword"
      },
      "user_name": {
        "type": "text",
        "analyzer": "ik_max_word",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      },
      "user_phone": {
        "type": "keyword"
      },
      "status": {
        "type": "keyword"
      },
      "total_amount": {
        "type": "double"
      },
      "payment_method": {
        "type": "keyword"
      },
      "shipping_address": {
        "type": "text",
        "analyzer": "ik_max_word"
      },
      "products": {
        "type": "nested",
        "properties": {
          "id": { "type": "keyword" },
          "name": { "type": "text", "analyzer": "ik_max_word" },
          "sku": { "type": "keyword" },
          "quantity": { "type": "integer" },
          "price": { "type": "double" }
        }
      },
      "created_at": {
        "type": "date"
      },
      "updated_at": {
        "type": "date"
      },
      "tags": {
        "type": "keyword"
      }
    }
  }
}
```

##### 2.2.2 è®¢å•æœç´¢æœåŠ¡
```typescript
// è®¢å•æœç´¢æœåŠ¡
class OrderSearchService {
  private esClient: Client;
  private indexName = 'orders';
  
  // è®¢å•æœç´¢
  async search(params: OrderSearchParams): Promise<OrderSearchResult> {
    const query = this.buildOrderSearchQuery(params);
    
    const response = await this.esClient.search({
      index: this.indexName,
      body: {
        query,
        sort: this.buildOrderSortQuery(params.sort),
        aggs: this.buildOrderAggregations(),
        from: (params.page - 1) * params.size,
        size: params.size
      }
    });
    
    return this.formatOrderSearchResult(response);
  }
  
  private buildOrderSearchQuery(params: OrderSearchParams) {
    const must = [];
    const filter = [];
    
    // å…³é”®è¯æœç´¢ï¼ˆè®¢å•å·ã€ç”¨æˆ·åã€æ‰‹æœºå·ã€äº§å“åç§°ï¼‰
    if (params.keyword) {
      must.push({
        multi_match: {
          query: params.keyword,
          fields: [
            'order_no^3',
            'user_name^2',
            'user_phone^2',
            'products.name',
            'products.sku^2'
          ],
          type: 'best_fields',
          fuzziness: 'AUTO'
        }
      });
    }
    
    // è®¢å•çŠ¶æ€ç­›é€‰
    if (params.status && params.status.length > 0) {
      filter.push({
        terms: { status: params.status }
      });
    }
    
    // ç”¨æˆ·ç­›é€‰
    if (params.userId) {
      filter.push({
        term: { user_id: params.userId }
      });
    }
    
    // é‡‘é¢èŒƒå›´ç­›é€‰
    if (params.amountRange) {
      const amountFilter: any = { range: { total_amount: {} } };
      if (params.amountRange.min !== undefined) {
        amountFilter.range.total_amount.gte = params.amountRange.min;
      }
      if (params.amountRange.max !== undefined) {
        amountFilter.range.total_amount.lte = params.amountRange.max;
      }
      filter.push(amountFilter);
    }
    
    // æ—¶é—´èŒƒå›´ç­›é€‰
    if (params.dateRange) {
      const dateFilter: any = { range: { created_at: {} } };
      if (params.dateRange.start) {
        dateFilter.range.created_at.gte = params.dateRange.start;
      }
      if (params.dateRange.end) {
        dateFilter.range.created_at.lte = params.dateRange.end;
      }
      filter.push(dateFilter);
    }
    
    // æ”¯ä»˜æ–¹å¼ç­›é€‰
    if (params.paymentMethods && params.paymentMethods.length > 0) {
      filter.push({
        terms: { payment_method: params.paymentMethods }
      });
    }
    
    return {
      bool: {
        must,
        filter
      }
    };
  }
  
  private buildOrderSortQuery(sort?: string) {
    const sortOptions = {
      newest: [{ created_at: { order: 'desc' } }],
      oldest: [{ created_at: { order: 'asc' } }],
      amount_desc: [{ total_amount: { order: 'desc' } }],
      amount_asc: [{ total_amount: { order: 'asc' } }],
      relevance: [{ _score: { order: 'desc' } }]
    };
    
    return sortOptions[sort || 'newest'] || sortOptions.newest;
  }
  
  private buildOrderAggregations() {
    return {
      status_stats: {
        terms: {
          field: 'status',
          size: 10
        }
      },
      payment_method_stats: {
        terms: {
          field: 'payment_method',
          size: 10
        }
      },
      amount_ranges: {
        range: {
          field: 'total_amount',
          ranges: [
            { to: 100 },
            { from: 100, to: 500 },
            { from: 500, to: 1000 },
            { from: 1000, to: 5000 },
            { from: 5000 }
          ]
        }
      },
      daily_orders: {
        date_histogram: {
          field: 'created_at',
          calendar_interval: 'day',
          format: 'yyyy-MM-dd'
        }
      }
    };
  }
}
```

#### 2.3 ç”¨æˆ·æœç´¢åŠŸèƒ½

##### 2.3.1 ç”¨æˆ·ç´¢å¼•ç»“æ„
```json
{
  "mappings": {
    "properties": {
      "id": {
        "type": "keyword"
      },
      "username": {
        "type": "keyword"
      },
      "real_name": {
        "type": "text",
        "analyzer": "ik_max_word",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      },
      "phone": {
        "type": "keyword"
      },
      "email": {
        "type": "keyword"
      },
      "level": {
        "type": "keyword"
      },
      "status": {
        "type": "keyword"
      },
      "registration_date": {
        "type": "date"
      },
      "last_login": {
        "type": "date"
      },
      "total_orders": {
        "type": "integer"
      },
      "total_amount": {
        "type": "double"
      },
      "points": {
        "type": "integer"
      },
      "tags": {
        "type": "keyword"
      },
      "region": {
        "type": "nested",
        "properties": {
          "province": { "type": "keyword" },
          "city": { "type": "keyword" },
          "district": { "type": "keyword" }
        }
      }
    }
  }
}
```

##### 2.3.2 ç”¨æˆ·æœç´¢æœåŠ¡
```typescript
// ç”¨æˆ·æœç´¢æœåŠ¡
class UserSearchService {
  private esClient: Client;
  private indexName = 'users';
  
  // ç”¨æˆ·æœç´¢
  async search(params: UserSearchParams): Promise<UserSearchResult> {
    const query = this.buildUserSearchQuery(params);
    
    const response = await this.esClient.search({
      index: this.indexName,
      body: {
        query,
        sort: this.buildUserSortQuery(params.sort),
        aggs: this.buildUserAggregations(),
        from: (params.page - 1) * params.size,
        size: params.size
      }
    });
    
    return this.formatUserSearchResult(response);
  }
  
  private buildUserSearchQuery(params: UserSearchParams) {
    const must = [];
    const filter = [];
    
    // å…³é”®è¯æœç´¢ï¼ˆç”¨æˆ·åã€çœŸå®å§“åã€æ‰‹æœºå·ã€é‚®ç®±ï¼‰
    if (params.keyword) {
      must.push({
        multi_match: {
          query: params.keyword,
          fields: [
            'username^3',
            'real_name^2',
            'phone^2',
            'email'
          ],
          type: 'best_fields',
          fuzziness: 'AUTO'
        }
      });
    }
    
    // ç”¨æˆ·ç­‰çº§ç­›é€‰
    if (params.levels && params.levels.length > 0) {
      filter.push({
        terms: { level: params.levels }
      });
    }
    
    // ç”¨æˆ·çŠ¶æ€ç­›é€‰
    if (params.status && params.status.length > 0) {
      filter.push({
        terms: { status: params.status }
      });
    }
    
    // æ³¨å†Œæ—¶é—´èŒƒå›´ç­›é€‰
    if (params.registrationDateRange) {
      const dateFilter: any = { range: { registration_date: {} } };
      if (params.registrationDateRange.start) {
        dateFilter.range.registration_date.gte = params.registrationDateRange.start;
      }
      if (params.registrationDateRange.end) {
        dateFilter.range.registration_date.lte = params.registrationDateRange.end;
      }
      filter.push(dateFilter);
    }
    
    // æ¶ˆè´¹é‡‘é¢èŒƒå›´ç­›é€‰
    if (params.totalAmountRange) {
      const amountFilter: any = { range: { total_amount: {} } };
      if (params.totalAmountRange.min !== undefined) {
        amountFilter.range.total_amount.gte = params.totalAmountRange.min;
      }
      if (params.totalAmountRange.max !== undefined) {
        amountFilter.range.total_amount.lte = params.totalAmountRange.max;
      }
      filter.push(amountFilter);
    }
    
    // åœ°åŒºç­›é€‰
    if (params.region) {
      const regionFilters = [];
      if (params.region.province) {
        regionFilters.push({
          nested: {
            path: 'region',
            query: {
              term: { 'region.province': params.region.province }
            }
          }
        });
      }
      if (params.region.city) {
        regionFilters.push({
          nested: {
            path: 'region',
            query: {
              term: { 'region.city': params.region.city }
            }
          }
        });
      }
      filter.push(...regionFilters);
    }
    
    return {
      bool: {
        must,
        filter
      }
    };
  }
}
```

### 3. æœç´¢æ™ºèƒ½åŒ–åŠŸèƒ½

#### 3.1 æœç´¢å»ºè®®ä¸è‡ªåŠ¨è¡¥å…¨

##### 3.1.1 æœç´¢å»ºè®®æœåŠ¡
```typescript
// æœç´¢å»ºè®®æœåŠ¡
class SearchSuggestionService {
  private esClient: Client;
  private redis: Redis;
  
  // è·å–æœç´¢å»ºè®®
  async getSuggestions(keyword: string, type: string = 'all'): Promise<SearchSuggestion[]> {
    const suggestions = [];
    
    // ä»ç¼“å­˜è·å–
    const cacheKey = `suggestions:${type}:${keyword}`;
    const cached = await this.redis.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }
    
    // æ ¹æ®ç±»å‹è·å–ä¸åŒçš„å»ºè®®
    switch (type) {
      case 'product':
        suggestions.push(...await this.getProductSuggestions(keyword));
        break;
      case 'brand':
        suggestions.push(...await this.getBrandSuggestions(keyword));
        break;
      case 'category':
        suggestions.push(...await this.getCategorySuggestions(keyword));
        break;
      default:
        suggestions.push(
          ...await this.getProductSuggestions(keyword),
          ...await this.getBrandSuggestions(keyword),
          ...await this.getCategorySuggestions(keyword)
        );
    }
    
    // æŒ‰ç›¸å…³æ€§æ’åº
    const sortedSuggestions = suggestions
      .sort((a, b) => b.score - a.score)
      .slice(0, 10);
    
    // ç¼“å­˜ç»“æœ
    await this.redis.setex(cacheKey, 300, JSON.stringify(sortedSuggestions));
    
    return sortedSuggestions;
  }
  
  private async getProductSuggestions(keyword: string): Promise<SearchSuggestion[]> {
    const response = await this.esClient.search({
      index: 'products',
      body: {
        suggest: {
          product_suggest: {
            prefix: keyword,
            completion: {
              field: 'suggest',
              size: 5,
              contexts: {
                status: ['active']
              }
            }
          }
        }
      }
    });
    
    return response.body.suggest.product_suggest[0].options.map((option: any) => ({
      text: option.text,
      type: 'product',
      score: option._score,
      metadata: option._source
    }));
  }
  
  private async getBrandSuggestions(keyword: string): Promise<SearchSuggestion[]> {
    const response = await this.esClient.search({
      index: 'products',
      body: {
        query: {
          prefix: {
            brand: keyword
          }
        },
        aggs: {
          brands: {
            terms: {
              field: 'brand',
              size: 5
            }
          }
        },
        size: 0
      }
    });
    
    return response.body.aggregations.brands.buckets.map((bucket: any) => ({
      text: bucket.key,
      type: 'brand',
      score: bucket.doc_count,
      metadata: { count: bucket.doc_count }
    }));
  }
  
  // æ™ºèƒ½çº é”™
  async getSpellingSuggestions(keyword: string): Promise<string[]> {
    const response = await this.esClient.search({
      index: 'products',
      body: {
        suggest: {
          spelling_suggest: {
            text: keyword,
            term: {
              field: 'name',
              suggest_mode: 'popular',
              min_word_length: 2,
              prefix_length: 1
            }
          }
        }
      }
    });
    
    const suggestions = [];
    for (const suggest of response.body.suggest.spelling_suggest) {
      for (const option of suggest.options) {
        suggestions.push(option.text);
      }
    }
    
    return suggestions;
  }
}
```

#### 3.2 ä¸ªæ€§åŒ–æœç´¢

##### 3.2.1 ç”¨æˆ·è¡Œä¸ºåˆ†æ
```typescript
// ç”¨æˆ·è¡Œä¸ºåˆ†ææœåŠ¡
class UserBehaviorAnalysisService {
  private esClient: Client;
  private redis: Redis;
  
  // è®°å½•æœç´¢è¡Œä¸º
  async recordSearchBehavior(userId: string, behavior: SearchBehavior) {
    const document = {
      user_id: userId,
      keyword: behavior.keyword,
      category: behavior.category,
      results_count: behavior.resultsCount,
      clicked_items: behavior.clickedItems,
      timestamp: new Date(),
      session_id: behavior.sessionId
    };
    
    // å­˜å‚¨åˆ°Elasticsearch
    await this.esClient.index({
      index: 'search_behaviors',
      body: document
    });
    
    // æ›´æ–°ç”¨æˆ·æœç´¢åå¥½
    await this.updateUserPreferences(userId, behavior);
  }
  
  // æ›´æ–°ç”¨æˆ·åå¥½
  private async updateUserPreferences(userId: string, behavior: SearchBehavior) {
    const preferencesKey = `user_preferences:${userId}`;
    
    // è·å–å½“å‰åå¥½
    let preferences = await this.redis.hgetall(preferencesKey);
    if (!preferences) {
      preferences = {};
    }
    
    // æ›´æ–°å…³é”®è¯åå¥½
    if (behavior.keyword) {
      const keywordKey = `keyword:${behavior.keyword}`;
      const currentScore = parseFloat(preferences[keywordKey] || '0');
      preferences[keywordKey] = (currentScore + 1).toString();
    }
    
    // æ›´æ–°åˆ†ç±»åå¥½
    if (behavior.category) {
      const categoryKey = `category:${behavior.category}`;
      const currentScore = parseFloat(preferences[categoryKey] || '0');
      preferences[categoryKey] = (currentScore + 1).toString();
    }
    
    // æ›´æ–°å“ç‰Œåå¥½ï¼ˆåŸºäºç‚¹å‡»çš„å•†å“ï¼‰
    for (const item of behavior.clickedItems || []) {
      if (item.brand) {
        const brandKey = `brand:${item.brand}`;
        const currentScore = parseFloat(preferences[brandKey] || '0');
        preferences[brandKey] = (currentScore + 2).toString(); // ç‚¹å‡»æƒé‡æ›´é«˜
      }
    }
    
    // ä¿å­˜åå¥½
    await this.redis.hmset(preferencesKey, preferences);
    await this.redis.expire(preferencesKey, 86400 * 30); // 30å¤©è¿‡æœŸ
  }
  
  // è·å–ä¸ªæ€§åŒ–æœç´¢æƒé‡
  async getPersonalizationWeights(userId: string): Promise<PersonalizationWeights> {
    const preferencesKey = `user_preferences:${userId}`;
    const preferences = await this.redis.hgetall(preferencesKey);
    
    const weights: PersonalizationWeights = {
      keywords: {},
      categories: {},
      brands: {}
    };
    
    for (const [key, score] of Object.entries(preferences)) {
      const [type, value] = key.split(':');
      const weight = Math.log(parseFloat(score) + 1); // å¯¹æ•°æƒé‡
      
      switch (type) {
        case 'keyword':
          weights.keywords[value] = weight;
          break;
        case 'category':
          weights.categories[value] = weight;
          break;
        case 'brand':
          weights.brands[value] = weight;
          break;
      }
    }
    
    return weights;
  }
}
```

##### 3.2.2 ä¸ªæ€§åŒ–æœç´¢æœåŠ¡
```typescript
// ä¸ªæ€§åŒ–æœç´¢æœåŠ¡
class PersonalizedSearchService {
  private productSearchService: ProductSearchService;
  private behaviorAnalysisService: UserBehaviorAnalysisService;
  
  // ä¸ªæ€§åŒ–äº§å“æœç´¢
  async personalizedProductSearch(
    userId: string,
    params: ProductSearchParams
  ): Promise<ProductSearchResult> {
    // è·å–ç”¨æˆ·ä¸ªæ€§åŒ–æƒé‡
    const weights = await this.behaviorAnalysisService.getPersonalizationWeights(userId);
    
    // æ„å»ºä¸ªæ€§åŒ–æŸ¥è¯¢
    const personalizedQuery = this.buildPersonalizedQuery(params, weights);
    
    const response = await this.esClient.search({
      index: 'products',
      body: {
        query: personalizedQuery,
        sort: this.buildPersonalizedSort(params.sort, weights),
        aggs: this.buildAggregations(),
        from: (params.page - 1) * params.size,
        size: params.size
      }
    });
    
    return this.formatSearchResult(response);
  }
  
  private buildPersonalizedQuery(params: ProductSearchParams, weights: PersonalizationWeights) {
    const baseQuery = this.buildSearchQuery(params);
    
    // æ·»åŠ ä¸ªæ€§åŒ–æƒé‡
    const personalizedShould = [];
    
    // å“ç‰Œåå¥½åŠ æƒ
    for (const [brand, weight] of Object.entries(weights.brands)) {
      personalizedShould.push({
        term: {
          brand: {
            value: brand,
            boost: weight
          }
        }
      });
    }
    
    // åˆ†ç±»åå¥½åŠ æƒ
    for (const [categoryId, weight] of Object.entries(weights.categories)) {
      personalizedShould.push({
        nested: {
          path: 'category',
          query: {
            term: {
              'category.id': {
                value: categoryId,
                boost: weight
              }
            }
          }
        }
      });
    }
    
    // å…³é”®è¯åå¥½åŠ æƒ
    for (const [keyword, weight] of Object.entries(weights.keywords)) {
      personalizedShould.push({
        multi_match: {
          query: keyword,
          fields: ['name', 'description', 'search_keywords'],
          boost: weight
        }
      });
    }
    
    if (personalizedShould.length > 0) {
      return {
        bool: {
          must: baseQuery.bool.must,
          filter: baseQuery.bool.filter,
          should: [
            ...(baseQuery.bool.should || []),
            ...personalizedShould
          ]
        }
      };
    }
    
    return baseQuery;
  }
  
  // æ¨èç›¸å…³æœç´¢
  async getRelatedSearches(userId: string, keyword: string): Promise<string[]> {
    // åŸºäºç”¨æˆ·å†å²æœç´¢è¡Œä¸ºæ¨è
    const userRelated = await this.getUserRelatedSearches(userId, keyword);
    
    // åŸºäºå…¨å±€æœç´¢è¡Œä¸ºæ¨è
    const globalRelated = await this.getGlobalRelatedSearches(keyword);
    
    // åˆå¹¶å¹¶å»é‡
    const allRelated = [...new Set([...userRelated, ...globalRelated])];
    
    return allRelated.slice(0, 10);
  }
  
  private async getUserRelatedSearches(userId: string, keyword: string): Promise<string[]> {
    const response = await this.esClient.search({
      index: 'search_behaviors',
      body: {
        query: {
          bool: {
            must: [
              { term: { user_id: userId } },
              { match: { keyword } }
            ]
          }
        },
        aggs: {
          related_keywords: {
            terms: {
              field: 'keyword.keyword',
              size: 5,
              exclude: [keyword]
            }
          }
        },
        size: 0
      }
    });
    
    return response.body.aggregations.related_keywords.buckets.map(
      (bucket: any) => bucket.key
    );
  }
}
```

### 4. æœç´¢æ•°æ®åŒæ­¥

#### 4.1 å®æ—¶æ•°æ®åŒæ­¥

##### 4.1.1 Canalæ•°æ®åŒæ­¥
```typescript
// Canalæ•°æ®åŒæ­¥æœåŠ¡
class CanalSyncService {
  private canalClient: CanalClient;
  private esClient: Client;
  private messageQueue: MessageQueue;
  
  constructor() {
    this.setupCanalClient();
    this.startSyncProcess();
  }
  
  private setupCanalClient() {
    this.canalClient = new CanalClient({
      host: 'localhost',
      port: 11111,
      destination: 'l2c_search',
      username: 'canal',
      password: 'canal'
    });
  }
  
  private async startSyncProcess() {
    this.canalClient.subscribe({
      onMessage: async (message) => {
        await this.processMessage(message);
      },
      onError: (error) => {
        console.error('CanalåŒæ­¥é”™è¯¯:', error);
      }
    });
  }
  
  private async processMessage(message: CanalMessage) {
    for (const entry of message.entries) {
      try {
        await this.processDatabaseChange(entry);
      } catch (error) {
        console.error('å¤„ç†æ•°æ®åº“å˜æ›´å¤±è´¥:', error);
        // å‘é€åˆ°æ­»ä¿¡é˜Ÿåˆ—é‡è¯•
        await this.messageQueue.sendToDeadLetter(entry);
      }
    }
  }
  
  private async processDatabaseChange(entry: CanalEntry) {
    const { tableName, eventType, rowData } = entry;
    
    switch (tableName) {
      case 'products':
        await this.syncProductData(eventType, rowData);
        break;
      case 'orders':
        await this.syncOrderData(eventType, rowData);
        break;
      case 'users':
        await this.syncUserData(eventType, rowData);
        break;
      case 'categories':
        await this.syncCategoryData(eventType, rowData);
        break;
      default:
        console.log(`å¿½ç•¥è¡¨ ${tableName} çš„å˜æ›´`);
    }
  }
  
  private async syncProductData(eventType: string, rowData: any) {
    const productId = rowData.id;
    
    switch (eventType) {
      case 'INSERT':
      case 'UPDATE':
        // è·å–å®Œæ•´çš„äº§å“æ•°æ®
        const productData = await this.getCompleteProductData(productId);
        
        // æ›´æ–°Elasticsearchç´¢å¼•
        await this.esClient.index({
          index: 'products',
          id: productId,
          body: this.transformProductData(productData)
        });
        
        // æ¸…é™¤ç›¸å…³ç¼“å­˜
        await this.clearProductCache(productId);
        break;
        
      case 'DELETE':
        // ä»ç´¢å¼•ä¸­åˆ é™¤
        await this.esClient.delete({
          index: 'products',
          id: productId
        });
        
        // æ¸…é™¤ç›¸å…³ç¼“å­˜
        await this.clearProductCache(productId);
        break;
    }
  }
  
  private async getCompleteProductData(productId: string) {
    // ä»æ•°æ®åº“è·å–å®Œæ•´çš„äº§å“æ•°æ®ï¼ŒåŒ…æ‹¬å…³è”çš„åˆ†ç±»ã€å±æ€§ç­‰
    const product = await this.productService.getCompleteProductById(productId);
    return product;
  }
  
  private transformProductData(productData: any) {
    return {
      id: productData.id,
      name: productData.name,
      description: productData.description,
      category: productData.categories.map(cat => ({
        id: cat.id,
        name: cat.name,
        level: cat.level
      })),
      brand: productData.brand,
      price: productData.price,
      stock: productData.stock,
      status: productData.status,
      tags: productData.tags,
      attributes: productData.attributes.map(attr => ({
        name: attr.name,
        value: attr.value
      })),
      sales_count: productData.sales_count,
      rating: productData.rating,
      created_at: productData.created_at,
      updated_at: productData.updated_at,
      search_keywords: this.generateSearchKeywords(productData),
      popularity_score: this.calculatePopularityScore(productData),
      suggest: {
        input: [
          productData.name,
          productData.brand,
          ...productData.tags,
          ...productData.categories.map(cat => cat.name)
        ],
        contexts: {
          status: [productData.status],
          category: productData.categories.map(cat => cat.id)
        }
      }
    };
  }
  
  private generateSearchKeywords(productData: any): string {
    const keywords = [
      productData.name,
      productData.brand,
      ...productData.tags,
      ...productData.categories.map(cat => cat.name),
      ...productData.attributes.map(attr => `${attr.name}:${attr.value}`)
    ];
    
    return keywords.join(' ');
  }
  
  private calculatePopularityScore(productData: any): number {
    // åŸºäºé”€é‡ã€è¯„åˆ†ã€æµè§ˆé‡ç­‰è®¡ç®—çƒ­åº¦åˆ†æ•°
    const salesWeight = 0.4;
    const ratingWeight = 0.3;
    const viewWeight = 0.2;
    const timeWeight = 0.1;
    
    const salesScore = Math.log(productData.sales_count + 1) * salesWeight;
    const ratingScore = (productData.rating / 5) * ratingWeight;
    const viewScore = Math.log(productData.view_count + 1) * viewWeight;
    const timeScore = this.calculateTimeScore(productData.created_at) * timeWeight;
    
    return salesScore + ratingScore + viewScore + timeScore;
  }
}
```

#### 4.2 æ‰¹é‡æ•°æ®åŒæ­¥

##### 4.2.1 æ‰¹é‡åŒæ­¥æœåŠ¡
```typescript
// æ‰¹é‡æ•°æ®åŒæ­¥æœåŠ¡
class BatchSyncService {
  private esClient: Client;
  private batchSize = 1000;
  
  // å…¨é‡åŒæ­¥äº§å“æ•°æ®
  async fullSyncProducts() {
    console.log('å¼€å§‹å…¨é‡åŒæ­¥äº§å“æ•°æ®...');
    
    let offset = 0;
    let totalSynced = 0;
    
    while (true) {
      // åˆ†æ‰¹è·å–äº§å“æ•°æ®
      const products = await this.productService.getProductsBatch(offset, this.batchSize);
      
      if (products.length === 0) {
        break;
      }
      
      // æ‰¹é‡ç´¢å¼•åˆ°Elasticsearch
      await this.bulkIndexProducts(products);
      
      totalSynced += products.length;
      offset += this.batchSize;
      
      console.log(`å·²åŒæ­¥ ${totalSynced} ä¸ªäº§å“`);
      
      // é¿å…è¿‡åº¦å ç”¨èµ„æº
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    console.log(`äº§å“æ•°æ®å…¨é‡åŒæ­¥å®Œæˆï¼Œå…±åŒæ­¥ ${totalSynced} ä¸ªäº§å“`);
  }
  
  private async bulkIndexProducts(products: any[]) {
    const body = [];
    
    for (const product of products) {
      body.push({
        index: {
          _index: 'products',
          _id: product.id
        }
      });
      body.push(this.transformProductData(product));
    }
    
    const response = await this.esClient.bulk({ body });
    
    if (response.body.errors) {
      console.error('æ‰¹é‡ç´¢å¼•å‡ºç°é”™è¯¯:', response.body.items.filter(item => item.index.error));
    }
  }
  
  // å¢é‡åŒæ­¥
  async incrementalSync(lastSyncTime: Date) {
    console.log(`å¼€å§‹å¢é‡åŒæ­¥ï¼Œä¸Šæ¬¡åŒæ­¥æ—¶é—´: ${lastSyncTime}`);
    
    // åŒæ­¥äº§å“æ•°æ®
    await this.incrementalSyncProducts(lastSyncTime);
    
    // åŒæ­¥è®¢å•æ•°æ®
    await this.incrementalSyncOrders(lastSyncTime);
    
    // åŒæ­¥ç”¨æˆ·æ•°æ®
    await this.incrementalSyncUsers(lastSyncTime);
    
    console.log('å¢é‡åŒæ­¥å®Œæˆ');
  }
  
  private async incrementalSyncProducts(lastSyncTime: Date) {
    const updatedProducts = await this.productService.getUpdatedProducts(lastSyncTime);
    
    if (updatedProducts.length > 0) {
      await this.bulkIndexProducts(updatedProducts);
      console.log(`å¢é‡åŒæ­¥äº† ${updatedProducts.length} ä¸ªäº§å“`);
    }
  }
  
  // å®šæ—¶åŒæ­¥ä»»åŠ¡
  setupScheduledSync() {
    // æ¯å¤©å‡Œæ™¨2ç‚¹æ‰§è¡Œå…¨é‡åŒæ­¥
    cron.schedule('0 2 * * *', async () => {
      try {
        await this.fullSyncProducts();
        await this.fullSyncOrders();
        await this.fullSyncUsers();
      } catch (error) {
        console.error('å®šæ—¶å…¨é‡åŒæ­¥å¤±è´¥:', error);
      }
    });
    
    // æ¯5åˆ†é’Ÿæ‰§è¡Œå¢é‡åŒæ­¥
    cron.schedule('*/5 * * * *', async () => {
      try {
        const lastSyncTime = await this.getLastSyncTime();
        await this.incrementalSync(lastSyncTime);
        await this.updateLastSyncTime(new Date());
      } catch (error) {
        console.error('å®šæ—¶å¢é‡åŒæ­¥å¤±è´¥:', error);
      }
    });
  }
}
```

### 5. æœç´¢æ€§èƒ½ä¼˜åŒ–

#### 5.1 ç´¢å¼•ä¼˜åŒ–

##### 5.1.1 ç´¢å¼•è®¾ç½®ä¼˜åŒ–
```json
{
  "settings": {
    "number_of_shards": 3,
    "number_of_replicas": 1,
    "refresh_interval": "30s",
    "max_result_window": 50000,
    "analysis": {
      "analyzer": {
        "ik_max_word_analyzer": {
          "type": "custom",
          "tokenizer": "ik_max_word",
          "filter": ["lowercase", "stop"]
        },
        "ik_smart_analyzer": {
          "type": "custom",
          "tokenizer": "ik_smart",
          "filter": ["lowercase", "stop"]
        },
        "pinyin_analyzer": {
          "type": "custom",
          "tokenizer": "pinyin_tokenizer",
          "filter": ["lowercase", "unique"]
        }
      },
      "tokenizer": {
        "pinyin_tokenizer": {
          "type": "pinyin",
          "keep_first_letter": true,
          "keep_separate_first_letter": false,
          "keep_full_pinyin": true,
          "keep_original": true,
          "limit_first_letter_length": 16,
          "lowercase": true,
          "remove_duplicated_term": true
        }
      }
    }
  }
}
```

##### 5.1.2 ç´¢å¼•ç”Ÿå‘½å‘¨æœŸç®¡ç†
```typescript
// ç´¢å¼•ç”Ÿå‘½å‘¨æœŸç®¡ç†
class IndexLifecycleManager {
  private esClient: Client;
  
  // åˆ›å»ºç´¢å¼•ç”Ÿå‘½å‘¨æœŸç­–ç•¥
  async createLifecyclePolicy() {
    await this.esClient.ilm.putLifecycle({
      policy: 'search_logs_policy',
      body: {
        policy: {
          phases: {
            hot: {
              actions: {
                rollover: {
                  max_size: '10GB',
                  max_age: '7d'
                }
              }
            },
            warm: {
              min_age: '7d',
              actions: {
                allocate: {
                  number_of_replicas: 0
                },
                forcemerge: {
                  max_num_segments: 1
                }
              }
            },
            cold: {
              min_age: '30d',
              actions: {
                allocate: {
                  number_of_replicas: 0
                }
              }
            },
            delete: {
              min_age: '90d'
            }
          }
        }
      }
    });
  }
  
  // ç´¢å¼•æ¨¡æ¿ç®¡ç†
  async createIndexTemplate() {
    await this.esClient.indices.putIndexTemplate({
      name: 'search_logs_template',
      body: {
        index_patterns: ['search_logs-*'],
        template: {
          settings: {
            number_of_shards: 1,
            number_of_replicas: 1,
            'index.lifecycle.name': 'search_logs_policy',
            'index.lifecycle.rollover_alias': 'search_logs'
          },
          mappings: {
            properties: {
              timestamp: { type: 'date' },
              user_id: { type: 'keyword' },
              keyword: { type: 'text', analyzer: 'ik_max_word' },
              results_count: { type: 'integer' },
              response_time: { type: 'integer' },
              ip_address: { type: 'ip' }
            }
          }
        }
      }
    });
  }
}
```

#### 5.2 æŸ¥è¯¢ä¼˜åŒ–

##### 5.2.1 æŸ¥è¯¢ç¼“å­˜ä¼˜åŒ–
```typescript
// æŸ¥è¯¢ç¼“å­˜ä¼˜åŒ–
class QueryCacheOptimizer {
  private redis: Redis;
  private esClient: Client;
  
  // æ™ºèƒ½æŸ¥è¯¢ç¼“å­˜
  async cachedSearch(query: any, cacheKey: string, ttl: number = 300): Promise<any> {
    // å°è¯•ä»ç¼“å­˜è·å–
    const cached = await this.redis.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }
    
    // æ‰§è¡Œæœç´¢
    const result = await this.esClient.search(query);
    
    // ç¼“å­˜ç»“æœ
    await this.redis.setex(cacheKey, ttl, JSON.stringify(result.body));
    
    return result.body;
  }
  
  // æŸ¥è¯¢é¢„çƒ­
  async warmupQueries() {
    const hotQueries = await this.getHotQueries();
    
    for (const query of hotQueries) {
      try {
        await this.esClient.search(query.searchQuery);
        console.log(`é¢„çƒ­æŸ¥è¯¢: ${query.keyword}`);
      } catch (error) {
        console.error(`é¢„çƒ­æŸ¥è¯¢å¤±è´¥: ${query.keyword}`, error);
      }
    }
  }
  
  private async getHotQueries(): Promise<any[]> {
    // ä»æœç´¢æ—¥å¿—åˆ†æçƒ­é—¨æŸ¥è¯¢
    const response = await this.esClient.search({
      index: 'search_logs',
      body: {
        query: {
          range: {
            timestamp: {
              gte: 'now-24h'
            }
          }
        },
        aggs: {
          hot_keywords: {
            terms: {
              field: 'keyword.keyword',
              size: 100,
              min_doc_count: 10
            }
          }
        },
        size: 0
      }
    });
    
    return response.body.aggregations.hot_keywords.buckets.map((bucket: any) => ({
      keyword: bucket.key,
      count: bucket.doc_count,
      searchQuery: this.buildSearchQuery(bucket.key)
    }));
  }
}
```

#### 5.3 æ€§èƒ½ç›‘æ§

##### 5.3.1 æœç´¢æ€§èƒ½ç›‘æ§
```typescript
// æœç´¢æ€§èƒ½ç›‘æ§
class SearchPerformanceMonitor {
  private esClient: Client;
  private redis: Redis;
  
  // è®°å½•æœç´¢æ€§èƒ½æŒ‡æ ‡
  async recordSearchMetrics(searchRequest: any, searchResponse: any, responseTime: number) {
    const metrics = {
      timestamp: new Date(),
      keyword: searchRequest.keyword,
      results_count: searchResponse.hits.total.value,
      response_time: responseTime,
      took: searchResponse.took,
      timed_out: searchResponse.timed_out,
      shards: searchResponse._shards
    };
    
    // å­˜å‚¨åˆ°Elasticsearch
    await this.esClient.index({
      index: 'search_metrics',
      body: metrics
    });
    
    // æ›´æ–°å®æ—¶æŒ‡æ ‡
    await this.updateRealTimeMetrics(metrics);
  }
  
  private async updateRealTimeMetrics(metrics: any) {
    const metricsKey = 'search:metrics:realtime';
    
    // æ›´æ–°å¹³å‡å“åº”æ—¶é—´
    await this.redis.lpush(`${metricsKey}:response_times`, metrics.response_time);
    await this.redis.ltrim(`${metricsKey}:response_times`, 0, 999); // ä¿ç•™æœ€è¿‘1000æ¬¡
    
    // æ›´æ–°æœç´¢é‡
    await this.redis.incr(`${metricsKey}:search_count:${this.getHourKey()}`);
    
    // æ›´æ–°æ…¢æŸ¥è¯¢
    if (metrics.response_time > 1000) {
      await this.redis.lpush(`${metricsKey}:slow_queries`, JSON.stringify(metrics));
      await this.redis.ltrim(`${metricsKey}:slow_queries`, 0, 99); // ä¿ç•™æœ€è¿‘100æ¬¡
    }
  }
  
  // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
  async generatePerformanceReport(): Promise<PerformanceReport> {
    const now = new Date();
    const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    
    const response = await this.esClient.search({
      index: 'search_metrics',
      body: {
        query: {
          range: {
            timestamp: {
              gte: yesterday,
              lte: now
            }
          }
        },
        aggs: {
          avg_response_time: {
            avg: { field: 'response_time' }
          },
          max_response_time: {
            max: { field: 'response_time' }
          },
          total_searches: {
            value_count: { field: 'keyword' }
          },
          slow_queries: {
            filter: {
              range: { response_time: { gte: 1000 } }
            }
          },
          hourly_searches: {
            date_histogram: {
              field: 'timestamp',
              calendar_interval: 'hour'
            }
          },
          top_keywords: {
            terms: {
              field: 'keyword.keyword',
              size: 20
            }
          }
        },
        size: 0
      }
    });
    
    const aggs = response.body.aggregations;
    
    return {
      period: { start: yesterday, end: now },
      totalSearches: aggs.total_searches.value,
      avgResponseTime: Math.round(aggs.avg_response_time.value),
      maxResponseTime: aggs.max_response_time.value,
      slowQueriesCount: aggs.slow_queries.doc_count,
      hourlySearches: aggs.hourly_searches.buckets,
      topKeywords: aggs.top_keywords.buckets.map((bucket: any) => ({
        keyword: bucket.key,
        count: bucket.doc_count
      }))
    };
  }
  
  private getHourKey(): string {
    const now = new Date();
    return `${now.getFullYear()}-${now.getMonth() + 1}-${now.getDate()}-${now.getHours()}`;
  }
}
```

### 6. æœç´¢å®‰å…¨è®¾è®¡

#### 6.1 æœç´¢æƒé™æ§åˆ¶

##### 6.1.1 æƒé™éªŒè¯æœåŠ¡
```typescript
// æœç´¢æƒé™éªŒè¯æœåŠ¡
class SearchPermissionService {
  private userService: UserService;
  private roleService: RoleService;
  
  // éªŒè¯æœç´¢æƒé™
  async validateSearchPermission(userId: string, searchType: string, filters: any): Promise<boolean> {
    const user = await this.userService.getUserById(userId);
    if (!user) {
      return false;
    }
    
    const userRoles = await this.roleService.getUserRoles(userId);
    
    // æ£€æŸ¥åŸºç¡€æœç´¢æƒé™
    if (!this.hasBasicSearchPermission(userRoles, searchType)) {
      return false;
    }
    
    // æ£€æŸ¥æ•°æ®èŒƒå›´æƒé™
    if (!this.hasDataScopePermission(userRoles, filters)) {
      return false;
    }
    
    return true;
  }
  
  private hasBasicSearchPermission(roles: string[], searchType: string): boolean {
    const permissionMap = {
      'product': ['admin', 'sales', 'customer'],
      'order': ['admin', 'sales', 'finance'],
      'user': ['admin', 'sales'],
      'financial': ['admin', 'finance']
    };
    
    const allowedRoles = permissionMap[searchType] || [];
    return roles.some(role => allowedRoles.includes(role));
  }
  
  private hasDataScopePermission(roles: string[], filters: any): boolean {
    // ç®¡ç†å‘˜å¯ä»¥è®¿é—®æ‰€æœ‰æ•°æ®
    if (roles.includes('admin')) {
      return true;
    }
    
    // é”€å”®äººå‘˜åªèƒ½è®¿é—®è‡ªå·±çš„å®¢æˆ·æ•°æ®
    if (roles.includes('sales') && filters.userId && filters.userId !== filters.currentUserId) {
      return false;
    }
    
    // è´¢åŠ¡äººå‘˜åªèƒ½è®¿é—®å·²ç¡®è®¤çš„è®¢å•
    if (roles.includes('finance') && filters.orderStatus && !['confirmed', 'paid'].includes(filters.orderStatus)) {
      return false;
    }
    
    return true;
  }
  
  // åº”ç”¨æ•°æ®è¿‡æ»¤
  async applyDataFilters(userId: string, query: any): Promise<any> {
    const user = await this.userService.getUserById(userId);
    const userRoles = await this.roleService.getUserRoles(userId);
    
    // ç®¡ç†å‘˜ä¸éœ€è¦é¢å¤–è¿‡æ»¤
    if (userRoles.includes('admin')) {
      return query;
    }
    
    const filters = [];
    
    // é”€å”®äººå‘˜æ•°æ®è¿‡æ»¤
    if (userRoles.includes('sales')) {
      filters.push({
        term: { sales_user_id: userId }
      });
    }
    
    // å®¢æˆ·æ•°æ®è¿‡æ»¤
    if (userRoles.includes('customer')) {
      filters.push({
        term: { user_id: userId }
      });
    }
    
    // åº”ç”¨è¿‡æ»¤æ¡ä»¶
    if (filters.length > 0) {
      if (!query.bool) {
        query = { bool: { must: [query] } };
      }
      
      if (!query.bool.filter) {
        query.bool.filter = [];
      }
      
      query.bool.filter.push(...filters);
    }
    
    return query;
  }
}
```

#### 6.2 æœç´¢å®¡è®¡

##### 6.2.1 æœç´¢å®¡è®¡æœåŠ¡
```typescript
// æœç´¢å®¡è®¡æœåŠ¡
class SearchAuditService {
  private esClient: Client;
  
  // è®°å½•æœç´¢å®¡è®¡æ—¥å¿—
  async logSearchAudit(auditData: SearchAuditData) {
    const auditLog = {
      timestamp: new Date(),
      user_id: auditData.userId,
      user_ip: auditData.userIp,
      user_agent: auditData.userAgent,
      search_type: auditData.searchType,
      keyword: auditData.keyword,
      filters: auditData.filters,
      results_count: auditData.resultsCount,
      response_time: auditData.responseTime,
      success: auditData.success,
      error_message: auditData.errorMessage,
      session_id: auditData.sessionId
    };
    
    await this.esClient.index({
      index: 'search_audit_logs',
      body: auditLog
    });
  }
  
  // æ£€æµ‹å¼‚å¸¸æœç´¢è¡Œä¸º
  async detectAnomalousSearchBehavior(userId: string): Promise<AnomalyDetectionResult> {
    const now = new Date();
    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
    
    const response = await this.esClient.search({
      index: 'search_audit_logs',
      body: {
        query: {
          bool: {
            must: [
              { term: { user_id: userId } },
              { range: { timestamp: { gte: oneHourAgo } } }
            ]
          }
        },
        aggs: {
          search_count: {
            value_count: { field: 'keyword' }
          },
          unique_keywords: {
            cardinality: { field: 'keyword.keyword' }
          },
          failed_searches: {
            filter: { term: { success: false } }
          }
        },
        size: 0
      }
    });
    
    const aggs = response.body.aggregations;
    const searchCount = aggs.search_count.value;
    const uniqueKeywords = aggs.unique_keywords.value;
    const failedSearches = aggs.failed_searches.doc_count;
    
    const anomalies = [];
    
    // æ£€æµ‹æœç´¢é¢‘ç‡å¼‚å¸¸
    if (searchCount > 1000) {
      anomalies.push({
        type: 'high_frequency',
        description: `ç”¨æˆ·åœ¨1å°æ—¶å†…è¿›è¡Œäº†${searchCount}æ¬¡æœç´¢`,
        severity: 'high'
      });
    }
    
    // æ£€æµ‹é‡å¤æœç´¢å¼‚å¸¸
    if (searchCount > 100 && uniqueKeywords < 10) {
      anomalies.push({
        type: 'repetitive_search',
        description: `ç”¨æˆ·é‡å¤æœç´¢ç›¸åŒå…³é”®è¯`,
        severity: 'medium'
      });
    }
    
    // æ£€æµ‹å¤±è´¥æœç´¢å¼‚å¸¸
    if (failedSearches > 50) {
      anomalies.push({
        type: 'high_failure_rate',
        description: `ç”¨æˆ·æœç´¢å¤±è´¥ç‡è¿‡é«˜`,
        severity: 'medium'
      });
    }
    
    return {
      userId,
      period: { start: oneHourAgo, end: now },
      anomalies,
      isAnomalous: anomalies.length > 0
    };
  }
}
```

### 7. æœç´¢è¿ç»´ç®¡ç†

#### 7.1 æœç´¢é›†ç¾¤ç®¡ç†

##### 7.1.1 é›†ç¾¤å¥åº·ç›‘æ§
```typescript
// Elasticsearché›†ç¾¤å¥åº·ç›‘æ§
class ClusterHealthMonitor {
  private esClient: Client;
  private alertService: AlertService;
  
  // æ£€æŸ¥é›†ç¾¤å¥åº·çŠ¶æ€
  async checkClusterHealth(): Promise<ClusterHealthStatus> {
    const health = await this.esClient.cluster.health();
    const stats = await this.esClient.cluster.stats();
    const nodes = await this.esClient.nodes.info();
    
    const healthStatus: ClusterHealthStatus = {
      status: health.body.status,
      numberOfNodes: health.body.number_of_nodes,
      numberOfDataNodes: health.body.number_of_data_nodes,
      activePrimaryShards: health.body.active_primary_shards,
      activeShards: health.body.active_shards,
      relocatingShards: health.body.relocating_shards,
      initializingShards: health.body.initializing_shards,
      unassignedShards: health.body.unassigned_shards,
      delayedUnassignedShards: health.body.delayed_unassigned_shards,
      pendingTasks: health.body.number_of_pending_tasks,
      inFlightFetch: health.body.number_of_in_flight_fetch,
      taskMaxWaitingInQueue: health.body.task_max_waiting_in_queue_millis,
      activeShardsPercent: health.body.active_shards_percent_as_number
    };
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦å‘Šè­¦
    await this.checkHealthAlerts(healthStatus);
    
    return healthStatus;
  }
  
  private async checkHealthAlerts(health: ClusterHealthStatus) {
    // é›†ç¾¤çŠ¶æ€å‘Šè­¦
    if (health.status === 'red') {
      await this.alertService.sendAlert({
        level: 'critical',
        title: 'Elasticsearché›†ç¾¤çŠ¶æ€å¼‚å¸¸',
        message: 'é›†ç¾¤çŠ¶æ€ä¸ºçº¢è‰²ï¼Œå­˜åœ¨ä¸å¯ç”¨çš„ä¸»åˆ†ç‰‡',
        details: health
      });
    } else if (health.status === 'yellow') {
      await this.alertService.sendAlert({
        level: 'warning',
        title: 'Elasticsearché›†ç¾¤çŠ¶æ€è­¦å‘Š',
        message: 'é›†ç¾¤çŠ¶æ€ä¸ºé»„è‰²ï¼Œå­˜åœ¨æœªåˆ†é…çš„å‰¯æœ¬åˆ†ç‰‡',
        details: health
      });
    }
    
    // æœªåˆ†é…åˆ†ç‰‡å‘Šè­¦
    if (health.unassignedShards > 0) {
      await this.alertService.sendAlert({
        level: 'warning',
        title: 'å­˜åœ¨æœªåˆ†é…çš„åˆ†ç‰‡',
        message: `æœ‰${health.unassignedShards}ä¸ªåˆ†ç‰‡æœªåˆ†é…`,
        details: health
      });
    }
    
    // æ´»è·ƒåˆ†ç‰‡ç™¾åˆ†æ¯”å‘Šè­¦
    if (health.activeShardsPercent < 95) {
      await this.alertService.sendAlert({
        level: 'warning',
        title: 'æ´»è·ƒåˆ†ç‰‡ç™¾åˆ†æ¯”è¿‡ä½',
        message: `æ´»è·ƒåˆ†ç‰‡ç™¾åˆ†æ¯”ä¸º${health.activeShardsPercent}%`,
        details: health
      });
    }
  }
  
  // ç›‘æ§èŠ‚ç‚¹æ€§èƒ½
  async monitorNodePerformance(): Promise<NodePerformanceMetrics[]> {
    const stats = await this.esClient.nodes.stats({
      metric: ['jvm', 'os', 'fs', 'indices']
    });
    
    const nodeMetrics: NodePerformanceMetrics[] = [];
    
    for (const [nodeId, nodeStats] of Object.entries(stats.body.nodes)) {
      const metrics: NodePerformanceMetrics = {
        nodeId,
        nodeName: nodeStats.name,
        // JVMæŒ‡æ ‡
        jvmHeapUsedPercent: nodeStats.jvm.mem.heap_used_percent,
        jvmHeapUsed: nodeStats.jvm.mem.heap_used_in_bytes,
        jvmHeapMax: nodeStats.jvm.mem.heap_max_in_bytes,
        jvmGcCollectionCount: nodeStats.jvm.gc.collectors.young.collection_count,
        jvmGcCollectionTime: nodeStats.jvm.gc.collectors.young.collection_time_in_millis,
        // æ“ä½œç³»ç»ŸæŒ‡æ ‡
        osLoadAverage: nodeStats.os.cpu.load_average?.['1m'] || 0,
        osCpuPercent: nodeStats.os.cpu.percent,
        osMemUsedPercent: nodeStats.os.mem.used_percent,
        // æ–‡ä»¶ç³»ç»ŸæŒ‡æ ‡
        fsTotal: nodeStats.fs.total.total_in_bytes,
        fsAvailable: nodeStats.fs.total.available_in_bytes,
        fsUsedPercent: ((nodeStats.fs.total.total_in_bytes - nodeStats.fs.total.available_in_bytes) / nodeStats.fs.total.total_in_bytes) * 100,
        // ç´¢å¼•æŒ‡æ ‡
        indexingRate: nodeStats.indices.indexing.index_total,
        searchRate: nodeStats.indices.search.query_total,
        searchLatency: nodeStats.indices.search.query_time_in_millis / Math.max(nodeStats.indices.search.query_total, 1)
      };
      
      nodeMetrics.push(metrics);
      
      // æ£€æŸ¥æ€§èƒ½å‘Šè­¦
      await this.checkNodePerformanceAlerts(metrics);
    }
    
    return nodeMetrics;
  }
  
  private async checkNodePerformanceAlerts(metrics: NodePerformanceMetrics) {
    // JVMå †å†…å­˜ä½¿ç”¨ç‡å‘Šè­¦
    if (metrics.jvmHeapUsedPercent > 85) {
      await this.alertService.sendAlert({
        level: 'warning',
        title: `èŠ‚ç‚¹${metrics.nodeName}å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜`,
        message: `JVMå †å†…å­˜ä½¿ç”¨ç‡ä¸º${metrics.jvmHeapUsedPercent}%`,
        details: metrics
      });
    }
    
    // CPUä½¿ç”¨ç‡å‘Šè­¦
    if (metrics.osCpuPercent > 80) {
      await this.alertService.sendAlert({
        level: 'warning',
        title: `èŠ‚ç‚¹${metrics.nodeName}CPUä½¿ç”¨ç‡è¿‡é«˜`,
        message: `CPUä½¿ç”¨ç‡ä¸º${metrics.osCpuPercent}%`,
        details: metrics
      });
    }
    
    // ç£ç›˜ä½¿ç”¨ç‡å‘Šè­¦
    if (metrics.fsUsedPercent > 85) {
      await this.alertService.sendAlert({
        level: 'warning',
        title: `èŠ‚ç‚¹${metrics.nodeName}ç£ç›˜ä½¿ç”¨ç‡è¿‡é«˜`,
        message: `ç£ç›˜ä½¿ç”¨ç‡ä¸º${metrics.fsUsedPercent.toFixed(2)}%`,
        details: metrics
      });
    }
    
    // æœç´¢å»¶è¿Ÿå‘Šè­¦
    if (metrics.searchLatency > 1000) {
      await this.alertService.sendAlert({
        level: 'warning',
        title: `èŠ‚ç‚¹${metrics.nodeName}æœç´¢å»¶è¿Ÿè¿‡é«˜`,
        message: `å¹³å‡æœç´¢å»¶è¿Ÿä¸º${metrics.searchLatency.toFixed(2)}ms`,
        details: metrics
      });
    }
  }
}
```

#### 7.2 ç´¢å¼•ç®¡ç†

##### 7.2.1 ç´¢å¼•ç»´æŠ¤æœåŠ¡
```typescript
// ç´¢å¼•ç»´æŠ¤æœåŠ¡
class IndexMaintenanceService {
  private esClient: Client;
  
  // ç´¢å¼•ä¼˜åŒ–
  async optimizeIndex(indexName: string) {
    console.log(`å¼€å§‹ä¼˜åŒ–ç´¢å¼•: ${indexName}`);
    
    // å¼ºåˆ¶åˆå¹¶æ®µ
    await this.esClient.indices.forcemerge({
      index: indexName,
      max_num_segments: 1,
      wait_for_completion: false
    });
    
    // åˆ·æ–°ç´¢å¼•
    await this.esClient.indices.refresh({
      index: indexName
    });
    
    console.log(`ç´¢å¼•ä¼˜åŒ–å®Œæˆ: ${indexName}`);
  }
  
  // ç´¢å¼•é‡å»º
  async reindexData(sourceIndex: string, targetIndex: string) {
    console.log(`å¼€å§‹é‡å»ºç´¢å¼•: ${sourceIndex} -> ${targetIndex}`);
    
    const reindexResponse = await this.esClient.reindex({
      body: {
        source: { index: sourceIndex },
        dest: { index: targetIndex }
      },
      wait_for_completion: false
    });
    
    const taskId = reindexResponse.body.task;
    
    // ç›‘æ§é‡å»ºè¿›åº¦
    await this.monitorReindexProgress(taskId);
    
    console.log(`ç´¢å¼•é‡å»ºå®Œæˆ: ${sourceIndex} -> ${targetIndex}`);
  }
  
  private async monitorReindexProgress(taskId: string) {
    while (true) {
      const taskStatus = await this.esClient.tasks.get({ task_id: taskId });
      
      if (taskStatus.body.completed) {
        console.log('é‡å»ºä»»åŠ¡å®Œæˆ');
        break;
      }
      
      const progress = taskStatus.body.task.status;
      console.log(`é‡å»ºè¿›åº¦: ${progress.created}/${progress.total}`);
      
      await new Promise(resolve => setTimeout(resolve, 5000));
    }
  }
  
  // æ¸…ç†è¿‡æœŸç´¢å¼•
  async cleanupExpiredIndices() {
    const indices = await this.esClient.cat.indices({ format: 'json' });
    const now = new Date();
    
    for (const index of indices.body) {
      const indexName = index.index;
      
      // è·³è¿‡ç³»ç»Ÿç´¢å¼•
      if (indexName.startsWith('.')) {
        continue;
      }
      
      // æ£€æŸ¥ç´¢å¼•åˆ›å»ºæ—¶é—´
      const indexStats = await this.esClient.indices.stats({ index: indexName });
      const creationDate = new Date(indexStats.body.indices[indexName].primaries.docs.creation_date);
      
      // åˆ é™¤è¶…è¿‡90å¤©çš„æ—¥å¿—ç´¢å¼•
      if (indexName.includes('logs') && this.daysBetween(creationDate, now) > 90) {
        console.log(`åˆ é™¤è¿‡æœŸç´¢å¼•: ${indexName}`);
        await this.esClient.indices.delete({ index: indexName });
      }
      
      // åˆ é™¤è¶…è¿‡30å¤©çš„ä¸´æ—¶ç´¢å¼•
      if (indexName.includes('temp') && this.daysBetween(creationDate, now) > 30) {
        console.log(`åˆ é™¤ä¸´æ—¶ç´¢å¼•: ${indexName}`);
        await this.esClient.indices.delete({ index: indexName });
      }
    }
  }
  
  private daysBetween(date1: Date, date2: Date): number {
    const diffTime = Math.abs(date2.getTime() - date1.getTime());
    return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  }
}
```

---

## ğŸ“Š ç›‘æ§ä¸è¿ç»´

### 1. ç›‘æ§æŒ‡æ ‡è®¾è®¡

#### 1.1 æ ¸å¿ƒç›‘æ§æŒ‡æ ‡

| æŒ‡æ ‡ç±»åˆ« | æŒ‡æ ‡åç§° | é˜ˆå€¼ | å‘Šè­¦çº§åˆ« |
|---------|---------|------|---------|
| **æ€§èƒ½æŒ‡æ ‡** | å¹³å‡å“åº”æ—¶é—´ | >500ms | Warning |
| | 95%å“åº”æ—¶é—´ | >1000ms | Critical |
| | QPS | >1000/s | Info |
| **å¯ç”¨æ€§æŒ‡æ ‡** | é›†ç¾¤çŠ¶æ€ | Yellow/Red | Warning/Critical |
| | èŠ‚ç‚¹å¯ç”¨æ€§ | <100% | Critical |
| | ç´¢å¼•å¥åº·åº¦ | <95% | Warning |
| **èµ„æºæŒ‡æ ‡** | JVMå †å†…å­˜ä½¿ç”¨ç‡ | >85% | Warning |
| | CPUä½¿ç”¨ç‡ | >80% | Warning |
| | ç£ç›˜ä½¿ç”¨ç‡ | >85% | Warning |
| **ä¸šåŠ¡æŒ‡æ ‡** | æœç´¢æˆåŠŸç‡ | <95% | Warning |
| | ç´¢å¼•æ›´æ–°å»¶è¿Ÿ | >30s | Warning |
| | ç¼“å­˜å‘½ä¸­ç‡ | <80% | Warning |

#### 1.2 å‘Šè­¦ç­–ç•¥

```typescript
// å‘Šè­¦ç­–ç•¥é…ç½®
const alertRules = {
  performance: {
    avgResponseTime: {
      threshold: 500,
      duration: '5m',
      severity: 'warning'
    },
    p95ResponseTime: {
      threshold: 1000,
      duration: '2m',
      severity: 'critical'
    }
  },
  availability: {
    clusterStatus: {
      condition: 'status != "green"',
      duration: '1m',
      severity: 'critical'
    }
  },
  resources: {
    jvmHeapUsage: {
      threshold: 85,
      duration: '5m',
      severity: 'warning'
    }
  }
};
```

### 2. è¿ç»´å·¥å…·

#### 2.1 æœç´¢ç®¡ç†åå°

```typescript
// æœç´¢ç®¡ç†åå°API
class SearchAdminController {
  // è·å–é›†ç¾¤çŠ¶æ€
  @Get('/cluster/status')
  async getClusterStatus() {
    return await this.clusterHealthMonitor.checkClusterHealth();
  }
  
  // è·å–æ€§èƒ½æŒ‡æ ‡
  @Get('/metrics/performance')
  async getPerformanceMetrics(@Query() query: MetricsQuery) {
    return await this.performanceMonitor.getMetrics(query);
  }
  
  // é‡å»ºç´¢å¼•
  @Post('/index/:name/reindex')
  async reindexData(@Param('name') indexName: string) {
    return await this.indexMaintenanceService.reindexData(indexName, `${indexName}_new`);
  }
  
  // æ¸…ç†ç¼“å­˜
  @Delete('/cache/clear')
  async clearCache(@Body() request: ClearCacheRequest) {
    return await this.cacheService.clearCache(request.pattern);
  }
}
```

---

## ğŸ”„ æ‰©å±•æ€§è®¾è®¡

### 1. æ°´å¹³æ‰©å±•

#### 1.1 åˆ†ç‰‡ç­–ç•¥
- **äº§å“ç´¢å¼•**ï¼šæŒ‰åˆ†ç±»åˆ†ç‰‡ï¼Œæ”¯æŒç‹¬ç«‹æ‰©å±•
- **è®¢å•ç´¢å¼•**ï¼šæŒ‰æ—¶é—´åˆ†ç‰‡ï¼Œæ”¯æŒå†å²æ•°æ®å½’æ¡£
- **ç”¨æˆ·ç´¢å¼•**ï¼šæŒ‰åœ°åŒºåˆ†ç‰‡ï¼Œæ”¯æŒåœ°åŸŸåŒ–éƒ¨ç½²

#### 1.2 é›†ç¾¤æ‰©å±•
- **è¯»å†™åˆ†ç¦»**ï¼šä¸“ç”¨å†™å…¥èŠ‚ç‚¹å’ŒæŸ¥è¯¢èŠ‚ç‚¹
- **å†·çƒ­åˆ†ç¦»**ï¼šçƒ­æ•°æ®SSDå­˜å‚¨ï¼Œå†·æ•°æ®æœºæ¢°ç¡¬ç›˜
- **å¤šé›†ç¾¤**ï¼šæŒ‰ä¸šåŠ¡çº¿éƒ¨ç½²ç‹¬ç«‹é›†ç¾¤

### 2. åŠŸèƒ½æ‰©å±•

#### 2.1 AIæœç´¢å¢å¼º
- **è¯­ä¹‰æœç´¢**ï¼šåŸºäºå‘é‡ç›¸ä¼¼åº¦çš„è¯­ä¹‰åŒ¹é…
- **æ™ºèƒ½æ¨è**ï¼šåŸºäºç”¨æˆ·è¡Œä¸ºçš„ä¸ªæ€§åŒ–æ¨è
- **è‡ªç„¶è¯­è¨€æŸ¥è¯¢**ï¼šæ”¯æŒè‡ªç„¶è¯­è¨€è½¬æ¢ä¸ºç»“æ„åŒ–æŸ¥è¯¢

#### 2.2 å¤šåª’ä½“æœç´¢
- **å›¾ç‰‡æœç´¢**ï¼šåŸºäºå›¾åƒè¯†åˆ«çš„å•†å“æœç´¢
- **è¯­éŸ³æœç´¢**ï¼šè¯­éŸ³è½¬æ–‡å­—çš„æœç´¢åŠŸèƒ½
- **è§†é¢‘æœç´¢**ï¼šè§†é¢‘å†…å®¹çš„å…³é”®è¯æå–å’Œæœç´¢

---

## ğŸ“‹ æ€»ç»“

æœ¬æœç´¢å¼•æ“è®¾è®¡æ–‡æ¡£ä¸ºç½—è±L2Cé”€å”®ç®¡ç†ç³»ç»Ÿæä¾›äº†å®Œæ•´çš„æœç´¢è§£å†³æ–¹æ¡ˆï¼Œä¸»è¦ç‰¹ç‚¹åŒ…æ‹¬ï¼š

### ğŸ¯ æ ¸å¿ƒä¼˜åŠ¿

1. **ç»Ÿä¸€æœç´¢æ¶æ„**ï¼šæä¾›äº§å“ã€è®¢å•ã€ç”¨æˆ·ç­‰å…¨æ–¹ä½æœç´¢èƒ½åŠ›
2. **æ™ºèƒ½æœç´¢ä½“éªŒ**ï¼šæ”¯æŒä¸­æ–‡åˆ†è¯ã€æ‹¼éŸ³æœç´¢ã€æ™ºèƒ½çº é”™ã€ä¸ªæ€§åŒ–æ¨è
3. **é«˜æ€§èƒ½è®¾è®¡**ï¼šåˆ†å±‚ç¼“å­˜ã€æŸ¥è¯¢ä¼˜åŒ–ã€ç´¢å¼•ä¼˜åŒ–ç¡®ä¿æ¯«ç§’çº§å“åº”
4. **å®æ—¶æ•°æ®åŒæ­¥**ï¼šCanal+æ¶ˆæ¯é˜Ÿåˆ—å®ç°æ•°æ®å®æ—¶åŒæ­¥
5. **å®Œå–„ç›‘æ§è¿ç»´**ï¼šå…¨æ–¹ä½ç›‘æ§æŒ‡æ ‡å’Œè‡ªåŠ¨åŒ–è¿ç»´å·¥å…·

### ğŸ”§ æŠ€æœ¯äº®ç‚¹

- **æ··åˆæœç´¢å¼•æ“**ï¼šElasticsearch + Redis + å…³ç³»æ•°æ®åº“çš„æ··åˆæ¶æ„
- **æ™ºèƒ½åˆ†è¯**ï¼šIKåˆ†è¯å™¨ + æ‹¼éŸ³æœç´¢ + è‡ªå®šä¹‰è¯å…¸
- **ä¸ªæ€§åŒ–æœç´¢**ï¼šåŸºäºç”¨æˆ·è¡Œä¸ºçš„æ™ºèƒ½æ¨èå’Œæƒé‡è°ƒæ•´
- **å®‰å…¨æ§åˆ¶**ï¼šç»†ç²’åº¦æƒé™æ§åˆ¶å’Œæœç´¢å®¡è®¡
- **å¼¹æ€§æ‰©å±•**ï¼šæ”¯æŒæ°´å¹³æ‰©å±•å’Œå¤šé›†ç¾¤éƒ¨ç½²

### ğŸ“ˆ ä¸šåŠ¡ä»·å€¼

- **ç”¨æˆ·ä½“éªŒæå‡**ï¼šå¿«é€Ÿã€å‡†ç¡®ã€æ™ºèƒ½çš„æœç´¢ä½“éªŒ
- **è¿è¥æ•ˆç‡æå‡**ï¼šå¸®åŠ©ç”¨æˆ·å¿«é€Ÿæ‰¾åˆ°æ‰€éœ€ä¿¡æ¯
- **æ•°æ®ä»·å€¼æŒ–æ˜**ï¼šé€šè¿‡æœç´¢åˆ†ææŒ–æ˜ç”¨æˆ·éœ€æ±‚
- **ç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–**ï¼šå‡å°‘æ•°æ®åº“å‹åŠ›ï¼Œæå‡æ•´ä½“æ€§èƒ½

è¯¥è®¾è®¡æ–¹æ¡ˆè§£å†³äº†ç³»ç»Ÿä¸­æœç´¢åŠŸèƒ½ç¼ºå¤±ã€æœç´¢ä½“éªŒå·®ã€æ€§èƒ½ç“¶é¢ˆç­‰å…³é”®é—®é¢˜ï¼Œä¸ºL2Cé”€å”®ç®¡ç†ç³»ç»Ÿæä¾›äº†å¼ºå¤§çš„æœç´¢èƒ½åŠ›æ”¯æ’‘ã€‚
