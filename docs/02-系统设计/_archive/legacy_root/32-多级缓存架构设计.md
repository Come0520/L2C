# 多级缓存架构设计

## 1. 概述

### 1.1 设计目标
- 提升系统响应速度，减少数据库访问压力
- 构建多层次缓存体系，实现就近访问
- 提高系统可用性和容错能力
- 降低带宽成本和服务器负载
- 支持缓存预热、失效和一致性管理

### 1.2 缓存层次
- **L1 - 浏览器缓存**：客户端本地缓存
- **L2 - CDN缓存**：边缘节点缓存
- **L3 - 负载均衡器缓存**：网关层缓存
- **L4 - 应用缓存**：JVM内存缓存
- **L5 - 分布式缓存**：Redis集群缓存
- **L6 - 数据库缓存**：MySQL查询缓存

### 1.3 缓存策略
- **Cache-Aside**：旁路缓存模式
- **Write-Through**：写穿透模式
- **Write-Behind**：写回模式
- **Refresh-Ahead**：预刷新模式

## 2. 整体架构设计

### 2.1 架构图
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   浏览器缓存     │    │   CDN边缘缓存    │    │   网关层缓存     │
│                 │    │                 │    │                 │
│ - HTTP缓存      │◄──►│ - 静态资源      │◄──►│ - API响应       │
│ - LocalStorage  │    │ - 动态内容      │    │ - 路由缓存      │
│ - SessionStorage│    │ - 图片/视频     │    │ - 限流缓存      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   应用层缓存     │    │   分布式缓存     │    │   数据库缓存     │
│                 │    │                 │    │                 │
│ - JVM堆内存     │◄──►│ - Redis集群     │◄──►│ - 查询缓存      │
│ - 堆外内存      │    │ - 数据分片      │    │ - 缓冲池        │
│ - 本地文件      │    │ - 主从复制      │    │ - 索引缓存      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 2.2 数据流向
```
用户请求 → 浏览器缓存 → CDN缓存 → 网关缓存 → 应用缓存 → Redis缓存 → 数据库
    ↑                                                              ↓
    └─────────────────── 缓存命中返回 ←─────────────────────────────┘
```

## 3. 浏览器缓存设计

### 3.1 HTTP缓存策略
```typescript
interface HTTPCacheConfig {
  // 强缓存配置
  cacheControl: {
    maxAge: number;           // 缓存有效期(秒)
    sMaxAge?: number;         // 代理缓存有效期
    public?: boolean;         // 是否允许代理缓存
    private?: boolean;        // 仅允许浏览器缓存
    noCache?: boolean;        // 需要验证缓存
    noStore?: boolean;        // 禁止缓存
    mustRevalidate?: boolean; // 必须重新验证
  };
  
  // 协商缓存配置
  etag?: string;              // 实体标签
  lastModified?: Date;        // 最后修改时间
  
  // 自定义头部
  customHeaders?: Record<string, string>;
}

// 不同资源的缓存策略
const cacheStrategies = {
  // 静态资源 - 长期缓存
  staticAssets: {
    cacheControl: {
      maxAge: 31536000, // 1年
      public: true
    }
  },
  
  // API数据 - 短期缓存
  apiData: {
    cacheControl: {
      maxAge: 300, // 5分钟
      private: true,
      mustRevalidate: true
    }
  },
  
  // 用户数据 - 协商缓存
  userData: {
    cacheControl: {
      noCache: true
    },
    etag: true,
    lastModified: true
  },
  
  // 敏感数据 - 禁止缓存
  sensitiveData: {
    cacheControl: {
      noStore: true,
      noCache: true,
      private: true
    }
  }
};
```

### 3.2 本地存储策略
```typescript
interface LocalStorageManager {
  // 设置缓存
  set(key: string, value: any, ttl?: number): void;
  
  // 获取缓存
  get(key: string): any;
  
  // 删除缓存
  remove(key: string): void;
  
  // 清空缓存
  clear(): void;
  
  // 检查过期
  isExpired(key: string): boolean;
}

class LocalStorageManagerImpl implements LocalStorageManager {
  set(key: string, value: any, ttl?: number): void {
    const item = {
      value: value,
      timestamp: Date.now(),
      ttl: ttl
    };
    
    try {
      localStorage.setItem(key, JSON.stringify(item));
    } catch (error) {
      // 存储空间不足时清理过期数据
      this.cleanup();
      localStorage.setItem(key, JSON.stringify(item));
    }
  }
  
  get(key: string): any {
    const itemStr = localStorage.getItem(key);
    if (!itemStr) return null;
    
    const item = JSON.parse(itemStr);
    
    // 检查是否过期
    if (item.ttl && Date.now() - item.timestamp > item.ttl * 1000) {
      localStorage.removeItem(key);
      return null;
    }
    
    return item.value;
  }
  
  private cleanup(): void {
    const keys = Object.keys(localStorage);
    keys.forEach(key => {
      if (this.isExpired(key)) {
        localStorage.removeItem(key);
      }
    });
  }
}
```

## 4. CDN缓存设计

### 4.1 CDN配置策略
```yaml
# CDN缓存配置
cdn_config:
  # 静态资源缓存
  static_resources:
    - path: "*.js"
      cache_time: 31536000  # 1年
      gzip: true
      brotli: true
    - path: "*.css"
      cache_time: 31536000  # 1年
      gzip: true
    - path: "*.png,*.jpg,*.gif"
      cache_time: 2592000   # 30天
      webp: true
      
  # 动态内容缓存
  dynamic_content:
    - path: "/api/products/*"
      cache_time: 300       # 5分钟
      cache_key: "$uri$args"
      vary: "Accept-Encoding,User-Agent"
    - path: "/api/news/*"
      cache_time: 1800      # 30分钟
      
  # 缓存清理规则
  purge_rules:
    - trigger: "content_update"
      pattern: "/api/products/*"
    - trigger: "manual"
      pattern: "/*"
      
  # 回源配置
  origin_config:
    host: "api.company.com"
    protocol: "https"
    timeout: 30
    retry: 3
```

### 4.2 CDN缓存管理
```typescript
interface CDNManager {
  // 预热缓存
  warmup(urls: string[]): Promise<void>;
  
  // 清理缓存
  purge(pattern: string): Promise<void>;
  
  // 获取缓存状态
  getCacheStatus(url: string): Promise<CacheStatus>;
  
  // 设置缓存规则
  setCacheRule(rule: CacheRule): Promise<void>;
}

class CDNManagerImpl implements CDNManager {
  async warmup(urls: string[]): Promise<void> {
    // 批量预热CDN缓存
    const batchSize = 100;
    for (let i = 0; i < urls.length; i += batchSize) {
      const batch = urls.slice(i, i + batchSize);
      await this.warmupBatch(batch);
    }
  }
  
  async purge(pattern: string): Promise<void> {
    // 清理匹配模式的缓存
    await this.cdnProvider.purgeCache({
      type: 'pattern',
      value: pattern
    });
  }
  
  private async warmupBatch(urls: string[]): Promise<void> {
    const promises = urls.map(url => 
      this.cdnProvider.warmupCache(url)
    );
    await Promise.all(promises);
  }
}
```

## 5. 应用层缓存设计

### 5.1 多级本地缓存
```typescript
interface LocalCacheManager {
  // L1缓存 - 堆内存
  l1Cache: Map<string, CacheItem>;
  
  // L2缓存 - 堆外内存
  l2Cache: OffHeapCache;
  
  // L3缓存 - 本地文件
  l3Cache: FileCache;
  
  // 获取缓存
  get(key: string): Promise<any>;
  
  // 设置缓存
  set(key: string, value: any, ttl?: number): Promise<void>;
  
  // 删除缓存
  delete(key: string): Promise<void>;
  
  // 清空缓存
  clear(): Promise<void>;
}

class LocalCacheManagerImpl implements LocalCacheManager {
  private readonly l1Cache = new Map<string, CacheItem>();
  private readonly l2Cache: OffHeapCache;
  private readonly l3Cache: FileCache;
  
  constructor() {
    this.l2Cache = new OffHeapCache({
      maxSize: '1GB',
      ttl: 3600
    });
    
    this.l3Cache = new FileCache({
      directory: '/tmp/cache',
      maxSize: '10GB',
      ttl: 86400
    });
  }
  
  async get(key: string): Promise<any> {
    // L1缓存查找
    let item = this.l1Cache.get(key);
    if (item && !this.isExpired(item)) {
      this.updateAccessTime(item);
      return item.value;
    }
    
    // L2缓存查找
    const l2Value = await this.l2Cache.get(key);
    if (l2Value) {
      // 回填L1缓存
      this.l1Cache.set(key, {
        value: l2Value,
        timestamp: Date.now(),
        accessTime: Date.now(),
        ttl: 300 // L1缓存较短TTL
      });
      return l2Value;
    }
    
    // L3缓存查找
    const l3Value = await this.l3Cache.get(key);
    if (l3Value) {
      // 回填L2和L1缓存
      await this.l2Cache.set(key, l3Value, 3600);
      this.l1Cache.set(key, {
        value: l3Value,
        timestamp: Date.now(),
        accessTime: Date.now(),
        ttl: 300
      });
      return l3Value;
    }
    
    return null;
  }
  
  async set(key: string, value: any, ttl: number = 3600): Promise<void> {
    // 同时写入三级缓存
    const promises = [
      this.setL1Cache(key, value, Math.min(ttl, 300)),
      this.l2Cache.set(key, value, Math.min(ttl, 3600)),
      this.l3Cache.set(key, value, ttl)
    ];
    
    await Promise.all(promises);
  }
  
  private setL1Cache(key: string, value: any, ttl: number): void {
    // L1缓存大小限制
    if (this.l1Cache.size >= 10000) {
      this.evictL1Cache();
    }
    
    this.l1Cache.set(key, {
      value: value,
      timestamp: Date.now(),
      accessTime: Date.now(),
      ttl: ttl
    });
  }
  
  private evictL1Cache(): void {
    // LRU淘汰策略
    const entries = Array.from(this.l1Cache.entries());
    entries.sort((a, b) => a[1].accessTime - b[1].accessTime);
    
    // 淘汰最久未访问的25%
    const evictCount = Math.floor(entries.length * 0.25);
    for (let i = 0; i < evictCount; i++) {
      this.l1Cache.delete(entries[i][0]);
    }
  }
}
```

### 5.2 缓存注解支持
```typescript
// 缓存装饰器
function Cacheable(options: CacheOptions) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      const cacheKey = generateCacheKey(target.constructor.name, propertyName, args);
      
      // 尝试从缓存获取
      const cached = await cacheManager.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      // 执行原方法
      const result = await method.apply(this, args);
      
      // 存入缓存
      await cacheManager.set(cacheKey, result, options.ttl);
      
      return result;
    };
  };
}

// 缓存清理装饰器
function CacheEvict(options: EvictOptions) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      const result = await method.apply(this, args);
      
      // 清理相关缓存
      if (options.key) {
        await cacheManager.delete(options.key);
      }
      
      if (options.pattern) {
        await cacheManager.deleteByPattern(options.pattern);
      }
      
      return result;
    };
  };
}

// 使用示例
class ProductService {
  @Cacheable({ ttl: 3600, key: 'product:${id}' })
  async getProduct(id: number): Promise<Product> {
    return await this.productRepository.findById(id);
  }
  
  @CacheEvict({ pattern: 'product:*' })
  async updateProduct(product: Product): Promise<void> {
    await this.productRepository.save(product);
  }
}
```

## 6. Redis分布式缓存设计

### 6.1 Redis集群架构
```yaml
# Redis集群配置
redis_cluster:
  # 主从配置
  master_slave:
    - master: "redis-master-1:6379"
      slaves: 
        - "redis-slave-1:6379"
        - "redis-slave-2:6379"
    - master: "redis-master-2:6379"
      slaves:
        - "redis-slave-3:6379"
        - "redis-slave-4:6379"
        
  # 哨兵配置
  sentinel:
    nodes:
      - "redis-sentinel-1:26379"
      - "redis-sentinel-2:26379"
      - "redis-sentinel-3:26379"
    quorum: 2
    
  # 分片配置
  sharding:
    algorithm: "consistent_hash"
    virtual_nodes: 160
    
  # 连接池配置
  connection_pool:
    max_connections: 100
    min_idle: 10
    max_idle: 50
    timeout: 5000
```

### 6.2 Redis缓存管理
```typescript
interface RedisCacheManager {
  // 基础操作
  get(key: string): Promise<string | null>;
  set(key: string, value: string, ttl?: number): Promise<void>;
  delete(key: string): Promise<void>;
  exists(key: string): Promise<boolean>;
  
  // 批量操作
  mget(keys: string[]): Promise<(string | null)[]>;
  mset(keyValues: Record<string, string>, ttl?: number): Promise<void>;
  
  // 模式操作
  keys(pattern: string): Promise<string[]>;
  deleteByPattern(pattern: string): Promise<number>;
  
  // 数据结构操作
  hget(key: string, field: string): Promise<string | null>;
  hset(key: string, field: string, value: string): Promise<void>;
  lpush(key: string, ...values: string[]): Promise<number>;
  rpop(key: string): Promise<string | null>;
  
  // 分布式锁
  lock(key: string, ttl: number): Promise<string | null>;
  unlock(key: string, token: string): Promise<boolean>;
}

class RedisCacheManagerImpl implements RedisCacheManager {
  private readonly redis: Redis.Cluster;
  
  constructor(config: RedisConfig) {
    this.redis = new Redis.Cluster(config.nodes, {
      redisOptions: {
        password: config.password,
        connectTimeout: config.timeout,
        lazyConnect: true
      },
      maxRetriesPerRequest: 3,
      retryDelayOnFailover: 100
    });
  }
  
  async get(key: string): Promise<string | null> {
    try {
      return await this.redis.get(key);
    } catch (error) {
      console.error(`Redis get error for key ${key}:`, error);
      return null;
    }
  }
  
  async set(key: string, value: string, ttl?: number): Promise<void> {
    try {
      if (ttl) {
        await this.redis.setex(key, ttl, value);
      } else {
        await this.redis.set(key, value);
      }
    } catch (error) {
      console.error(`Redis set error for key ${key}:`, error);
      throw error;
    }
  }
  
  async deleteByPattern(pattern: string): Promise<number> {
    const keys = await this.keys(pattern);
    if (keys.length === 0) return 0;
    
    // 批量删除
    const pipeline = this.redis.pipeline();
    keys.forEach(key => pipeline.del(key));
    const results = await pipeline.exec();
    
    return results?.filter(result => result[1] === 1).length || 0;
  }
  
  async lock(key: string, ttl: number): Promise<string | null> {
    const token = this.generateToken();
    const result = await this.redis.set(key, token, 'PX', ttl, 'NX');
    return result === 'OK' ? token : null;
  }
  
  async unlock(key: string, token: string): Promise<boolean> {
    const script = `
      if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
      else
        return 0
      end
    `;
    
    const result = await this.redis.eval(script, 1, key, token);
    return result === 1;
  }
  
  private generateToken(): string {
    return Math.random().toString(36).substring(2) + Date.now().toString(36);
  }
}
```

### 6.3 缓存一致性策略
```typescript
interface CacheConsistencyManager {
  // 缓存更新策略
  updateCache(key: string, value: any): Promise<void>;
  
  // 缓存失效策略
  invalidateCache(keys: string[]): Promise<void>;
  
  // 缓存同步策略
  syncCache(source: string, target: string): Promise<void>;
  
  // 版本控制
  setVersion(key: string, version: number): Promise<void>;
  getVersion(key: string): Promise<number>;
}

class CacheConsistencyManagerImpl implements CacheConsistencyManager {
  async updateCache(key: string, value: any): Promise<void> {
    const version = await this.getNextVersion(key);
    
    // 使用事务确保原子性
    const multi = this.redis.multi();
    multi.set(key, JSON.stringify(value));
    multi.set(`${key}:version`, version);
    multi.publish(`cache:update:${key}`, JSON.stringify({ key, version }));
    
    await multi.exec();
  }
  
  async invalidateCache(keys: string[]): Promise<void> {
    // 批量失效缓存
    const multi = this.redis.multi();
    
    keys.forEach(key => {
      multi.del(key);
      multi.del(`${key}:version`);
      multi.publish(`cache:invalidate:${key}`, key);
    });
    
    await multi.exec();
  }
  
  private async getNextVersion(key: string): Promise<number> {
    const current = await this.redis.get(`${key}:version`);
    return current ? parseInt(current) + 1 : 1;
  }
}
```

## 7. 缓存预热策略

### 7.1 预热任务调度
```typescript
interface CacheWarmupManager {
  // 启动时预热
  warmupOnStartup(): Promise<void>;
  
  // 定时预热
  scheduleWarmup(cron: string, task: WarmupTask): void;
  
  // 手动预热
  manualWarmup(keys: string[]): Promise<void>;
  
  // 智能预热
  intelligentWarmup(): Promise<void>;
}

class CacheWarmupManagerImpl implements CacheWarmupManager {
  private readonly scheduler = new CronScheduler();
  private readonly analytics = new CacheAnalytics();
  
  async warmupOnStartup(): Promise<void> {
    console.log('Starting cache warmup...');
    
    // 预热热点数据
    await this.warmupHotData();
    
    // 预热基础配置
    await this.warmupBaseConfig();
    
    // 预热用户会话数据
    await this.warmupUserSessions();
    
    console.log('Cache warmup completed');
  }
  
  scheduleWarmup(cron: string, task: WarmupTask): void {
    this.scheduler.schedule(cron, async () => {
      try {
        await task.execute();
        console.log(`Scheduled warmup task ${task.name} completed`);
      } catch (error) {
        console.error(`Scheduled warmup task ${task.name} failed:`, error);
      }
    });
  }
  
  async intelligentWarmup(): Promise<void> {
    // 分析访问模式
    const hotKeys = await this.analytics.getHotKeys();
    const predictedKeys = await this.analytics.getPredictedKeys();
    
    // 预热热点数据
    await this.warmupKeys(hotKeys);
    
    // 预热预测数据
    await this.warmupKeys(predictedKeys);
  }
  
  private async warmupHotData(): Promise<void> {
    const hotDataTasks = [
      () => this.warmupProducts(),
      () => this.warmupCategories(),
      () => this.warmupConfigs(),
      () => this.warmupMenus()
    ];
    
    // 并行执行预热任务
    await Promise.all(hotDataTasks.map(task => task()));
  }
  
  private async warmupProducts(): Promise<void> {
    const products = await this.productService.getHotProducts(100);
    const promises = products.map(product => 
      this.cacheManager.set(`product:${product.id}`, product, 3600)
    );
    await Promise.all(promises);
  }
}
```

### 7.2 预热数据源配置
```yaml
# 缓存预热配置
cache_warmup:
  # 启动预热
  startup:
    enabled: true
    timeout: 300  # 5分钟超时
    tasks:
      - name: "hot_products"
        priority: 1
        data_source: "SELECT * FROM products WHERE is_hot = 1"
        cache_key: "product:${id}"
        ttl: 3600
      - name: "categories"
        priority: 2
        data_source: "SELECT * FROM categories WHERE status = 'active'"
        cache_key: "category:${id}"
        ttl: 7200
        
  # 定时预热
  scheduled:
    - name: "daily_reports"
      cron: "0 6 * * *"  # 每天6点
      data_source: "CALL generate_daily_report()"
      cache_key: "report:daily:${date}"
      ttl: 86400
    - name: "user_preferences"
      cron: "0 */4 * * *"  # 每4小时
      data_source: "SELECT * FROM user_preferences WHERE updated_at > NOW() - INTERVAL 4 HOUR"
      cache_key: "user:pref:${user_id}"
      ttl: 14400
      
  # 智能预热
  intelligent:
    enabled: true
    ml_model: "cache_prediction_v1"
    prediction_window: 3600  # 1小时预测窗口
    confidence_threshold: 0.8
```

## 8. 缓存监控告警

### 8.1 监控指标
```typescript
interface CacheMetrics {
  // 命中率指标
  hitRate: number;
  missRate: number;
  
  // 性能指标
  avgResponseTime: number;
  p95ResponseTime: number;
  p99ResponseTime: number;
  
  // 容量指标
  memoryUsage: number;
  keyCount: number;
  evictionCount: number;
  
  // 错误指标
  errorRate: number;
  timeoutCount: number;
  connectionErrors: number;
}

class CacheMonitor {
  private metrics: CacheMetrics = {
    hitRate: 0,
    missRate: 0,
    avgResponseTime: 0,
    p95ResponseTime: 0,
    p99ResponseTime: 0,
    memoryUsage: 0,
    keyCount: 0,
    evictionCount: 0,
    errorRate: 0,
    timeoutCount: 0,
    connectionErrors: 0
  };
  
  private responseTimes: number[] = [];
  private readonly maxSamples = 1000;
  
  recordHit(): void {
    this.metrics.hitRate = this.updateRate(this.metrics.hitRate, true);
  }
  
  recordMiss(): void {
    this.metrics.missRate = this.updateRate(this.metrics.missRate, true);
  }
  
  recordResponseTime(time: number): void {
    this.responseTimes.push(time);
    if (this.responseTimes.length > this.maxSamples) {
      this.responseTimes.shift();
    }
    
    this.updateResponseTimeMetrics();
  }
  
  private updateResponseTimeMetrics(): void {
    const sorted = [...this.responseTimes].sort((a, b) => a - b);
    const len = sorted.length;
    
    this.metrics.avgResponseTime = sorted.reduce((a, b) => a + b, 0) / len;
    this.metrics.p95ResponseTime = sorted[Math.floor(len * 0.95)];
    this.metrics.p99ResponseTime = sorted[Math.floor(len * 0.99)];
  }
  
  getMetrics(): CacheMetrics {
    return { ...this.metrics };
  }
}
```

### 8.2 告警规则
```yaml
# 缓存告警配置
cache_alerts:
  # 命中率告警
  hit_rate:
    threshold: 0.8  # 命中率低于80%
    duration: 300   # 持续5分钟
    severity: "warning"
    message: "Cache hit rate is below 80%"
    
  # 响应时间告警
  response_time:
    p95_threshold: 100  # P95响应时间超过100ms
    duration: 180       # 持续3分钟
    severity: "warning"
    message: "Cache P95 response time exceeds 100ms"
    
  # 内存使用告警
  memory_usage:
    threshold: 0.9  # 内存使用率超过90%
    duration: 60    # 持续1分钟
    severity: "critical"
    message: "Cache memory usage exceeds 90%"
    
  # 连接错误告警
  connection_errors:
    threshold: 10   # 连接错误超过10次/分钟
    duration: 60
    severity: "critical"
    message: "Cache connection errors exceed threshold"
    
  # 缓存雪崩告警
  cache_avalanche:
    miss_rate_threshold: 0.8  # 缓存失效率超过80%
    duration: 30              # 持续30秒
    severity: "critical"
    message: "Potential cache avalanche detected"
```

## 9. 缓存优化策略

### 9.1 缓存穿透防护
```typescript
class CachePenetrationProtection {
  private readonly bloomFilter: BloomFilter;
  private readonly nullValueCache = new Map<string, number>();
  
  constructor() {
    // 布隆过滤器，预估100万个key，误判率0.1%
    this.bloomFilter = new BloomFilter(1000000, 0.001);
  }
  
  async get(key: string, loader: () => Promise<any>): Promise<any> {
    // 1. 检查布隆过滤器
    if (!this.bloomFilter.contains(key)) {
      // key不存在，直接返回null
      return null;
    }
    
    // 2. 检查缓存
    const cached = await this.cacheManager.get(key);
    if (cached !== null) {
      return cached === 'NULL_VALUE' ? null : cached;
    }
    
    // 3. 检查空值缓存
    if (this.nullValueCache.has(key)) {
      const timestamp = this.nullValueCache.get(key)!;
      if (Date.now() - timestamp < 60000) { // 1分钟内不重复查询
        return null;
      }
    }
    
    // 4. 加载数据
    const value = await loader();
    
    if (value === null) {
      // 缓存空值，防止穿透
      await this.cacheManager.set(key, 'NULL_VALUE', 300); // 5分钟
      this.nullValueCache.set(key, Date.now());
    } else {
      // 缓存正常值
      await this.cacheManager.set(key, value, 3600);
      this.bloomFilter.add(key);
    }
    
    return value;
  }
}
```

### 9.2 缓存雪崩防护
```typescript
class CacheAvalancheProtection {
  private readonly loadingKeys = new Set<string>();
  private readonly randomTTL = true;
  
  async get(key: string, loader: () => Promise<any>): Promise<any> {
    // 1. 检查缓存
    const cached = await this.cacheManager.get(key);
    if (cached !== null) {
      return cached;
    }
    
    // 2. 防止并发加载
    if (this.loadingKeys.has(key)) {
      // 等待其他线程加载完成
      await this.waitForLoading(key);
      return await this.cacheManager.get(key);
    }
    
    this.loadingKeys.add(key);
    
    try {
      // 3. 加载数据
      const value = await loader();
      
      // 4. 随机TTL防止同时过期
      const baseTTL = 3600;
      const randomTTL = this.randomTTL 
        ? baseTTL + Math.floor(Math.random() * 600) // 基础TTL + 0-10分钟随机
        : baseTTL;
      
      await this.cacheManager.set(key, value, randomTTL);
      
      return value;
    } finally {
      this.loadingKeys.delete(key);
    }
  }
  
  private async waitForLoading(key: string): Promise<void> {
    let attempts = 0;
    const maxAttempts = 50; // 最多等待5秒
    
    while (this.loadingKeys.has(key) && attempts < maxAttempts) {
      await new Promise(resolve => setTimeout(resolve, 100));
      attempts++;
    }
  }
}
```

### 9.3 缓存击穿防护
```typescript
class CacheBreakdownProtection {
  private readonly mutexes = new Map<string, Promise<any>>();
  
  async get(key: string, loader: () => Promise<any>): Promise<any> {
    // 1. 检查缓存
    const cached = await this.cacheManager.get(key);
    if (cached !== null) {
      return cached;
    }
    
    // 2. 检查是否有其他线程正在加载
    if (this.mutexes.has(key)) {
      return await this.mutexes.get(key)!;
    }
    
    // 3. 创建加载Promise
    const loadPromise = this.loadWithMutex(key, loader);
    this.mutexes.set(key, loadPromise);
    
    try {
      return await loadPromise;
    } finally {
      this.mutexes.delete(key);
    }
  }
  
  private async loadWithMutex(key: string, loader: () => Promise<any>): Promise<any> {
    // 分布式锁防止多实例同时加载
    const lockKey = `lock:${key}`;
    const lockToken = await this.cacheManager.lock(lockKey, 30000); // 30秒锁
    
    if (!lockToken) {
      // 获取锁失败，等待并重试
      await new Promise(resolve => setTimeout(resolve, 100));
      const cached = await this.cacheManager.get(key);
      if (cached !== null) {
        return cached;
      }
      // 递归重试
      return await this.get(key, loader);
    }
    
    try {
      // 再次检查缓存（双重检查）
      const cached = await this.cacheManager.get(key);
      if (cached !== null) {
        return cached;
      }
      
      // 加载数据
      const value = await loader();
      await this.cacheManager.set(key, value, 3600);
      
      return value;
    } finally {
      await this.cacheManager.unlock(lockKey, lockToken);
    }
  }
}
```

## 10. 性能优化

### 10.1 缓存压缩
```typescript
interface CacheCompression {
  compress(data: string): Promise<Buffer>;
  decompress(data: Buffer): Promise<string>;
}

class GzipCompression implements CacheCompression {
  private readonly threshold = 1024; // 1KB以上才压缩
  
  async compress(data: string): Promise<Buffer> {
    if (data.length < this.threshold) {
      return Buffer.from(data, 'utf8');
    }
    
    return new Promise((resolve, reject) => {
      zlib.gzip(data, (err, result) => {
        if (err) reject(err);
        else resolve(result);
      });
    });
  }
  
  async decompress(data: Buffer): Promise<string> {
    // 检查是否为压缩数据
    if (data[0] !== 0x1f || data[1] !== 0x8b) {
      return data.toString('utf8');
    }
    
    return new Promise((resolve, reject) => {
      zlib.gunzip(data, (err, result) => {
        if (err) reject(err);
        else resolve(result.toString('utf8'));
      });
    });
  }
}
```

### 10.2 批量操作优化
```typescript
class BatchCacheOperations {
  private readonly batchSize = 100;
  private readonly batchTimeout = 10; // 10ms
  
  private pendingGets: Array<{
    key: string;
    resolve: (value: any) => void;
    reject: (error: any) => void;
  }> = [];
  
  private pendingSets: Array<{
    key: string;
    value: any;
    ttl?: number;
    resolve: () => void;
    reject: (error: any) => void;
  }> = [];
  
  private getTimer?: NodeJS.Timeout;
  private setTimer?: NodeJS.Timeout;
  
  async get(key: string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.pendingGets.push({ key, resolve, reject });
      
      if (this.pendingGets.length >= this.batchSize) {
        this.flushGets();
      } else if (!this.getTimer) {
        this.getTimer = setTimeout(() => this.flushGets(), this.batchTimeout);
      }
    });
  }
  
  async set(key: string, value: any, ttl?: number): Promise<void> {
    return new Promise((resolve, reject) => {
      this.pendingSets.push({ key, value, ttl, resolve, reject });
      
      if (this.pendingSets.length >= this.batchSize) {
        this.flushSets();
      } else if (!this.setTimer) {
        this.setTimer = setTimeout(() => this.flushSets(), this.batchTimeout);
      }
    });
  }
  
  private async flushGets(): Promise<void> {
    if (this.getTimer) {
      clearTimeout(this.getTimer);
      this.getTimer = undefined;
    }
    
    const batch = this.pendingGets.splice(0);
    if (batch.length === 0) return;
    
    try {
      const keys = batch.map(item => item.key);
      const values = await this.cacheManager.mget(keys);
      
      batch.forEach((item, index) => {
        item.resolve(values[index]);
      });
    } catch (error) {
      batch.forEach(item => item.reject(error));
    }
  }
  
  private async flushSets(): Promise<void> {
    if (this.setTimer) {
      clearTimeout(this.setTimer);
      this.setTimer = undefined;
    }
    
    const batch = this.pendingSets.splice(0);
    if (batch.length === 0) return;
    
    try {
      const keyValues: Record<string, string> = {};
      batch.forEach(item => {
        keyValues[item.key] = JSON.stringify(item.value);
      });
      
      await this.cacheManager.mset(keyValues);
      
      batch.forEach(item => item.resolve());
    } catch (error) {
      batch.forEach(item => item.reject(error));
    }
  }
}
```

## 11. 运维管理

### 11.1 缓存运维工具
```typescript
interface CacheAdminTool {
  // 缓存统计
  getStatistics(): Promise<CacheStatistics>;
  
  // 缓存清理
  cleanup(options: CleanupOptions): Promise<CleanupResult>;
  
  // 缓存迁移
  migrate(source: string, target: string): Promise<void>;
  
  // 缓存备份
  backup(path: string): Promise<void>;
  
  // 缓存恢复
  restore(path: string): Promise<void>;
}

class CacheAdminToolImpl implements CacheAdminTool {
  async getStatistics(): Promise<CacheStatistics> {
    const [redisInfo, localStats] = await Promise.all([
      this.getRedisStatistics(),
      this.getLocalCacheStatistics()
    ]);
    
    return {
      redis: redisInfo,
      local: localStats,
      overall: this.calculateOverallStats(redisInfo, localStats)
    };
  }
  
  async cleanup(options: CleanupOptions): Promise<CleanupResult> {
    let deletedKeys = 0;
    let freedMemory = 0;
    
    // 清理过期键
    if (options.expiredKeys) {
      const expired = await this.findExpiredKeys();
      deletedKeys += await this.deleteKeys(expired);
    }
    
    // 清理LRU键
    if (options.lruKeys && options.maxMemoryUsage) {
      const currentUsage = await this.getMemoryUsage();
      if (currentUsage > options.maxMemoryUsage) {
        const lruKeys = await this.findLRUKeys(currentUsage - options.maxMemoryUsage);
        deletedKeys += await this.deleteKeys(lruKeys);
      }
    }
    
    // 清理匹配模式的键
    if (options.patterns) {
      for (const pattern of options.patterns) {
        const keys = await this.cacheManager.keys(pattern);
        deletedKeys += await this.deleteKeys(keys);
      }
    }
    
    return { deletedKeys, freedMemory };
  }
}
```

### 11.2 缓存配置管理
```yaml
# 缓存配置文件
cache_config:
  # 全局配置
  global:
    default_ttl: 3600
    max_memory: "2GB"
    eviction_policy: "allkeys-lru"
    compression: true
    
  # 应用缓存配置
  local_cache:
    l1_cache:
      max_size: 10000
      ttl: 300
      eviction: "lru"
    l2_cache:
      max_size: "1GB"
      ttl: 3600
      type: "off_heap"
    l3_cache:
      max_size: "10GB"
      ttl: 86400
      type: "file"
      directory: "/tmp/cache"
      
  # Redis配置
  redis:
    cluster:
      nodes:
        - "redis-1:6379"
        - "redis-2:6379"
        - "redis-3:6379"
    pool:
      max_connections: 100
      min_idle: 10
      timeout: 5000
    sentinel:
      master_name: "mymaster"
      nodes:
        - "sentinel-1:26379"
        - "sentinel-2:26379"
        - "sentinel-3:26379"
        
  # 业务缓存配置
  business_cache:
    product:
      ttl: 3600
      compression: true
      preload: true
    user:
      ttl: 1800
      encryption: true
    session:
      ttl: 7200
      storage: "redis"
```

这个多级缓存架构设计文档涵盖了从浏览器缓存到数据库缓存的完整缓存体系，包括缓存策略、一致性管理、性能优化、监控告警等各个方面，为系统提供了全面的缓存解决方案。
