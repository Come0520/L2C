# æœåŠ¡é™çº§å’Œç†”æ–­æœºåˆ¶è®¾è®¡

## 1. æ¦‚è¿°

### 1.1 è®¾è®¡ç›®æ ‡
- ä¿éšœç³»ç»Ÿåœ¨é«˜è´Ÿè½½æˆ–æ•…éšœæƒ…å†µä¸‹çš„å¯ç”¨æ€§
- é˜²æ­¢çº§è”æ•…éšœå’Œé›ªå´©æ•ˆåº”
- æä¾›ä¼˜é›…çš„æœåŠ¡é™çº§ç­–ç•¥
- å®ç°è‡ªåŠ¨æ•…éšœæ£€æµ‹å’Œæ¢å¤
- ä¿æŠ¤æ ¸å¿ƒä¸šåŠ¡åŠŸèƒ½çš„æ­£å¸¸è¿è¡Œ

### 1.2 æ ¸å¿ƒç»„ä»¶
- **é™æµå™¨ï¼ˆRate Limiterï¼‰**ï¼šæ§åˆ¶è¯·æ±‚æµé‡
- **ç†”æ–­å™¨ï¼ˆCircuit Breakerï¼‰**ï¼šé˜²æ­¢æ•…éšœä¼ æ’­
- **é™çº§å™¨ï¼ˆDegraderï¼‰**ï¼šæä¾›å¤‡ç”¨æ–¹æ¡ˆ
- **ç›‘æ§å™¨ï¼ˆMonitorï¼‰**ï¼šå®æ—¶ç›‘æ§ç³»ç»ŸçŠ¶æ€
- **æ¢å¤å™¨ï¼ˆRecoveryï¼‰**ï¼šè‡ªåŠ¨æ•…éšœæ¢å¤

### 1.3 ä¿æŠ¤ç­–ç•¥
- **æµé‡æ§åˆ¶**ï¼šä»¤ç‰Œæ¡¶ã€æ¼æ¡¶ã€æ»‘åŠ¨çª—å£
- **æ•…éšœéš”ç¦»**ï¼šç†”æ–­ã€èˆ±å£ã€è¶…æ—¶
- **æœåŠ¡é™çº§**ï¼šåŠŸèƒ½é™çº§ã€æ•°æ®é™çº§ã€UIé™çº§
- **è‡ªé€‚åº”ä¿æŠ¤**ï¼šåŠ¨æ€é˜ˆå€¼ã€æ™ºèƒ½è°ƒèŠ‚

## 2. æ•´ä½“æ¶æ„è®¾è®¡

### 2.1 æ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        æœåŠ¡ä¿æŠ¤å±‚                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   é™æµå™¨    â”‚  â”‚   ç†”æ–­å™¨    â”‚  â”‚   é™çº§å™¨    â”‚  â”‚   ç›‘æ§å™¨    â”‚ â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚ â”‚
â”‚  â”‚ - ä»¤ç‰Œæ¡¶    â”‚  â”‚ - çŠ¶æ€æœº    â”‚  â”‚ - ç­–ç•¥å¼•æ“  â”‚  â”‚ - æŒ‡æ ‡æ”¶é›†  â”‚ â”‚
â”‚  â”‚ - æ¼æ¡¶      â”‚  â”‚ - é˜ˆå€¼æ£€æµ‹  â”‚  â”‚ - å¤‡ç”¨æ–¹æ¡ˆ  â”‚  â”‚ - å‘Šè­¦é€šçŸ¥  â”‚ â”‚
â”‚  â”‚ - æ»‘åŠ¨çª—å£  â”‚  â”‚ - è‡ªåŠ¨æ¢å¤  â”‚  â”‚ - ä¼˜é›…é€€åŒ–  â”‚  â”‚ - å¥åº·æ£€æŸ¥  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ä¸šåŠ¡æœåŠ¡å±‚                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  ç”¨æˆ·æœåŠ¡   â”‚  â”‚  è®¢å•æœåŠ¡   â”‚  â”‚  æ”¯ä»˜æœåŠ¡   â”‚  â”‚  åº“å­˜æœåŠ¡   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        æ•°æ®å­˜å‚¨å±‚                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   MySQL     â”‚  â”‚    Redis    â”‚  â”‚   MongoDB   â”‚  â”‚     MQ      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ä¿æŠ¤æœºåˆ¶å±‚æ¬¡
```
è¯·æ±‚æµé‡ â†’ å…¨å±€é™æµ â†’ æœåŠ¡é™æµ â†’ æ¥å£é™æµ â†’ ç†”æ–­æ£€æµ‹ â†’ é™çº§ç­–ç•¥ â†’ ä¸šåŠ¡å¤„ç†
    â†‘                                                              â†“
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ç›‘æ§åé¦ˆ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 3. é™æµæœºåˆ¶è®¾è®¡

### 3.1 é™æµç®—æ³•å®ç°
```typescript
// ä»¤ç‰Œæ¡¶ç®—æ³•
class TokenBucket {
  private tokens: number;
  private lastRefillTime: number;
  
  constructor(
    private capacity: number,      // æ¡¶å®¹é‡
    private refillRate: number,    // ä»¤ç‰Œç”Ÿæˆé€Ÿç‡ï¼ˆä¸ª/ç§’ï¼‰
    private refillPeriod: number = 1000  // è¡¥å……å‘¨æœŸï¼ˆæ¯«ç§’ï¼‰
  ) {
    this.tokens = capacity;
    this.lastRefillTime = Date.now();
  }
  
  tryAcquire(permits: number = 1): boolean {
    this.refill();
    
    if (this.tokens >= permits) {
      this.tokens -= permits;
      return true;
    }
    
    return false;
  }
  
  private refill(): void {
    const now = Date.now();
    const timePassed = now - this.lastRefillTime;
    
    if (timePassed >= this.refillPeriod) {
      const tokensToAdd = Math.floor(timePassed / this.refillPeriod) * this.refillRate;
      this.tokens = Math.min(this.capacity, this.tokens + tokensToAdd);
      this.lastRefillTime = now;
    }
  }
  
  getAvailableTokens(): number {
    this.refill();
    return this.tokens;
  }
}

// æ¼æ¡¶ç®—æ³•
class LeakyBucket {
  private queue: Array<{ timestamp: number; request: any }> = [];
  
  constructor(
    private capacity: number,      // æ¡¶å®¹é‡
    private leakRate: number,      // æ¼å‡ºé€Ÿç‡ï¼ˆä¸ª/ç§’ï¼‰
    private leakPeriod: number = 1000  // æ¼å‡ºå‘¨æœŸï¼ˆæ¯«ç§’ï¼‰
  ) {
    this.startLeaking();
  }
  
  tryAdd(request: any): boolean {
    this.leak();
    
    if (this.queue.length < this.capacity) {
      this.queue.push({
        timestamp: Date.now(),
        request: request
      });
      return true;
    }
    
    return false;
  }
  
  private leak(): void {
    const now = Date.now();
    const leakCount = Math.floor(this.leakRate * this.leakPeriod / 1000);
    
    for (let i = 0; i < leakCount && this.queue.length > 0; i++) {
      const item = this.queue.shift();
      if (item) {
        this.processRequest(item.request);
      }
    }
  }
  
  private startLeaking(): void {
    setInterval(() => {
      this.leak();
    }, this.leakPeriod);
  }
  
  private processRequest(request: any): void {
    // å¤„ç†è¯·æ±‚çš„é€»è¾‘
    console.log('Processing request:', request);
  }
}

// æ»‘åŠ¨çª—å£ç®—æ³•
class SlidingWindow {
  private windows: Map<number, number> = new Map();
  
  constructor(
    private windowSize: number,    // çª—å£å¤§å°ï¼ˆæ¯«ç§’ï¼‰
    private maxRequests: number,   // æœ€å¤§è¯·æ±‚æ•°
    private subWindowCount: number = 10  // å­çª—å£æ•°é‡
  ) {}
  
  tryAcquire(): boolean {
    const now = Date.now();
    const windowStart = Math.floor(now / this.windowSize) * this.windowSize;
    const subWindowSize = this.windowSize / this.subWindowCount;
    const subWindowIndex = Math.floor((now - windowStart) / subWindowSize);
    
    // æ¸…ç†è¿‡æœŸçª—å£
    this.cleanupExpiredWindows(windowStart);
    
    // è®¡ç®—å½“å‰çª—å£çš„è¯·æ±‚æ•°
    const currentRequests = this.getCurrentRequests(windowStart);
    
    if (currentRequests < this.maxRequests) {
      // å¢åŠ å½“å‰å­çª—å£çš„è®¡æ•°
      const subWindowKey = windowStart + subWindowIndex * subWindowSize;
      this.windows.set(subWindowKey, (this.windows.get(subWindowKey) || 0) + 1);
      return true;
    }
    
    return false;
  }
  
  private getCurrentRequests(windowStart: number): number {
    let total = 0;
    const subWindowSize = this.windowSize / this.subWindowCount;
    
    for (let i = 0; i < this.subWindowCount; i++) {
      const subWindowKey = windowStart + i * subWindowSize;
      total += this.windows.get(subWindowKey) || 0;
    }
    
    return total;
  }
  
  private cleanupExpiredWindows(currentWindowStart: number): void {
    const expiredKeys: number[] = [];
    
    for (const [key] of this.windows) {
      if (key < currentWindowStart) {
        expiredKeys.push(key);
      }
    }
    
    expiredKeys.forEach(key => this.windows.delete(key));
  }
}
```

### 3.2 åˆ†å±‚é™æµç­–ç•¥
```typescript
interface RateLimitConfig {
  global: {
    qps: number;           // å…¨å±€QPSé™åˆ¶
    burst: number;         // çªå‘æµé‡å®¹é‡
    algorithm: 'token_bucket' | 'leaky_bucket' | 'sliding_window';
  };
  service: Record<string, {
    qps: number;           // æœåŠ¡çº§QPSé™åˆ¶
    concurrent: number;    // å¹¶å‘æ•°é™åˆ¶
    timeout: number;       // è¶…æ—¶æ—¶é—´
  }>;
  api: Record<string, {
    qps: number;           // æ¥å£çº§QPSé™åˆ¶
    user_qps: number;      // ç”¨æˆ·çº§QPSé™åˆ¶
    ip_qps: number;        // IPçº§QPSé™åˆ¶
  }>;
}

class HierarchicalRateLimiter {
  private globalLimiter: TokenBucket;
  private serviceLimiters: Map<string, TokenBucket> = new Map();
  private apiLimiters: Map<string, TokenBucket> = new Map();
  private userLimiters: Map<string, TokenBucket> = new Map();
  private ipLimiters: Map<string, TokenBucket> = new Map();
  
  constructor(private config: RateLimitConfig) {
    this.globalLimiter = new TokenBucket(
      config.global.burst,
      config.global.qps
    );
    
    this.initializeServiceLimiters();
    this.initializeApiLimiters();
  }
  
  async checkLimit(request: {
    service: string;
    api: string;
    userId?: string;
    clientIp: string;
  }): Promise<{ allowed: boolean; reason?: string }> {
    // 1. å…¨å±€é™æµæ£€æŸ¥
    if (!this.globalLimiter.tryAcquire()) {
      return { allowed: false, reason: 'Global rate limit exceeded' };
    }
    
    // 2. æœåŠ¡çº§é™æµæ£€æŸ¥
    const serviceLimiter = this.getServiceLimiter(request.service);
    if (!serviceLimiter.tryAcquire()) {
      return { allowed: false, reason: 'Service rate limit exceeded' };
    }
    
    // 3. æ¥å£çº§é™æµæ£€æŸ¥
    const apiLimiter = this.getApiLimiter(request.api);
    if (!apiLimiter.tryAcquire()) {
      return { allowed: false, reason: 'API rate limit exceeded' };
    }
    
    // 4. ç”¨æˆ·çº§é™æµæ£€æŸ¥
    if (request.userId) {
      const userLimiter = this.getUserLimiter(request.userId, request.api);
      if (!userLimiter.tryAcquire()) {
        return { allowed: false, reason: 'User rate limit exceeded' };
      }
    }
    
    // 5. IPçº§é™æµæ£€æŸ¥
    const ipLimiter = this.getIpLimiter(request.clientIp, request.api);
    if (!ipLimiter.tryAcquire()) {
      return { allowed: false, reason: 'IP rate limit exceeded' };
    }
    
    return { allowed: true };
  }
  
  private getServiceLimiter(service: string): TokenBucket {
    if (!this.serviceLimiters.has(service)) {
      const config = this.config.service[service];
      if (config) {
        this.serviceLimiters.set(service, new TokenBucket(
          config.qps * 2, // burst = 2 * qps
          config.qps
        ));
      }
    }
    
    return this.serviceLimiters.get(service) || this.globalLimiter;
  }
  
  private getApiLimiter(api: string): TokenBucket {
    if (!this.apiLimiters.has(api)) {
      const config = this.config.api[api];
      if (config) {
        this.apiLimiters.set(api, new TokenBucket(
          config.qps * 2,
          config.qps
        ));
      }
    }
    
    return this.apiLimiters.get(api) || this.globalLimiter;
  }
  
  private getUserLimiter(userId: string, api: string): TokenBucket {
    const key = `${userId}:${api}`;
    if (!this.userLimiters.has(key)) {
      const config = this.config.api[api];
      if (config && config.user_qps) {
        this.userLimiters.set(key, new TokenBucket(
          config.user_qps * 2,
          config.user_qps
        ));
      }
    }
    
    return this.userLimiters.get(key) || this.globalLimiter;
  }
  
  private getIpLimiter(ip: string, api: string): TokenBucket {
    const key = `${ip}:${api}`;
    if (!this.ipLimiters.has(key)) {
      const config = this.config.api[api];
      if (config && config.ip_qps) {
        this.ipLimiters.set(key, new TokenBucket(
          config.ip_qps * 2,
          config.ip_qps
        ));
      }
    }
    
    return this.ipLimiters.get(key) || this.globalLimiter;
  }
}
```

## 4. ç†”æ–­æœºåˆ¶è®¾è®¡

### 4.1 ç†”æ–­å™¨çŠ¶æ€æœº
```typescript
enum CircuitBreakerState {
  CLOSED = 'CLOSED',       // å…³é—­çŠ¶æ€ï¼Œæ­£å¸¸å¤„ç†è¯·æ±‚
  OPEN = 'OPEN',           // å¼€å¯çŠ¶æ€ï¼Œæ‹’ç»æ‰€æœ‰è¯·æ±‚
  HALF_OPEN = 'HALF_OPEN'  // åŠå¼€çŠ¶æ€ï¼Œå…è®¸å°‘é‡è¯·æ±‚æµ‹è¯•
}

interface CircuitBreakerConfig {
  failureThreshold: number;      // å¤±è´¥é˜ˆå€¼
  successThreshold: number;      // æˆåŠŸé˜ˆå€¼ï¼ˆåŠå¼€çŠ¶æ€ï¼‰
  timeout: number;               // è¶…æ—¶æ—¶é—´
  resetTimeout: number;          // é‡ç½®è¶…æ—¶æ—¶é—´
  monitoringPeriod: number;      // ç›‘æ§å‘¨æœŸ
  minimumRequests: number;       // æœ€å°è¯·æ±‚æ•°
}

class CircuitBreaker {
  private state: CircuitBreakerState = CircuitBreakerState.CLOSED;
  private failureCount: number = 0;
  private successCount: number = 0;
  private lastFailureTime: number = 0;
  private requestCount: number = 0;
  private lastResetTime: number = Date.now();
  
  constructor(
    private name: string,
    private config: CircuitBreakerConfig
  ) {}
  
  async execute<T>(operation: () => Promise<T>): Promise<T> {
    // æ£€æŸ¥ç†”æ–­å™¨çŠ¶æ€
    if (this.state === CircuitBreakerState.OPEN) {
      if (this.shouldAttemptReset()) {
        this.state = CircuitBreakerState.HALF_OPEN;
        this.successCount = 0;
        console.log(`Circuit breaker ${this.name} moved to HALF_OPEN state`);
      } else {
        throw new Error(`Circuit breaker ${this.name} is OPEN`);
      }
    }
    
    try {
      const startTime = Date.now();
      
      // è®¾ç½®è¶…æ—¶
      const timeoutPromise = new Promise<never>((_, reject) => {
        setTimeout(() => reject(new Error('Operation timeout')), this.config.timeout);
      });
      
      // æ‰§è¡Œæ“ä½œ
      const result = await Promise.race([operation(), timeoutPromise]);
      
      const duration = Date.now() - startTime;
      this.onSuccess(duration);
      
      return result;
    } catch (error) {
      this.onFailure(error);
      throw error;
    }
  }
  
  private onSuccess(duration: number): void {
    this.requestCount++;
    
    if (this.state === CircuitBreakerState.HALF_OPEN) {
      this.successCount++;
      
      if (this.successCount >= this.config.successThreshold) {
        this.reset();
        console.log(`Circuit breaker ${this.name} moved to CLOSED state`);
      }
    } else {
      // åœ¨CLOSEDçŠ¶æ€ä¸‹ï¼Œé‡ç½®å¤±è´¥è®¡æ•°
      this.failureCount = 0;
    }
  }
  
  private onFailure(error: any): void {
    this.requestCount++;
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.state === CircuitBreakerState.HALF_OPEN) {
      // åŠå¼€çŠ¶æ€ä¸‹ä»»ä½•å¤±è´¥éƒ½ä¼šé‡æ–°æ‰“å¼€ç†”æ–­å™¨
      this.state = CircuitBreakerState.OPEN;
      console.log(`Circuit breaker ${this.name} moved to OPEN state from HALF_OPEN`);
    } else if (this.shouldTrip()) {
      this.state = CircuitBreakerState.OPEN;
      console.log(`Circuit breaker ${this.name} tripped to OPEN state`);
    }
  }
  
  private shouldTrip(): boolean {
    // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æœ€å°è¯·æ±‚æ•°
    if (this.requestCount < this.config.minimumRequests) {
      return false;
    }
    
    // æ£€æŸ¥å¤±è´¥ç‡æ˜¯å¦è¶…è¿‡é˜ˆå€¼
    const failureRate = this.failureCount / this.requestCount;
    return failureRate >= this.config.failureThreshold;
  }
  
  private shouldAttemptReset(): boolean {
    return Date.now() - this.lastFailureTime >= this.config.resetTimeout;
  }
  
  private reset(): void {
    this.state = CircuitBreakerState.CLOSED;
    this.failureCount = 0;
    this.successCount = 0;
    this.requestCount = 0;
    this.lastResetTime = Date.now();
  }
  
  getState(): CircuitBreakerState {
    return this.state;
  }
  
  getMetrics(): {
    state: CircuitBreakerState;
    failureCount: number;
    successCount: number;
    requestCount: number;
    failureRate: number;
  } {
    return {
      state: this.state,
      failureCount: this.failureCount,
      successCount: this.successCount,
      requestCount: this.requestCount,
      failureRate: this.requestCount > 0 ? this.failureCount / this.requestCount : 0
    };
  }
}
```

### 4.2 ç†”æ–­å™¨ç®¡ç†å™¨
```typescript
class CircuitBreakerManager {
  private breakers: Map<string, CircuitBreaker> = new Map();
  private configs: Map<string, CircuitBreakerConfig> = new Map();
  
  constructor() {
    this.initializeDefaultConfigs();
    this.startMonitoring();
  }
  
  getBreaker(name: string): CircuitBreaker {
    if (!this.breakers.has(name)) {
      const config = this.configs.get(name) || this.getDefaultConfig();
      this.breakers.set(name, new CircuitBreaker(name, config));
    }
    
    return this.breakers.get(name)!;
  }
  
  async executeWithBreaker<T>(
    breakerName: string,
    operation: () => Promise<T>,
    fallback?: () => Promise<T>
  ): Promise<T> {
    const breaker = this.getBreaker(breakerName);
    
    try {
      return await breaker.execute(operation);
    } catch (error) {
      if (fallback) {
        console.log(`Executing fallback for ${breakerName}`);
        return await fallback();
      }
      throw error;
    }
  }
  
  configureBreaker(name: string, config: CircuitBreakerConfig): void {
    this.configs.set(name, config);
    
    // å¦‚æœç†”æ–­å™¨å·²å­˜åœ¨ï¼Œéœ€è¦é‡æ–°åˆ›å»º
    if (this.breakers.has(name)) {
      this.breakers.delete(name);
    }
  }
  
  getAllMetrics(): Record<string, any> {
    const metrics: Record<string, any> = {};
    
    for (const [name, breaker] of this.breakers) {
      metrics[name] = breaker.getMetrics();
    }
    
    return metrics;
  }
  
  private initializeDefaultConfigs(): void {
    // æ•°æ®åº“æœåŠ¡ç†”æ–­é…ç½®
    this.configs.set('database', {
      failureThreshold: 0.5,    // 50%å¤±è´¥ç‡
      successThreshold: 3,      // 3æ¬¡æˆåŠŸ
      timeout: 5000,            // 5ç§’è¶…æ—¶
      resetTimeout: 60000,      // 1åˆ†é’Ÿé‡ç½®
      monitoringPeriod: 10000,  // 10ç§’ç›‘æ§å‘¨æœŸ
      minimumRequests: 10       // æœ€å°‘10ä¸ªè¯·æ±‚
    });
    
    // å¤–éƒ¨APIç†”æ–­é…ç½®
    this.configs.set('external_api', {
      failureThreshold: 0.3,    // 30%å¤±è´¥ç‡
      successThreshold: 5,      // 5æ¬¡æˆåŠŸ
      timeout: 3000,            // 3ç§’è¶…æ—¶
      resetTimeout: 30000,      // 30ç§’é‡ç½®
      monitoringPeriod: 5000,   // 5ç§’ç›‘æ§å‘¨æœŸ
      minimumRequests: 5        // æœ€å°‘5ä¸ªè¯·æ±‚
    });
    
    // ç¼“å­˜æœåŠ¡ç†”æ–­é…ç½®
    this.configs.set('cache', {
      failureThreshold: 0.7,    // 70%å¤±è´¥ç‡
      successThreshold: 2,      // 2æ¬¡æˆåŠŸ
      timeout: 1000,            // 1ç§’è¶…æ—¶
      resetTimeout: 10000,      // 10ç§’é‡ç½®
      monitoringPeriod: 2000,   // 2ç§’ç›‘æ§å‘¨æœŸ
      minimumRequests: 3        // æœ€å°‘3ä¸ªè¯·æ±‚
    });
  }
  
  private getDefaultConfig(): CircuitBreakerConfig {
    return {
      failureThreshold: 0.5,
      successThreshold: 3,
      timeout: 5000,
      resetTimeout: 60000,
      monitoringPeriod: 10000,
      minimumRequests: 10
    };
  }
  
  private startMonitoring(): void {
    setInterval(() => {
      const metrics = this.getAllMetrics();
      console.log('Circuit Breaker Metrics:', JSON.stringify(metrics, null, 2));
      
      // å‘é€ç›‘æ§æ•°æ®åˆ°ç›‘æ§ç³»ç»Ÿ
      this.sendMetricsToMonitoring(metrics);
    }, 30000); // æ¯30ç§’è¾“å‡ºä¸€æ¬¡ç›‘æ§æ•°æ®
  }
  
  private sendMetricsToMonitoring(metrics: Record<string, any>): void {
    // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿçš„é€»è¾‘
    // è¿™é‡Œå¯ä»¥é›†æˆPrometheusã€Grafanaç­‰ç›‘æ§ç³»ç»Ÿ
  }
}
```

## 5. æœåŠ¡é™çº§è®¾è®¡

### 5.1 é™çº§ç­–ç•¥å¼•æ“
```typescript
enum DegradationLevel {
  NONE = 0,        // æ— é™çº§
  LIGHT = 1,       // è½»åº¦é™çº§
  MODERATE = 2,    // ä¸­åº¦é™çº§
  HEAVY = 3,       // é‡åº¦é™çº§
  EMERGENCY = 4    // ç´§æ€¥é™çº§
}

interface DegradationRule {
  id: string;
  name: string;
  level: DegradationLevel;
  conditions: DegradationCondition[];
  actions: DegradationAction[];
  priority: number;
  enabled: boolean;
}

interface DegradationCondition {
  type: 'cpu_usage' | 'memory_usage' | 'error_rate' | 'response_time' | 'qps';
  operator: '>' | '<' | '>=' | '<=' | '==';
  threshold: number;
  duration: number; // æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
}

interface DegradationAction {
  type: 'disable_feature' | 'use_cache' | 'return_default' | 'redirect' | 'limit_users';
  target: string;
  config: Record<string, any>;
}

class DegradationEngine {
  private rules: Map<string, DegradationRule> = new Map();
  private currentLevel: DegradationLevel = DegradationLevel.NONE;
  private activeRules: Set<string> = new Set();
  private metrics: SystemMetrics;
  
  constructor(metrics: SystemMetrics) {
    this.metrics = metrics;
    this.initializeDefaultRules();
    this.startMonitoring();
  }
  
  async checkDegradation(): Promise<void> {
    const currentMetrics = await this.metrics.getCurrentMetrics();
    const triggeredRules: DegradationRule[] = [];
    
    // æ£€æŸ¥æ‰€æœ‰è§„åˆ™
    for (const rule of this.rules.values()) {
      if (!rule.enabled) continue;
      
      if (this.evaluateRule(rule, currentMetrics)) {
        triggeredRules.push(rule);
      }
    }
    
    // æŒ‰ä¼˜å…ˆçº§æ’åº
    triggeredRules.sort((a, b) => b.priority - a.priority);
    
    // æ‰§è¡Œé™çº§åŠ¨ä½œ
    for (const rule of triggeredRules) {
      if (!this.activeRules.has(rule.id)) {
        await this.executeRule(rule);
        this.activeRules.add(rule.id);
      }
    }
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦æ¢å¤
    await this.checkRecovery(currentMetrics);
  }
  
  private evaluateRule(rule: DegradationRule, metrics: any): boolean {
    return rule.conditions.every(condition => {
      const value = metrics[condition.type];
      
      switch (condition.operator) {
        case '>': return value > condition.threshold;
        case '<': return value < condition.threshold;
        case '>=': return value >= condition.threshold;
        case '<=': return value <= condition.threshold;
        case '==': return value === condition.threshold;
        default: return false;
      }
    });
  }
  
  private async executeRule(rule: DegradationRule): Promise<void> {
    console.log(`Executing degradation rule: ${rule.name}`);
    
    for (const action of rule.actions) {
      await this.executeAction(action);
    }
    
    // æ›´æ–°å½“å‰é™çº§çº§åˆ«
    if (rule.level > this.currentLevel) {
      this.currentLevel = rule.level;
    }
  }
  
  private async executeAction(action: DegradationAction): Promise<void> {
    switch (action.type) {
      case 'disable_feature':
        await this.disableFeature(action.target, action.config);
        break;
      case 'use_cache':
        await this.enableCacheMode(action.target, action.config);
        break;
      case 'return_default':
        await this.setDefaultResponse(action.target, action.config);
        break;
      case 'redirect':
        await this.setupRedirect(action.target, action.config);
        break;
      case 'limit_users':
        await this.limitUsers(action.target, action.config);
        break;
    }
  }
  
  private async disableFeature(feature: string, config: any): Promise<void> {
    // ç¦ç”¨ç‰¹å®šåŠŸèƒ½
    console.log(`Disabling feature: ${feature}`);
    // å®ç°åŠŸèƒ½ç¦ç”¨é€»è¾‘
  }
  
  private async enableCacheMode(service: string, config: any): Promise<void> {
    // å¯ç”¨ç¼“å­˜æ¨¡å¼
    console.log(`Enabling cache mode for service: ${service}`);
    // å®ç°ç¼“å­˜æ¨¡å¼é€»è¾‘
  }
  
  private async setDefaultResponse(api: string, config: any): Promise<void> {
    // è®¾ç½®é»˜è®¤å“åº”
    console.log(`Setting default response for API: ${api}`);
    // å®ç°é»˜è®¤å“åº”é€»è¾‘
  }
  
  private async setupRedirect(source: string, config: any): Promise<void> {
    // è®¾ç½®é‡å®šå‘
    console.log(`Setting up redirect from ${source} to ${config.target}`);
    // å®ç°é‡å®šå‘é€»è¾‘
  }
  
  private async limitUsers(target: string, config: any): Promise<void> {
    // é™åˆ¶ç”¨æˆ·è®¿é—®
    console.log(`Limiting users for ${target}, config:`, config);
    // å®ç°ç”¨æˆ·é™åˆ¶é€»è¾‘
  }
  
  private async checkRecovery(metrics: any): Promise<void> {
    const rulesToRemove: string[] = [];
    
    for (const ruleId of this.activeRules) {
      const rule = this.rules.get(ruleId);
      if (rule && !this.evaluateRule(rule, metrics)) {
        // æ¡ä»¶ä¸å†æ»¡è¶³ï¼Œå¯ä»¥æ¢å¤
        await this.recoverFromRule(rule);
        rulesToRemove.push(ruleId);
      }
    }
    
    // ç§»é™¤å·²æ¢å¤çš„è§„åˆ™
    rulesToRemove.forEach(ruleId => this.activeRules.delete(ruleId));
    
    // é‡æ–°è®¡ç®—å½“å‰é™çº§çº§åˆ«
    this.recalculateCurrentLevel();
  }
  
  private async recoverFromRule(rule: DegradationRule): Promise<void> {
    console.log(`Recovering from degradation rule: ${rule.name}`);
    
    // æ‰§è¡Œæ¢å¤åŠ¨ä½œ
    for (const action of rule.actions) {
      await this.recoverFromAction(action);
    }
  }
  
  private async recoverFromAction(action: DegradationAction): Promise<void> {
    switch (action.type) {
      case 'disable_feature':
        await this.enableFeature(action.target);
        break;
      case 'use_cache':
        await this.disableCacheMode(action.target);
        break;
      case 'return_default':
        await this.removeDefaultResponse(action.target);
        break;
      case 'redirect':
        await this.removeRedirect(action.target);
        break;
      case 'limit_users':
        await this.removeLimitUsers(action.target);
        break;
    }
  }
  
  private recalculateCurrentLevel(): void {
    let maxLevel = DegradationLevel.NONE;
    
    for (const ruleId of this.activeRules) {
      const rule = this.rules.get(ruleId);
      if (rule && rule.level > maxLevel) {
        maxLevel = rule.level;
      }
    }
    
    this.currentLevel = maxLevel;
  }
  
  private initializeDefaultRules(): void {
    // CPUä½¿ç”¨ç‡è¿‡é«˜é™çº§è§„åˆ™
    this.rules.set('high_cpu', {
      id: 'high_cpu',
      name: 'High CPU Usage Degradation',
      level: DegradationLevel.MODERATE,
      conditions: [
        {
          type: 'cpu_usage',
          operator: '>',
          threshold: 80,
          duration: 30000 // 30ç§’
        }
      ],
      actions: [
        {
          type: 'disable_feature',
          target: 'recommendation_engine',
          config: {}
        },
        {
          type: 'use_cache',
          target: 'product_service',
          config: { ttl: 300 }
        }
      ],
      priority: 100,
      enabled: true
    });
    
    // é”™è¯¯ç‡è¿‡é«˜é™çº§è§„åˆ™
    this.rules.set('high_error_rate', {
      id: 'high_error_rate',
      name: 'High Error Rate Degradation',
      level: DegradationLevel.HEAVY,
      conditions: [
        {
          type: 'error_rate',
          operator: '>',
          threshold: 10, // 10%
          duration: 60000 // 1åˆ†é’Ÿ
        }
      ],
      actions: [
        {
          type: 'return_default',
          target: 'user_recommendations',
          config: { response: { items: [], message: 'Service temporarily unavailable' } }
        }
      ],
      priority: 200,
      enabled: true
    });
  }
  
  private startMonitoring(): void {
    setInterval(async () => {
      await this.checkDegradation();
    }, 10000); // æ¯10ç§’æ£€æŸ¥ä¸€æ¬¡
  }
  
  getCurrentLevel(): DegradationLevel {
    return this.currentLevel;
  }
  
  getActiveRules(): string[] {
    return Array.from(this.activeRules);
  }
}
```

### 5.2 é™çº§è£…é¥°å™¨
```typescript
// é™çº§è£…é¥°å™¨
function Degradable(options: {
  level: DegradationLevel;
  fallback?: () => any;
  cacheKey?: string;
  defaultValue?: any;
}) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      const degradationEngine = DegradationEngine.getInstance();
      const currentLevel = degradationEngine.getCurrentLevel();
      
      // æ£€æŸ¥æ˜¯å¦éœ€è¦é™çº§
      if (currentLevel >= options.level) {
        console.log(`Method ${propertyName} degraded due to level ${currentLevel}`);
        
        // å°è¯•ä»ç¼“å­˜è·å–
        if (options.cacheKey) {
          const cached = await cacheManager.get(options.cacheKey);
          if (cached) {
            return cached;
          }
        }
        
        // æ‰§è¡Œé™çº§é€»è¾‘
        if (options.fallback) {
          return await options.fallback();
        }
        
        // è¿”å›é»˜è®¤å€¼
        if (options.defaultValue !== undefined) {
          return options.defaultValue;
        }
        
        throw new Error(`Service degraded: ${propertyName}`);
      }
      
      // æ­£å¸¸æ‰§è¡Œ
      try {
        const result = await method.apply(this, args);
        
        // ç¼“å­˜ç»“æœ
        if (options.cacheKey) {
          await cacheManager.set(options.cacheKey, result, 300);
        }
        
        return result;
      } catch (error) {
        // å‡ºé”™æ—¶å°è¯•é™çº§å¤„ç†
        if (options.fallback) {
          console.log(`Method ${propertyName} failed, using fallback`);
          return await options.fallback();
        }
        
        throw error;
      }
    };
  };
}

// ä½¿ç”¨ç¤ºä¾‹
class ProductService {
  @Degradable({
    level: DegradationLevel.LIGHT,
    cacheKey: 'product_recommendations',
    fallback: async () => {
      return { items: [], message: 'Recommendations temporarily unavailable' };
    }
  })
  async getRecommendations(userId: number): Promise<any> {
    // å¤æ‚çš„æ¨èç®—æ³•
    return await this.complexRecommendationAlgorithm(userId);
  }
  
  @Degradable({
    level: DegradationLevel.MODERATE,
    defaultValue: { reviews: [], count: 0 }
  })
  async getProductReviews(productId: number): Promise<any> {
    // è·å–äº§å“è¯„è®º
    return await this.fetchProductReviews(productId);
  }
}
```

## 6. ç›‘æ§å’Œå‘Šè­¦

### 6.1 ç³»ç»ŸæŒ‡æ ‡ç›‘æ§
```typescript
interface SystemMetrics {
  cpu_usage: number;        // CPUä½¿ç”¨ç‡
  memory_usage: number;     // å†…å­˜ä½¿ç”¨ç‡
  disk_usage: number;       // ç£ç›˜ä½¿ç”¨ç‡
  network_io: number;       // ç½‘ç»œIO
  error_rate: number;       // é”™è¯¯ç‡
  response_time: number;    // å“åº”æ—¶é—´
  qps: number;             // æ¯ç§’è¯·æ±‚æ•°
  active_connections: number; // æ´»è·ƒè¿æ¥æ•°
}

class MetricsCollector {
  private metrics: SystemMetrics = {
    cpu_usage: 0,
    memory_usage: 0,
    disk_usage: 0,
    network_io: 0,
    error_rate: 0,
    response_time: 0,
    qps: 0,
    active_connections: 0
  };
  
  private requestCounts: number[] = [];
  private responseTimes: number[] = [];
  private errorCounts: number[] = [];
  
  constructor() {
    this.startCollection();
  }
  
  recordRequest(responseTime: number, isError: boolean = false): void {
    this.responseTimes.push(responseTime);
    this.requestCounts.push(Date.now());
    
    if (isError) {
      this.errorCounts.push(Date.now());
    }
    
    // ä¿æŒæœ€è¿‘1000ä¸ªè®°å½•
    if (this.responseTimes.length > 1000) {
      this.responseTimes.shift();
    }
    if (this.requestCounts.length > 1000) {
      this.requestCounts.shift();
    }
    if (this.errorCounts.length > 1000) {
      this.errorCounts.shift();
    }
  }
  
  async getCurrentMetrics(): Promise<SystemMetrics> {
    // æ›´æ–°è®¡ç®—æŒ‡æ ‡
    this.updateCalculatedMetrics();
    
    // è·å–ç³»ç»ŸæŒ‡æ ‡
    await this.updateSystemMetrics();
    
    return { ...this.metrics };
  }
  
  private updateCalculatedMetrics(): void {
    const now = Date.now();
    const oneMinuteAgo = now - 60000;
    
    // è®¡ç®—QPSï¼ˆæœ€è¿‘1åˆ†é’Ÿï¼‰
    const recentRequests = this.requestCounts.filter(time => time > oneMinuteAgo);
    this.metrics.qps = recentRequests.length / 60;
    
    // è®¡ç®—é”™è¯¯ç‡ï¼ˆæœ€è¿‘1åˆ†é’Ÿï¼‰
    const recentErrors = this.errorCounts.filter(time => time > oneMinuteAgo);
    this.metrics.error_rate = recentRequests.length > 0 
      ? (recentErrors.length / recentRequests.length) * 100 
      : 0;
    
    // è®¡ç®—å¹³å‡å“åº”æ—¶é—´
    if (this.responseTimes.length > 0) {
      this.metrics.response_time = this.responseTimes.reduce((a, b) => a + b, 0) / this.responseTimes.length;
    }
  }
  
  private async updateSystemMetrics(): Promise<void> {
    try {
      // è·å–CPUä½¿ç”¨ç‡
      this.metrics.cpu_usage = await this.getCpuUsage();
      
      // è·å–å†…å­˜ä½¿ç”¨ç‡
      this.metrics.memory_usage = await this.getMemoryUsage();
      
      // è·å–ç£ç›˜ä½¿ç”¨ç‡
      this.metrics.disk_usage = await this.getDiskUsage();
      
      // è·å–ç½‘ç»œIO
      this.metrics.network_io = await this.getNetworkIO();
      
      // è·å–æ´»è·ƒè¿æ¥æ•°
      this.metrics.active_connections = await this.getActiveConnections();
    } catch (error) {
      console.error('Failed to update system metrics:', error);
    }
  }
  
  private async getCpuUsage(): Promise<number> {
    // å®ç°CPUä½¿ç”¨ç‡è·å–é€»è¾‘
    return Math.random() * 100; // æ¨¡æ‹Ÿæ•°æ®
  }
  
  private async getMemoryUsage(): Promise<number> {
    // å®ç°å†…å­˜ä½¿ç”¨ç‡è·å–é€»è¾‘
    const used = process.memoryUsage();
    const total = require('os').totalmem();
    return (used.heapUsed / total) * 100;
  }
  
  private async getDiskUsage(): Promise<number> {
    // å®ç°ç£ç›˜ä½¿ç”¨ç‡è·å–é€»è¾‘
    return Math.random() * 100; // æ¨¡æ‹Ÿæ•°æ®
  }
  
  private async getNetworkIO(): Promise<number> {
    // å®ç°ç½‘ç»œIOè·å–é€»è¾‘
    return Math.random() * 1000; // æ¨¡æ‹Ÿæ•°æ®
  }
  
  private async getActiveConnections(): Promise<number> {
    // å®ç°æ´»è·ƒè¿æ¥æ•°è·å–é€»è¾‘
    return Math.floor(Math.random() * 1000); // æ¨¡æ‹Ÿæ•°æ®
  }
  
  private startCollection(): void {
    // æ¯5ç§’æ›´æ–°ä¸€æ¬¡ç³»ç»ŸæŒ‡æ ‡
    setInterval(async () => {
      await this.updateSystemMetrics();
    }, 5000);
  }
}
```

### 6.2 å‘Šè­¦ç³»ç»Ÿ
```typescript
interface AlertRule {
  id: string;
  name: string;
  metric: keyof SystemMetrics;
  operator: '>' | '<' | '>=' | '<=' | '==';
  threshold: number;
  duration: number;        // æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
  severity: 'info' | 'warning' | 'error' | 'critical';
  enabled: boolean;
  channels: string[];      // å‘Šè­¦æ¸ é“
}

interface Alert {
  id: string;
  ruleId: string;
  message: string;
  severity: string;
  timestamp: number;
  resolved: boolean;
  resolvedAt?: number;
}

class AlertManager {
  private rules: Map<string, AlertRule> = new Map();
  private activeAlerts: Map<string, Alert> = new Map();
  private alertHistory: Alert[] = [];
  private metricsCollector: MetricsCollector;
  
  constructor(metricsCollector: MetricsCollector) {
    this.metricsCollector = metricsCollector;
    this.initializeDefaultRules();
    this.startMonitoring();
  }
  
  addRule(rule: AlertRule): void {
    this.rules.set(rule.id, rule);
  }
  
  removeRule(ruleId: string): void {
    this.rules.delete(ruleId);
    
    // è§£å†³ç›¸å…³çš„æ´»è·ƒå‘Šè­¦
    for (const [alertId, alert] of this.activeAlerts) {
      if (alert.ruleId === ruleId) {
        this.resolveAlert(alertId);
      }
    }
  }
  
  async checkAlerts(): Promise<void> {
    const metrics = await this.metricsCollector.getCurrentMetrics();
    
    for (const rule of this.rules.values()) {
      if (!rule.enabled) continue;
      
      const shouldAlert = this.evaluateRule(rule, metrics);
      const existingAlert = this.findActiveAlert(rule.id);
      
      if (shouldAlert && !existingAlert) {
        // è§¦å‘æ–°å‘Šè­¦
        await this.triggerAlert(rule, metrics);
      } else if (!shouldAlert && existingAlert) {
        // è§£å†³å‘Šè­¦
        this.resolveAlert(existingAlert.id);
      }
    }
  }
  
  private evaluateRule(rule: AlertRule, metrics: SystemMetrics): boolean {
    const value = metrics[rule.metric];
    
    switch (rule.operator) {
      case '>': return value > rule.threshold;
      case '<': return value < rule.threshold;
      case '>=': return value >= rule.threshold;
      case '<=': return value <= rule.threshold;
      case '==': return value === rule.threshold;
      default: return false;
    }
  }
  
  private findActiveAlert(ruleId: string): Alert | undefined {
    for (const alert of this.activeAlerts.values()) {
      if (alert.ruleId === ruleId) {
        return alert;
      }
    }
    return undefined;
  }
  
  private async triggerAlert(rule: AlertRule, metrics: SystemMetrics): Promise<void> {
    const alert: Alert = {
      id: this.generateAlertId(),
      ruleId: rule.id,
      message: this.generateAlertMessage(rule, metrics),
      severity: rule.severity,
      timestamp: Date.now(),
      resolved: false
    };
    
    this.activeAlerts.set(alert.id, alert);
    this.alertHistory.push(alert);
    
    console.log(`ğŸš¨ Alert triggered: ${alert.message}`);
    
    // å‘é€å‘Šè­¦é€šçŸ¥
    await this.sendAlert(alert, rule.channels);
  }
  
  private resolveAlert(alertId: string): void {
    const alert = this.activeAlerts.get(alertId);
    if (alert) {
      alert.resolved = true;
      alert.resolvedAt = Date.now();
      this.activeAlerts.delete(alertId);
      
      console.log(`âœ… Alert resolved: ${alert.message}`);
    }
  }
  
  private generateAlertMessage(rule: AlertRule, metrics: SystemMetrics): string {
    const value = metrics[rule.metric];
    return `${rule.name}: ${rule.metric} is ${value}${rule.metric.includes('rate') || rule.metric.includes('usage') ? '%' : ''} (threshold: ${rule.threshold})`;
  }
  
  private generateAlertId(): string {
    return `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  private async sendAlert(alert: Alert, channels: string[]): Promise<void> {
    for (const channel of channels) {
      try {
        await this.sendToChannel(alert, channel);
      } catch (error) {
        console.error(`Failed to send alert to channel ${channel}:`, error);
      }
    }
  }
  
  private async sendToChannel(alert: Alert, channel: string): Promise<void> {
    switch (channel) {
      case 'email':
        await this.sendEmail(alert);
        break;
      case 'sms':
        await this.sendSMS(alert);
        break;
      case 'webhook':
        await this.sendWebhook(alert);
        break;
      case 'slack':
        await this.sendSlack(alert);
        break;
      default:
        console.log(`Unknown alert channel: ${channel}`);
    }
  }
  
  private async sendEmail(alert: Alert): Promise<void> {
    // å®ç°é‚®ä»¶å‘é€é€»è¾‘
    console.log(`ğŸ“§ Sending email alert: ${alert.message}`);
  }
  
  private async sendSMS(alert: Alert): Promise<void> {
    // å®ç°çŸ­ä¿¡å‘é€é€»è¾‘
    console.log(`ğŸ“± Sending SMS alert: ${alert.message}`);
  }
  
  private async sendWebhook(alert: Alert): Promise<void> {
    // å®ç°Webhookå‘é€é€»è¾‘
    console.log(`ğŸ”— Sending webhook alert: ${alert.message}`);
  }
  
  private async sendSlack(alert: Alert): Promise<void> {
    // å®ç°Slackå‘é€é€»è¾‘
    console.log(`ğŸ’¬ Sending Slack alert: ${alert.message}`);
  }
  
  private initializeDefaultRules(): void {
    // CPUä½¿ç”¨ç‡å‘Šè­¦
    this.addRule({
      id: 'high_cpu_usage',
      name: 'High CPU Usage',
      metric: 'cpu_usage',
      operator: '>',
      threshold: 80,
      duration: 30000,
      severity: 'warning',
      enabled: true,
      channels: ['email', 'slack']
    });
    
    // å†…å­˜ä½¿ç”¨ç‡å‘Šè­¦
    this.addRule({
      id: 'high_memory_usage',
      name: 'High Memory Usage',
      metric: 'memory_usage',
      operator: '>',
      threshold: 85,
      duration: 60000,
      severity: 'error',
      enabled: true,
      channels: ['email', 'sms', 'slack']
    });
    
    // é”™è¯¯ç‡å‘Šè­¦
    this.addRule({
      id: 'high_error_rate',
      name: 'High Error Rate',
      metric: 'error_rate',
      operator: '>',
      threshold: 5,
      duration: 120000,
      severity: 'critical',
      enabled: true,
      channels: ['email', 'sms', 'webhook', 'slack']
    });
    
    // å“åº”æ—¶é—´å‘Šè­¦
    this.addRule({
      id: 'slow_response_time',
      name: 'Slow Response Time',
      metric: 'response_time',
      operator: '>',
      threshold: 1000,
      duration: 180000,
      severity: 'warning',
      enabled: true,
      channels: ['email', 'slack']
    });
  }
  
  private startMonitoring(): void {
    setInterval(async () => {
      await this.checkAlerts();
    }, 10000); // æ¯10ç§’æ£€æŸ¥ä¸€æ¬¡
  }
  
  getActiveAlerts(): Alert[] {
    return Array.from(this.activeAlerts.values());
  }
  
  getAlertHistory(limit: number = 100): Alert[] {
    return this.alertHistory.slice(-limit);
  }
}
```

## 7. æ•°æ®åº“è®¾è®¡

### 7.1 ä¿æŠ¤æœºåˆ¶é…ç½®è¡¨
```sql
-- é™æµé…ç½®è¡¨
CREATE TABLE rate_limit_configs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL COMMENT 'é™æµè§„åˆ™åç§°',
    type ENUM('global', 'service', 'api', 'user', 'ip') NOT NULL COMMENT 'é™æµç±»å‹',
    target VARCHAR(200) NOT NULL COMMENT 'é™æµç›®æ ‡',
    algorithm ENUM('token_bucket', 'leaky_bucket', 'sliding_window') NOT NULL COMMENT 'é™æµç®—æ³•',
    qps INT NOT NULL COMMENT 'æ¯ç§’è¯·æ±‚æ•°é™åˆ¶',
    burst INT DEFAULT NULL COMMENT 'çªå‘å®¹é‡',
    window_size INT DEFAULT NULL COMMENT 'çª—å£å¤§å°(æ¯«ç§’)',
    enabled BOOLEAN DEFAULT TRUE COMMENT 'æ˜¯å¦å¯ç”¨',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_type_target (type, target),
    INDEX idx_enabled (enabled)
) COMMENT 'é™æµé…ç½®è¡¨';

-- ç†”æ–­å™¨é…ç½®è¡¨
CREATE TABLE circuit_breaker_configs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL UNIQUE COMMENT 'ç†”æ–­å™¨åç§°',
    service_name VARCHAR(100) NOT NULL COMMENT 'æœåŠ¡åç§°',
    failure_threshold DECIMAL(3,2) NOT NULL COMMENT 'å¤±è´¥é˜ˆå€¼(0-1)',
    success_threshold INT NOT NULL COMMENT 'æˆåŠŸé˜ˆå€¼',
    timeout_ms INT NOT NULL COMMENT 'è¶…æ—¶æ—¶é—´(æ¯«ç§’)',
    reset_timeout_ms INT NOT NULL COMMENT 'é‡ç½®è¶…æ—¶æ—¶é—´(æ¯«ç§’)',
    monitoring_period_ms INT NOT NULL COMMENT 'ç›‘æ§å‘¨æœŸ(æ¯«ç§’)',
    minimum_requests INT NOT NULL COMMENT 'æœ€å°è¯·æ±‚æ•°',
    enabled BOOLEAN DEFAULT TRUE COMMENT 'æ˜¯å¦å¯ç”¨',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_service_name (service_name),
    INDEX idx_enabled (enabled)
) COMMENT 'ç†”æ–­å™¨é…ç½®è¡¨';

-- é™çº§è§„åˆ™è¡¨
CREATE TABLE degradation_rules (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    rule_id VARCHAR(50) NOT NULL UNIQUE COMMENT 'è§„åˆ™ID',
    name VARCHAR(100) NOT NULL COMMENT 'è§„åˆ™åç§°',
    level TINYINT NOT NULL COMMENT 'é™çº§çº§åˆ«(0-4)',
    priority INT NOT NULL COMMENT 'ä¼˜å…ˆçº§',
    conditions JSON NOT NULL COMMENT 'è§¦å‘æ¡ä»¶',
    actions JSON NOT NULL COMMENT 'é™çº§åŠ¨ä½œ',
    enabled BOOLEAN DEFAULT TRUE COMMENT 'æ˜¯å¦å¯ç”¨',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_rule_id (rule_id),
    INDEX idx_level (level),
    INDEX idx_priority (priority),
    INDEX idx_enabled (enabled)
) COMMENT 'é™çº§è§„åˆ™è¡¨';

-- å‘Šè­¦è§„åˆ™è¡¨
CREATE TABLE alert_rules (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    rule_id VARCHAR(50) NOT NULL UNIQUE COMMENT 'è§„åˆ™ID',
    name VARCHAR(100) NOT NULL COMMENT 'è§„åˆ™åç§°',
    metric VARCHAR(50) NOT NULL COMMENT 'ç›‘æ§æŒ‡æ ‡',
    operator ENUM('>', '<', '>=', '<=', '==') NOT NULL COMMENT 'æ¯”è¾ƒæ“ä½œç¬¦',
    threshold DECIMAL(10,2) NOT NULL COMMENT 'é˜ˆå€¼',
    duration_ms INT NOT NULL COMMENT 'æŒç»­æ—¶é—´(æ¯«ç§’)',
    severity ENUM('info', 'warning', 'error', 'critical') NOT NULL COMMENT 'ä¸¥é‡çº§åˆ«',
    channels JSON NOT NULL COMMENT 'å‘Šè­¦æ¸ é“',
    enabled BOOLEAN DEFAULT TRUE COMMENT 'æ˜¯å¦å¯ç”¨',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_rule_id (rule_id),
    INDEX idx_metric (metric),
    INDEX idx_severity (severity),
    INDEX idx_enabled (enabled)
) COMMENT 'å‘Šè­¦è§„åˆ™è¡¨';
```

### 7.2 ç›‘æ§æ•°æ®è¡¨
```sql
-- ç³»ç»ŸæŒ‡æ ‡è¡¨
CREATE TABLE system_metrics (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    timestamp TIMESTAMP NOT NULL COMMENT 'æ—¶é—´æˆ³',
    cpu_usage DECIMAL(5,2) NOT NULL COMMENT 'CPUä½¿ç”¨ç‡(%)',
    memory_usage DECIMAL(5,2) NOT NULL COMMENT 'å†…å­˜ä½¿ç”¨ç‡(%)',
    disk_usage DECIMAL(5,2) NOT NULL COMMENT 'ç£ç›˜ä½¿ç”¨ç‡(%)',
    network_io BIGINT NOT NULL COMMENT 'ç½‘ç»œIO(å­—èŠ‚)',
    error_rate DECIMAL(5,2) NOT NULL COMMENT 'é”™è¯¯ç‡(%)',
    response_time DECIMAL(8,2) NOT NULL COMMENT 'å“åº”æ—¶é—´(æ¯«ç§’)',
    qps DECIMAL(8,2) NOT NULL COMMENT 'æ¯ç§’è¯·æ±‚æ•°',
    active_connections INT NOT NULL COMMENT 'æ´»è·ƒè¿æ¥æ•°',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_timestamp (timestamp),
    INDEX idx_cpu_usage (cpu_usage),
    INDEX idx_memory_usage (memory_usage),
    INDEX idx_error_rate (error_rate)
) COMMENT 'ç³»ç»ŸæŒ‡æ ‡è¡¨'
PARTITION BY RANGE (UNIX_TIMESTAMP(timestamp)) (
    PARTITION p_current VALUES LESS THAN (UNIX_TIMESTAMP('2024-02-01')),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- ç†”æ–­å™¨çŠ¶æ€è¡¨
CREATE TABLE circuit_breaker_states (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    breaker_name VARCHAR(100) NOT NULL COMMENT 'ç†”æ–­å™¨åç§°',
    state ENUM('CLOSED', 'OPEN', 'HALF_OPEN') NOT NULL COMMENT 'çŠ¶æ€',
    failure_count INT NOT NULL COMMENT 'å¤±è´¥æ¬¡æ•°',
    success_count INT NOT NULL COMMENT 'æˆåŠŸæ¬¡æ•°',
    request_count INT NOT NULL COMMENT 'è¯·æ±‚æ¬¡æ•°',
    last_failure_time TIMESTAMP NULL COMMENT 'æœ€åå¤±è´¥æ—¶é—´',
    timestamp TIMESTAMP NOT NULL COMMENT 'è®°å½•æ—¶é—´',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_breaker_name (breaker_name),
    INDEX idx_state (state),
    INDEX idx_timestamp (timestamp)
) COMMENT 'ç†”æ–­å™¨çŠ¶æ€è¡¨';

-- å‘Šè­¦è®°å½•è¡¨
CREATE TABLE alert_records (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    alert_id VARCHAR(100) NOT NULL UNIQUE COMMENT 'å‘Šè­¦ID',
    rule_id VARCHAR(50) NOT NULL COMMENT 'è§„åˆ™ID',
    message TEXT NOT NULL COMMENT 'å‘Šè­¦æ¶ˆæ¯',
    severity ENUM('info', 'warning', 'error', 'critical') NOT NULL COMMENT 'ä¸¥é‡çº§åˆ«',
    triggered_at TIMESTAMP NOT NULL COMMENT 'è§¦å‘æ—¶é—´',
    resolved BOOLEAN DEFAULT FALSE COMMENT 'æ˜¯å¦å·²è§£å†³',
    resolved_at TIMESTAMP NULL COMMENT 'è§£å†³æ—¶é—´',
    channels_sent JSON NULL COMMENT 'å·²å‘é€çš„æ¸ é“',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_alert_id (alert_id),
    INDEX idx_rule_id (rule_id),
    INDEX idx_severity (severity),
    INDEX idx_triggered_at (triggered_at),
    INDEX idx_resolved (resolved)
) COMMENT 'å‘Šè­¦è®°å½•è¡¨';

-- é™æµç»Ÿè®¡è¡¨
CREATE TABLE rate_limit_stats (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    config_id BIGINT NOT NULL COMMENT 'é™æµé…ç½®ID',
    target VARCHAR(200) NOT NULL COMMENT 'é™æµç›®æ ‡',
    timestamp TIMESTAMP NOT NULL COMMENT 'æ—¶é—´æˆ³',
    total_requests INT NOT NULL COMMENT 'æ€»è¯·æ±‚æ•°',
    allowed_requests INT NOT NULL COMMENT 'å…è®¸çš„è¯·æ±‚æ•°',
    rejected_requests INT NOT NULL COMMENT 'æ‹’ç»çš„è¯·æ±‚æ•°',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (config_id) REFERENCES rate_limit_configs(id),
    INDEX idx_config_id (config_id),
    INDEX idx_target (target),
    INDEX idx_timestamp (timestamp)
) COMMENT 'é™æµç»Ÿè®¡è¡¨';

-- é™çº§æ‰§è¡Œè®°å½•è¡¨
CREATE TABLE degradation_executions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    rule_id VARCHAR(50) NOT NULL COMMENT 'è§„åˆ™ID',
    execution_id VARCHAR(100) NOT NULL COMMENT 'æ‰§è¡ŒID',
    level TINYINT NOT NULL COMMENT 'é™çº§çº§åˆ«',
    actions_executed JSON NOT NULL COMMENT 'æ‰§è¡Œçš„åŠ¨ä½œ',
    triggered_at TIMESTAMP NOT NULL COMMENT 'è§¦å‘æ—¶é—´',
    recovered_at TIMESTAMP NULL COMMENT 'æ¢å¤æ—¶é—´',
    duration_ms INT NULL COMMENT 'æŒç»­æ—¶é—´(æ¯«ç§’)',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_rule_id (rule_id),
    INDEX idx_execution_id (execution_id),
    INDEX idx_level (level),
    INDEX idx_triggered_at (triggered_at)
) COMMENT 'é™çº§æ‰§è¡Œè®°å½•è¡¨';
```

## 8. APIæ¥å£è®¾è®¡

### 8.1 é™æµç®¡ç†æ¥å£
```typescript
// é™æµé…ç½®ç®¡ç†
interface RateLimitAPI {
  // è·å–é™æµé…ç½®åˆ—è¡¨
  GET /api/protection/rate_limits
  
  // åˆ›å»ºé™æµé…ç½®
  POST /api/protection/rate_limits
  
  // æ›´æ–°é™æµé…ç½®
  PUT /api/protection/rate_limits/{id}
  
  // åˆ é™¤é™æµé…ç½®
  DELETE /api/protection/rate_limits/{id}
  
  // è·å–é™æµç»Ÿè®¡
  GET /api/protection/rate_limits/{id}/stats
}

// é™æµé…ç½®è¯·æ±‚ä½“
interface CreateRateLimitRequest {
  name: string;
  type: 'global' | 'service' | 'api' | 'user' | 'ip';
  target: string;
  algorithm: 'token_bucket' | 'leaky_bucket' | 'sliding_window';
  qps: number;
  burst?: number;
  window_size?: number;
  enabled: boolean;
}

// é™æµç»Ÿè®¡å“åº”
interface RateLimitStatsResponse {
  config_id: number;
  target: string;
  period: string;
  total_requests: number;
  allowed_requests: number;
  rejected_requests: number;
  rejection_rate: number;
  timeline: Array<{
    timestamp: string;
    requests: number;
    rejections: number;
  }>;
}
```

### 8.2 ç†”æ–­å™¨ç®¡ç†æ¥å£
```typescript
// ç†”æ–­å™¨ç®¡ç†
interface CircuitBreakerAPI {
  // è·å–ç†”æ–­å™¨åˆ—è¡¨
  GET /api/protection/circuit_breakers
  
  // åˆ›å»ºç†”æ–­å™¨é…ç½®
  POST /api/protection/circuit_breakers
  
  // æ›´æ–°ç†”æ–­å™¨é…ç½®
  PUT /api/protection/circuit_breakers/{id}
  
  // åˆ é™¤ç†”æ–­å™¨é…ç½®
  DELETE /api/protection/circuit_breakers/{id}
  
  // è·å–ç†”æ–­å™¨çŠ¶æ€
  GET /api/protection/circuit_breakers/{name}/status
  
  // æ‰‹åŠ¨è§¦å‘ç†”æ–­å™¨
  POST /api/protection/circuit_breakers/{name}/trip
  
  // æ‰‹åŠ¨é‡ç½®ç†”æ–­å™¨
  POST /api/protection/circuit_breakers/{name}/reset
}

// ç†”æ–­å™¨é…ç½®è¯·æ±‚ä½“
interface CreateCircuitBreakerRequest {
  name: string;
  service_name: string;
  failure_threshold: number;
  success_threshold: number;
  timeout_ms: number;
  reset_timeout_ms: number;
  monitoring_period_ms: number;
  minimum_requests: number;
  enabled: boolean;
}

// ç†”æ–­å™¨çŠ¶æ€å“åº”
interface CircuitBreakerStatusResponse {
  name: string;
  state: 'CLOSED' | 'OPEN' | 'HALF_OPEN';
  failure_count: number;
  success_count: number;
  request_count: number;
  failure_rate: number;
  last_failure_time?: string;
  next_attempt_time?: string;
  metrics: {
    total_requests: number;
    successful_requests: number;
    failed_requests: number;
    avg_response_time: number;
  };
}
```

### 8.3 é™çº§ç®¡ç†æ¥å£
```typescript
// é™çº§ç®¡ç†
interface DegradationAPI {
  // è·å–é™çº§è§„åˆ™åˆ—è¡¨
  GET /api/protection/degradation_rules
  
  // åˆ›å»ºé™çº§è§„åˆ™
  POST /api/protection/degradation_rules
  
  // æ›´æ–°é™çº§è§„åˆ™
  PUT /api/protection/degradation_rules/{id}
  
  // åˆ é™¤é™çº§è§„åˆ™
  DELETE /api/protection/degradation_rules/{id}
  
  // è·å–å½“å‰é™çº§çŠ¶æ€
  GET /api/protection/degradation/status
  
  // æ‰‹åŠ¨è§¦å‘é™çº§
  POST /api/protection/degradation/trigger
  
  // æ‰‹åŠ¨æ¢å¤é™çº§
  POST /api/protection/degradation/recover
  
  // è·å–é™çº§æ‰§è¡Œå†å²
  GET /api/protection/degradation/executions
}

// é™çº§è§„åˆ™è¯·æ±‚ä½“
interface CreateDegradationRuleRequest {
  rule_id: string;
  name: string;
  level: number;
  priority: number;
  conditions: Array<{
    type: string;
    operator: string;
    threshold: number;
    duration: number;
  }>;
  actions: Array<{
    type: string;
    target: string;
    config: Record<string, any>;
  }>;
  enabled: boolean;
}

// é™çº§çŠ¶æ€å“åº”
interface DegradationStatusResponse {
  current_level: number;
  active_rules: string[];
  system_metrics: {
    cpu_usage: number;
    memory_usage: number;
    error_rate: number;
    response_time: number;
    qps: number;
  };
  degraded_features: Array<{
    feature: string;
    level: number;
    since: string;
  }>;
}
```

### 8.4 ç›‘æ§å‘Šè­¦æ¥å£
```typescript
// ç›‘æ§å‘Šè­¦
interface MonitoringAPI {
  // è·å–ç³»ç»ŸæŒ‡æ ‡
  GET /api/monitoring/metrics
  
  // è·å–å‘Šè­¦è§„åˆ™åˆ—è¡¨
  GET /api/monitoring/alert_rules
  
  // åˆ›å»ºå‘Šè­¦è§„åˆ™
  POST /api/monitoring/alert_rules
  
  // æ›´æ–°å‘Šè­¦è§„åˆ™
  PUT /api/monitoring/alert_rules/{id}
  
  // åˆ é™¤å‘Šè­¦è§„åˆ™
  DELETE /api/monitoring/alert_rules/{id}
  
  // è·å–æ´»è·ƒå‘Šè­¦
  GET /api/monitoring/alerts/active
  
  // è·å–å‘Šè­¦å†å²
  GET /api/monitoring/alerts/history
  
  // ç¡®è®¤å‘Šè­¦
  POST /api/monitoring/alerts/{id}/acknowledge
  
  // è§£å†³å‘Šè­¦
  POST /api/monitoring/alerts/{id}/resolve
}

// ç³»ç»ŸæŒ‡æ ‡å“åº”
interface SystemMetricsResponse {
  timestamp: string;
  metrics: {
    cpu_usage: number;
    memory_usage: number;
    disk_usage: number;
    network_io: number;
    error_rate: number;
    response_time: number;
    qps: number;
    active_connections: number;
  };
  trends: {
    cpu_trend: 'up' | 'down' | 'stable';
    memory_trend: 'up' | 'down' | 'stable';
    error_trend: 'up' | 'down' | 'stable';
  };
}

// å‘Šè­¦è§„åˆ™è¯·æ±‚ä½“
interface CreateAlertRuleRequest {
  rule_id: string;
  name: string;
  metric: string;
  operator: '>' | '<' | '>=' | '<=' | '==';
  threshold: number;
  duration_ms: number;
  severity: 'info' | 'warning' | 'error' | 'critical';
  channels: string[];
  enabled: boolean;
}
```

## 9. é…ç½®ç®¡ç†

### 9.1 é…ç½®æ–‡ä»¶ç»“æ„
```yaml
# æœåŠ¡ä¿æŠ¤é…ç½®
protection:
  # å…¨å±€å¼€å…³
  enabled: true
  
  # é™æµé…ç½®
  rate_limiting:
    enabled: true
    default_algorithm: "token_bucket"
    global:
      qps: 10000
      burst: 20000
    services:
      user_service:
        qps: 1000
        burst: 2000
      order_service:
        qps: 500
        burst: 1000
    apis:
      "/api/users/login":
        qps: 100
        user_qps: 5
        ip_qps: 20
      "/api/orders/create":
        qps: 200
        user_qps: 10
        
  # ç†”æ–­å™¨é…ç½®
  circuit_breaker:
    enabled: true
    default_config:
      failure_threshold: 0.5
      success_threshold: 3
      timeout: 5000
      reset_timeout: 60000
      monitoring_period: 10000
      minimum_requests: 10
    services:
      database:
        failure_threshold: 0.3
        timeout: 3000
        reset_timeout: 30000
      external_api:
        failure_threshold: 0.4
        timeout: 2000
        reset_timeout: 20000
        
  # é™çº§é…ç½®
  degradation:
    enabled: true
    rules:
      - id: "high_cpu"
        name: "High CPU Usage"
        level: 2
        priority: 100
        conditions:
          - type: "cpu_usage"
            operator: ">"
            threshold: 80
            duration: 30000
        actions:
          - type: "disable_feature"
            target: "recommendation_engine"
          - type: "use_cache"
            target: "product_service"
            config:
              ttl: 300
      - id: "high_error_rate"
        name: "High Error Rate"
        level: 3
        priority: 200
        conditions:
          - type: "error_rate"
            operator: ">"
            threshold: 10
            duration: 60000
        actions:
          - type: "return_default"
            target: "user_recommendations"
            config:
              response:
                items: []
                message: "Service temporarily unavailable"
                
  # ç›‘æ§å‘Šè­¦é…ç½®
  monitoring:
    enabled: true
    collection_interval: 5000  # 5ç§’
    alert_check_interval: 10000  # 10ç§’
    metrics_retention: 7  # 7å¤©
    
    alert_rules:
      - id: "high_cpu_usage"
        name: "High CPU Usage"
        metric: "cpu_usage"
        operator: ">"
        threshold: 80
        duration: 30000
        severity: "warning"
        channels: ["email", "slack"]
      - id: "high_memory_usage"
        name: "High Memory Usage"
        metric: "memory_usage"
        operator: ">"
        threshold: 85
        duration: 60000
        severity: "error"
        channels: ["email", "sms", "slack"]
      - id: "high_error_rate"
        name: "High Error Rate"
        metric: "error_rate"
        operator: ">"
        threshold: 5
        duration: 120000
        severity: "critical"
        channels: ["email", "sms", "webhook", "slack"]
        
    # å‘Šè­¦æ¸ é“é…ç½®
    channels:
      email:
        enabled: true
        smtp_host: "smtp.company.com"
        smtp_port: 587
        username: "alerts@company.com"
        recipients: ["admin@company.com", "ops@company.com"]
      sms:
        enabled: true
        provider: "aliyun"
        api_key: "${SMS_API_KEY}"
        phones: ["+86138****8888", "+86139****9999"]
      slack:
        enabled: true
        webhook_url: "${SLACK_WEBHOOK_URL}"
        channel: "#alerts"
      webhook:
        enabled: true
        url: "${WEBHOOK_URL}"
        timeout: 5000
```

## 10. éƒ¨ç½²å’Œè¿ç»´

### 10.1 éƒ¨ç½²æ¶æ„
```yaml
# Docker Compose éƒ¨ç½²é…ç½®
version: '3.8'
services:
  # åº”ç”¨æœåŠ¡
  app:
    image: company/app:latest
    ports:
      - "8080:8080"
    environment:
      - PROTECTION_ENABLED=true
      - REDIS_URL=redis://redis:6379
      - DB_URL=mysql://mysql:3306/app
    depends_on:
      - redis
      - mysql
      - prometheus
    volumes:
      - ./config/protection.yml:/app/config/protection.yml
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '2'
          memory: 4G
        reservations:
          cpus: '1'
          memory: 2G
          
  # Redisç¼“å­˜
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes
    
  # MySQLæ•°æ®åº“
  mysql:
    image: mysql:8.0
    ports:
      - "3306:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=password
      - MYSQL_DATABASE=app
    volumes:
      - mysql_data:/var/lib/mysql
      - ./sql/init.sql:/docker-entrypoint-initdb.d/init.sql
      
  # Prometheusç›‘æ§
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./config/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      
  # Grafanaå¯è§†åŒ–
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana_data:/var/lib/grafana
      - ./config/grafana/dashboards:/etc/grafana/provisioning/dashboards
      - ./config/grafana/datasources:/etc/grafana/provisioning/datasources
      
  # AlertManagerå‘Šè­¦
  alertmanager:
    image: prom/alertmanager:latest
    ports:
      - "9093:9093"
    volumes:
      - ./config/alertmanager.yml:/etc/alertmanager/alertmanager.yml
      - alertmanager_data:/alertmanager

volumes:
  redis_data:
  mysql_data:
  prometheus_data:
  grafana_data:
  alertmanager_data:
```

### 10.2 è¿ç»´è„šæœ¬
```bash
#!/bin/bash
# æœåŠ¡ä¿æŠ¤è¿ç»´è„šæœ¬

# æ£€æŸ¥æœåŠ¡çŠ¶æ€
check_protection_status() {
    echo "=== æ£€æŸ¥æœåŠ¡ä¿æŠ¤çŠ¶æ€ ==="
    
    # æ£€æŸ¥é™æµçŠ¶æ€
    curl -s "http://localhost:8080/api/protection/rate_limits" | jq '.[] | {name, enabled, qps}'
    
    # æ£€æŸ¥ç†”æ–­å™¨çŠ¶æ€
    curl -s "http://localhost:8080/api/protection/circuit_breakers" | jq '.[] | {name, state, failure_rate}'
    
    # æ£€æŸ¥é™çº§çŠ¶æ€
    curl -s "http://localhost:8080/api/protection/degradation/status" | jq '{current_level, active_rules}'
    
    # æ£€æŸ¥æ´»è·ƒå‘Šè­¦
    curl -s "http://localhost:8080/api/monitoring/alerts/active" | jq '.[] | {message, severity, triggered_at}'
}

# é‡ç½®ç†”æ–­å™¨
reset_circuit_breaker() {
    local breaker_name=$1
    if [ -z "$breaker_name" ]; then
        echo "Usage: reset_circuit_breaker <breaker_name>"
        return 1
    fi
    
    echo "é‡ç½®ç†”æ–­å™¨: $breaker_name"
    curl -X POST "http://localhost:8080/api/protection/circuit_breakers/$breaker_name/reset"
}

# æ‰‹åŠ¨è§¦å‘é™çº§
trigger_degradation() {
    local rule_id=$1
    if [ -z "$rule_id" ]; then
        echo "Usage: trigger_degradation <rule_id>"
        return 1
    fi
    
    echo "æ‰‹åŠ¨è§¦å‘é™çº§è§„åˆ™: $rule_id"
    curl -X POST "http://localhost:8080/api/protection/degradation/trigger" \
         -H "Content-Type: application/json" \
         -d "{\"rule_id\": \"$rule_id\"}"
}

# æ¢å¤é™çº§
recover_degradation() {
    local rule_id=$1
    if [ -z "$rule_id" ]; then
        echo "Usage: recover_degradation <rule_id>"
        return 1
    fi
    
    echo "æ¢å¤é™çº§è§„åˆ™: $rule_id"
    curl -X POST "http://localhost:8080/api/protection/degradation/recover" \
         -H "Content-Type: application/json" \
         -d "{\"rule_id\": \"$rule_id\"}"
}

# æ›´æ–°é™æµé…ç½®
update_rate_limit() {
    local config_id=$1
    local qps=$2
    if [ -z "$config_id" ] || [ -z "$qps" ]; then
        echo "Usage: update_rate_limit <config_id> <qps>"
        return 1
    fi
    
    echo "æ›´æ–°é™æµé…ç½®: $config_id, QPS: $qps"
    curl -X PUT "http://localhost:8080/api/protection/rate_limits/$config_id" \
         -H "Content-Type: application/json" \
         -d "{\"qps\": $qps}"
}

# ç”Ÿæˆä¿æŠ¤æŠ¥å‘Š
generate_protection_report() {
    local output_file="protection_report_$(date +%Y%m%d_%H%M%S).json"
    
    echo "ç”Ÿæˆä¿æŠ¤æœºåˆ¶æŠ¥å‘Š: $output_file"
    
    {
        echo "{"
        echo "  \"timestamp\": \"$(date -Iseconds)\","
        echo "  \"rate_limits\": $(curl -s "http://localhost:8080/api/protection/rate_limits"),"
        echo "  \"circuit_breakers\": $(curl -s "http://localhost:8080/api/protection/circuit_breakers"),"
        echo "  \"degradation_status\": $(curl -s "http://localhost:8080/api/protection/degradation/status"),"
        echo "  \"active_alerts\": $(curl -s "http://localhost:8080/api/monitoring/alerts/active"),"
        echo "  \"system_metrics\": $(curl -s "http://localhost:8080/api/monitoring/metrics")"
        echo "}"
    } > "$output_file"
    
    echo "æŠ¥å‘Šå·²ç”Ÿæˆ: $output_file"
}

# ä¸»èœå•
main() {
    case "$1" in
        "status")
            check_protection_status
            ;;
        "reset-breaker")
            reset_circuit_breaker "$2"
            ;;
        "trigger-degradation")
            trigger_degradation "$2"
            ;;
        "recover-degradation")
            recover_degradation "$2"
            ;;
        "update-rate-limit")
            update_rate_limit "$2" "$3"
            ;;
        "report")
            generate_protection_report
            ;;
        *)
            echo "Usage: $0 {status|reset-breaker|trigger-degradation|recover-degradation|update-rate-limit|report}"
            echo ""
            echo "Commands:"
            echo "  status                              - æ£€æŸ¥æœåŠ¡ä¿æŠ¤çŠ¶æ€"
            echo "  reset-breaker <name>               - é‡ç½®ç†”æ–­å™¨"
            echo "  trigger-degradation <rule_id>      - æ‰‹åŠ¨è§¦å‘é™çº§"
            echo "  recover-degradation <rule_id>      - æ¢å¤é™çº§"
            echo "  update-rate-limit <id> <qps>       - æ›´æ–°é™æµé…ç½®"
            echo "  report                             - ç”Ÿæˆä¿æŠ¤æŠ¥å‘Š"
            exit 1
            ;;
    esac
}

main "$@"
```

è¿™ä¸ªæœåŠ¡é™çº§å’Œç†”æ–­æœºåˆ¶è®¾è®¡æ–‡æ¡£æä¾›äº†å®Œæ•´çš„ç³»ç»Ÿä¿æŠ¤æ–¹æ¡ˆï¼ŒåŒ…æ‹¬é™æµã€ç†”æ–­ã€é™çº§ã€ç›‘æ§å‘Šè­¦ç­‰å„ä¸ªæ–¹é¢ï¼Œç¡®ä¿ç³»ç»Ÿåœ¨é«˜è´Ÿè½½æˆ–æ•…éšœæƒ…å†µä¸‹èƒ½å¤Ÿä¿æŒç¨³å®šè¿è¡Œã€‚
