# ç½—è±L2Cé”€å”®ç®¡ç†ç³»ç»Ÿ - æ•°æ®æ²»ç†æ¡†æ¶è®¾è®¡æ–¹æ¡ˆ

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

**é¡¹ç›®åç§°ï¼š** ç½—è±L2Cé”€å”®ç®¡ç†ç³»ç»Ÿæ•°æ®æ²»ç†æ¡†æ¶  
**æ–‡æ¡£ç‰ˆæœ¬ï¼š** v1.0  
**åˆ›å»ºæ—¥æœŸï¼š** 2024å¹´  
**è®¾è®¡ç›®æ ‡ï¼š** å»ºç«‹å®Œå–„çš„æ•°æ®æ²»ç†ä½“ç³»ï¼Œç¡®ä¿æ•°æ®è´¨é‡ã€å®‰å…¨å’Œåˆè§„  

---

## ğŸ¯ æ•°æ®æ²»ç†ç›®æ ‡ä¸ä»·å€¼

### 1. æ ¸å¿ƒç›®æ ‡
- **æ•°æ®è´¨é‡ä¿éšœ**ï¼šç¡®ä¿æ•°æ®çš„å‡†ç¡®æ€§ã€å®Œæ•´æ€§ã€ä¸€è‡´æ€§å’ŒåŠæ—¶æ€§
- **æ•°æ®å®‰å…¨åˆè§„**ï¼šä¿æŠ¤æ•æ„Ÿæ•°æ®ï¼Œæ»¡è¶³æ³•è§„è¦æ±‚
- **æ•°æ®èµ„äº§ç®¡ç†**ï¼šå»ºç«‹æ•°æ®èµ„äº§ç›®å½•ï¼Œæå‡æ•°æ®ä»·å€¼
- **æ•°æ®æ ‡å‡†åŒ–**ï¼šç»Ÿä¸€æ•°æ®å®šä¹‰ã€æ ¼å¼å’Œå¤„ç†è§„èŒƒ
- **æ•°æ®ç”Ÿå‘½å‘¨æœŸç®¡ç†**ï¼šä»æ•°æ®äº§ç”Ÿåˆ°é”€æ¯çš„å…¨ç”Ÿå‘½å‘¨æœŸç®¡ç†

### 2. æ²»ç†åŸåˆ™
- **ç»Ÿä¸€æ ‡å‡†**ï¼šå»ºç«‹ä¼ä¸šçº§æ•°æ®æ ‡å‡†å’Œè§„èŒƒ
- **åˆ†çº§ç®¡ç†**ï¼šæ ¹æ®æ•°æ®é‡è¦æ€§å®æ–½åˆ†çº§æ²»ç†
- **å…¨ç¨‹ç›‘æ§**ï¼šæ•°æ®æµè½¬å…¨è¿‡ç¨‹è´¨é‡ç›‘æ§
- **æŒç»­æ”¹è¿›**ï¼šåŸºäºç›‘æ§ç»“æœæŒç»­ä¼˜åŒ–æ²»ç†ç­–ç•¥
- **ä¸šåŠ¡é©±åŠ¨**ï¼šä»¥ä¸šåŠ¡éœ€æ±‚ä¸ºå¯¼å‘çš„æ•°æ®æ²»ç†

---

## ğŸ—ï¸ æ•°æ®æ²»ç†æ¶æ„

### 1. æ•´ä½“æ¶æ„è®¾è®¡

```mermaid
graph TB
    subgraph "æ•°æ®æ²»ç†å±‚"
        A[æ•°æ®æ²»ç†å§”å‘˜ä¼š] --> B[æ•°æ®ç®¡ç†åŠå…¬å®¤]
        B --> C[æ•°æ®æ ‡å‡†ç®¡ç†]
        B --> D[æ•°æ®è´¨é‡ç®¡ç†]
        B --> E[ä¸»æ•°æ®ç®¡ç†]
        B --> F[å…ƒæ•°æ®ç®¡ç†]
        B --> G[æ•°æ®å®‰å…¨ç®¡ç†]
    end
    
    subgraph "æ•°æ®å¤„ç†å±‚"
        H[æ•°æ®é‡‡é›†] --> I[æ•°æ®æ¸…æ´—]
        I --> J[æ•°æ®è½¬æ¢]
        J --> K[æ•°æ®åŠ è½½]
        K --> L[æ•°æ®å­˜å‚¨]
    end
    
    subgraph "æ•°æ®åº”ç”¨å±‚"
        M[ä¸šåŠ¡åº”ç”¨] --> N[æ•°æ®åˆ†æ]
        N --> O[æ•°æ®æŠ¥å‘Š]
        O --> P[æ•°æ®æœåŠ¡]
    end
    
    subgraph "ç›‘æ§æ”¯æ’‘å±‚"
        Q[è´¨é‡ç›‘æ§] --> R[åˆè§„å®¡è®¡]
        R --> S[é£é™©é¢„è­¦]
        S --> T[æ²»ç†è¯„ä¼°]
    end
    
    C --> H
    D --> I
    E --> J
    F --> K
    G --> L
    
    L --> M
    Q --> H
    R --> I
    S --> J
    T --> K
```

### 2. ç»„ç»‡æ¶æ„è®¾è®¡

#### 2.1 æ•°æ®æ²»ç†å§”å‘˜ä¼š
```yaml
# æ•°æ®æ²»ç†ç»„ç»‡æ¶æ„
governance_committee:
  chairman: "CTO"
  members:
    - role: "ä¸šåŠ¡è´Ÿè´£äºº"
      department: "é”€å”®éƒ¨é—¨"
      responsibilities:
        - "ä¸šåŠ¡æ•°æ®éœ€æ±‚å®šä¹‰"
        - "æ•°æ®è´¨é‡æ ‡å‡†åˆ¶å®š"
    - role: "æŠ€æœ¯è´Ÿè´£äºº"
      department: "ITéƒ¨é—¨"
      responsibilities:
        - "æŠ€æœ¯æ ‡å‡†åˆ¶å®š"
        - "æ•°æ®æ¶æ„è®¾è®¡"
    - role: "æ•°æ®ç®¡ç†å‘˜"
      department: "æ•°æ®ä¸­å¿ƒ"
      responsibilities:
        - "æ—¥å¸¸æ•°æ®æ²»ç†æ‰§è¡Œ"
        - "æ•°æ®è´¨é‡ç›‘æ§"
    - role: "åˆè§„ä¸“å‘˜"
      department: "æ³•åŠ¡éƒ¨é—¨"
      responsibilities:
        - "æ•°æ®åˆè§„å®¡æŸ¥"
        - "éšç§ä¿æŠ¤ç›‘ç£"

data_management_office:
  director: "æ•°æ®æ€»ç›‘"
  teams:
    - name: "æ•°æ®æ ‡å‡†å›¢é˜Ÿ"
      size: 3
      focus: "æ•°æ®æ ‡å‡†åˆ¶å®šå’Œç»´æŠ¤"
    - name: "æ•°æ®è´¨é‡å›¢é˜Ÿ"
      size: 4
      focus: "æ•°æ®è´¨é‡ç›‘æ§å’Œæ”¹è¿›"
    - name: "ä¸»æ•°æ®å›¢é˜Ÿ"
      size: 2
      focus: "ä¸»æ•°æ®ç®¡ç†å’Œç»´æŠ¤"
    - name: "å…ƒæ•°æ®å›¢é˜Ÿ"
      size: 2
      focus: "å…ƒæ•°æ®ç®¡ç†å’Œè¡€ç¼˜åˆ†æ"
```

---

## ğŸ“Š æ•°æ®è´¨é‡ç®¡ç†

### 1. æ•°æ®è´¨é‡æ¡†æ¶

#### 1.1 æ•°æ®è´¨é‡ç»´åº¦
```typescript
// æ•°æ®è´¨é‡ç»´åº¦å®šä¹‰
interface DataQualityDimensions {
  accuracy: {
    name: 'å‡†ç¡®æ€§';
    description: 'æ•°æ®ä¸çœŸå®æƒ…å†µçš„ç¬¦åˆç¨‹åº¦';
    metrics: ['é”™è¯¯ç‡', 'å‡†ç¡®ç‡'];
    threshold: {
      error_rate: '<1%';
      accuracy_rate: '>99%';
    };
  };
  
  completeness: {
    name: 'å®Œæ•´æ€§';
    description: 'æ•°æ®çš„å®Œæ•´ç¨‹åº¦';
    metrics: ['ç¼ºå¤±ç‡', 'å®Œæ•´ç‡'];
    threshold: {
      missing_rate: '<5%';
      completeness_rate: '>95%';
    };
  };
  
  consistency: {
    name: 'ä¸€è‡´æ€§';
    description: 'åŒä¸€æ•°æ®åœ¨ä¸åŒç³»ç»Ÿä¸­çš„ä¸€è‡´ç¨‹åº¦';
    metrics: ['ä¸€è‡´æ€§ç‡', 'å†²çªç‡'];
    threshold: {
      consistency_rate: '>98%';
      conflict_rate: '<2%';
    };
  };
  
  timeliness: {
    name: 'åŠæ—¶æ€§';
    description: 'æ•°æ®çš„æ—¶æ•ˆæ€§';
    metrics: ['å»¶è¿Ÿæ—¶é—´', 'æ›´æ–°é¢‘ç‡'];
    threshold: {
      max_delay: '1å°æ—¶';
      update_frequency: 'å®æ—¶';
    };
  };
  
  validity: {
    name: 'æœ‰æ•ˆæ€§';
    description: 'æ•°æ®æ ¼å¼å’Œä¸šåŠ¡è§„åˆ™çš„ç¬¦åˆç¨‹åº¦';
    metrics: ['æ ¼å¼é”™è¯¯ç‡', 'ä¸šåŠ¡è§„åˆ™è¿åç‡'];
    threshold: {
      format_error_rate: '<0.5%';
      rule_violation_rate: '<1%';
    };
  };
  
  uniqueness: {
    name: 'å”¯ä¸€æ€§';
    description: 'æ•°æ®çš„é‡å¤ç¨‹åº¦';
    metrics: ['é‡å¤ç‡', 'å”¯ä¸€æ€§ç‡'];
    threshold: {
      duplicate_rate: '<2%';
      uniqueness_rate: '>98%';
    };
  };
}
```

#### 1.2 æ•°æ®è´¨é‡è§„åˆ™å¼•æ“
```typescript
// æ•°æ®è´¨é‡è§„åˆ™å¼•æ“
// src/services/data-quality/quality-rule-engine.ts

export class QualityRuleEngine {
  private rules: QualityRule[] = [];
  
  constructor(
    private databaseService: DatabaseService,
    private notificationService: NotificationService
  ) {
    this.initializeRules();
  }

  private initializeRules(): void {
    // å®¢æˆ·æ•°æ®è´¨é‡è§„åˆ™
    this.addRule({
      id: 'customer_phone_format',
      name: 'å®¢æˆ·æ‰‹æœºå·æ ¼å¼æ£€æŸ¥',
      table: 'customers',
      column: 'phone',
      type: 'format',
      rule: /^1[3-9]\d{9}$/,
      severity: 'high',
      action: 'alert',
    });

    this.addRule({
      id: 'customer_email_format',
      name: 'å®¢æˆ·é‚®ç®±æ ¼å¼æ£€æŸ¥',
      table: 'customers',
      column: 'email',
      type: 'format',
      rule: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
      severity: 'medium',
      action: 'alert',
    });

    this.addRule({
      id: 'customer_name_completeness',
      name: 'å®¢æˆ·å§“åå®Œæ•´æ€§æ£€æŸ¥',
      table: 'customers',
      column: 'name',
      type: 'completeness',
      rule: 'NOT NULL AND LENGTH(name) > 0',
      severity: 'high',
      action: 'block',
    });

    // è®¢å•æ•°æ®è´¨é‡è§„åˆ™
    this.addRule({
      id: 'order_amount_range',
      name: 'è®¢å•é‡‘é¢èŒƒå›´æ£€æŸ¥',
      table: 'orders',
      column: 'total_amount',
      type: 'range',
      rule: 'total_amount > 0 AND total_amount < 1000000',
      severity: 'high',
      action: 'alert',
    });

    this.addRule({
      id: 'order_status_validity',
      name: 'è®¢å•çŠ¶æ€æœ‰æ•ˆæ€§æ£€æŸ¥',
      table: 'orders',
      column: 'status',
      type: 'validity',
      rule: "status IN ('pending', 'confirmed', 'shipped', 'delivered', 'cancelled')",
      severity: 'high',
      action: 'block',
    });
  }

  addRule(rule: QualityRule): void {
    this.rules.push(rule);
  }

  async validateData(tableName: string, data: any): Promise<ValidationResult> {
    const tableRules = this.rules.filter(rule => rule.table === tableName);
    const violations: QualityViolation[] = [];

    for (const rule of tableRules) {
      const violation = await this.checkRule(rule, data);
      if (violation) {
        violations.push(violation);
      }
    }

    return {
      isValid: violations.length === 0,
      violations,
      score: this.calculateQualityScore(violations),
    };
  }

  private async checkRule(rule: QualityRule, data: any): Promise<QualityViolation | null> {
    const value = data[rule.column];

    switch (rule.type) {
      case 'format':
        if (value && !rule.rule.test(value)) {
          return {
            ruleId: rule.id,
            ruleName: rule.name,
            severity: rule.severity,
            message: `å­—æ®µ ${rule.column} æ ¼å¼ä¸æ­£ç¡®: ${value}`,
            value,
            expectedFormat: rule.rule.toString(),
          };
        }
        break;

      case 'completeness':
        if (!value || (typeof value === 'string' && value.trim().length === 0)) {
          return {
            ruleId: rule.id,
            ruleName: rule.name,
            severity: rule.severity,
            message: `å­—æ®µ ${rule.column} ä¸èƒ½ä¸ºç©º`,
            value,
          };
        }
        break;

      case 'range':
        if (rule.column === 'total_amount') {
          if (value <= 0 || value >= 1000000) {
            return {
              ruleId: rule.id,
              ruleName: rule.name,
              severity: rule.severity,
              message: `å­—æ®µ ${rule.column} è¶…å‡ºæœ‰æ•ˆèŒƒå›´: ${value}`,
              value,
              validRange: '0 < amount < 1000000',
            };
          }
        }
        break;

      case 'validity':
        if (rule.column === 'status') {
          const validStatuses = ['pending', 'confirmed', 'shipped', 'delivered', 'cancelled'];
          if (!validStatuses.includes(value)) {
            return {
              ruleId: rule.id,
              ruleName: rule.name,
              severity: rule.severity,
              message: `å­—æ®µ ${rule.column} å€¼æ— æ•ˆ: ${value}`,
              value,
              validValues: validStatuses,
            };
          }
        }
        break;
    }

    return null;
  }

  private calculateQualityScore(violations: QualityViolation[]): number {
    if (violations.length === 0) return 100;

    const severityWeights = {
      low: 1,
      medium: 3,
      high: 5,
      critical: 10,
    };

    const totalWeight = violations.reduce((sum, violation) => {
      return sum + severityWeights[violation.severity];
    }, 0);

    return Math.max(0, 100 - totalWeight);
  }

  async runQualityCheck(tableName: string): Promise<QualityReport> {
    const startTime = Date.now();
    const totalRecords = await this.getTotalRecords(tableName);
    const violations: QualityViolation[] = [];
    
    // åˆ†æ‰¹æ£€æŸ¥æ•°æ®
    const batchSize = 1000;
    for (let offset = 0; offset < totalRecords; offset += batchSize) {
      const records = await this.getRecords(tableName, offset, batchSize);
      
      for (const record of records) {
        const result = await this.validateData(tableName, record);
        violations.push(...result.violations);
      }
    }

    const endTime = Date.now();
    const duration = endTime - startTime;

    const report: QualityReport = {
      tableName,
      totalRecords,
      checkedRecords: totalRecords,
      violations,
      qualityScore: this.calculateOverallQualityScore(violations, totalRecords),
      checkDuration: duration,
      timestamp: new Date(),
      summary: this.generateSummary(violations, totalRecords),
    };

    // å‘é€è´¨é‡æŠ¥å‘Š
    await this.sendQualityReport(report);

    return report;
  }

  private async getTotalRecords(tableName: string): Promise<number> {
    const result = await this.databaseService.query(
      `SELECT COUNT(*) as count FROM ${tableName}`
    );
    return parseInt(result.rows[0].count);
  }

  private async getRecords(tableName: string, offset: number, limit: number): Promise<any[]> {
    const result = await this.databaseService.query(
      `SELECT * FROM ${tableName} LIMIT $1 OFFSET $2`,
      [limit, offset]
    );
    return result.rows;
  }

  private calculateOverallQualityScore(violations: QualityViolation[], totalRecords: number): number {
    if (violations.length === 0) return 100;

    const errorRate = violations.length / totalRecords;
    return Math.max(0, 100 - (errorRate * 100));
  }

  private generateSummary(violations: QualityViolation[], totalRecords: number): QualitySummary {
    const severityCount = violations.reduce((acc, violation) => {
      acc[violation.severity] = (acc[violation.severity] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const ruleViolationCount = violations.reduce((acc, violation) => {
      acc[violation.ruleId] = (acc[violation.ruleId] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    return {
      totalRecords,
      totalViolations: violations.length,
      errorRate: (violations.length / totalRecords) * 100,
      severityBreakdown: severityCount,
      topViolatedRules: Object.entries(ruleViolationCount)
        .sort(([, a], [, b]) => b - a)
        .slice(0, 5)
        .map(([ruleId, count]) => ({ ruleId, count })),
    };
  }

  private async sendQualityReport(report: QualityReport): Promise<void> {
    if (report.qualityScore < 95) {
      await this.notificationService.sendAlert({
        type: 'data_quality_alert',
        severity: report.qualityScore < 80 ? 'high' : 'medium',
        title: `æ•°æ®è´¨é‡å‘Šè­¦ - ${report.tableName}`,
        message: `è¡¨ ${report.tableName} æ•°æ®è´¨é‡åˆ†æ•°: ${report.qualityScore.toFixed(2)}%`,
        details: report,
      });
    }
  }
}

// æ•°æ®è´¨é‡æ¥å£å®šä¹‰
interface QualityRule {
  id: string;
  name: string;
  table: string;
  column: string;
  type: 'format' | 'completeness' | 'range' | 'validity' | 'uniqueness';
  rule: RegExp | string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  action: 'alert' | 'block' | 'auto_fix';
}

interface QualityViolation {
  ruleId: string;
  ruleName: string;
  severity: string;
  message: string;
  value: any;
  expectedFormat?: string;
  validRange?: string;
  validValues?: any[];
}

interface ValidationResult {
  isValid: boolean;
  violations: QualityViolation[];
  score: number;
}

interface QualityReport {
  tableName: string;
  totalRecords: number;
  checkedRecords: number;
  violations: QualityViolation[];
  qualityScore: number;
  checkDuration: number;
  timestamp: Date;
  summary: QualitySummary;
}

interface QualitySummary {
  totalRecords: number;
  totalViolations: number;
  errorRate: number;
  severityBreakdown: Record<string, number>;
  topViolatedRules: Array<{ ruleId: string; count: number }>;
}
```

### 2. æ•°æ®æ¸…æ´—å’Œä¿®å¤

#### 2.1 è‡ªåŠ¨åŒ–æ•°æ®æ¸…æ´—
```typescript
// æ•°æ®æ¸…æ´—æœåŠ¡
// src/services/data-quality/data-cleansing.service.ts

export class DataCleansingService {
  constructor(
    private databaseService: DatabaseService,
    private logService: LogService
  ) {}

  async cleanseCustomerData(): Promise<CleansingResult> {
    const startTime = Date.now();
    const results: CleansingOperation[] = [];

    // 1. æ¸…ç†é‡å¤å®¢æˆ·è®°å½•
    const duplicateResult = await this.removeDuplicateCustomers();
    results.push(duplicateResult);

    // 2. æ ‡å‡†åŒ–æ‰‹æœºå·æ ¼å¼
    const phoneResult = await this.standardizePhoneNumbers();
    results.push(phoneResult);

    // 3. æ¸…ç†æ— æ•ˆé‚®ç®±
    const emailResult = await this.cleanInvalidEmails();
    results.push(emailResult);

    // 4. è¡¥å…¨ç¼ºå¤±ä¿¡æ¯
    const completionResult = await this.completeCustomerInfo();
    results.push(completionResult);

    const endTime = Date.now();
    const duration = endTime - startTime;

    const result: CleansingResult = {
      tableName: 'customers',
      operations: results,
      totalProcessed: results.reduce((sum, op) => sum + op.processedCount, 0),
      totalCleansed: results.reduce((sum, op) => sum + op.cleanedCount, 0),
      duration,
      timestamp: new Date(),
    };

    await this.logCleansingResult(result);
    return result;
  }

  private async removeDuplicateCustomers(): Promise<CleansingOperation> {
    // æŸ¥æ‰¾é‡å¤å®¢æˆ·ï¼ˆåŸºäºæ‰‹æœºå·å’Œé‚®ç®±ï¼‰
    const duplicatesQuery = `
      SELECT 
        phone, 
        email, 
        COUNT(*) as count,
        array_agg(id ORDER BY created_at DESC) as ids
      FROM customers 
      WHERE phone IS NOT NULL OR email IS NOT NULL
      GROUP BY phone, email 
      HAVING COUNT(*) > 1
    `;

    const duplicates = await this.databaseService.query(duplicatesQuery);
    let cleanedCount = 0;

    for (const duplicate of duplicates.rows) {
      const [keepId, ...removeIds] = duplicate.ids;
      
      // åˆå¹¶æ•°æ®åˆ°ä¿ç•™çš„è®°å½•
      await this.mergeCustomerData(keepId, removeIds);
      
      // åˆ é™¤é‡å¤è®°å½•
      await this.databaseService.query(
        'DELETE FROM customers WHERE id = ANY($1)',
        [removeIds]
      );
      
      cleanedCount += removeIds.length;
    }

    return {
      operation: 'remove_duplicates',
      description: 'åˆ é™¤é‡å¤å®¢æˆ·è®°å½•',
      processedCount: duplicates.rows.length,
      cleanedCount,
      details: `åˆ é™¤äº† ${cleanedCount} æ¡é‡å¤è®°å½•`,
    };
  }

  private async standardizePhoneNumbers(): Promise<CleansingOperation> {
    // æŸ¥æ‰¾éœ€è¦æ ‡å‡†åŒ–çš„æ‰‹æœºå·
    const phonesQuery = `
      SELECT id, phone 
      FROM customers 
      WHERE phone IS NOT NULL 
      AND phone !~ '^1[3-9]\\d{9}$'
    `;

    const phones = await this.databaseService.query(phonesQuery);
    let cleanedCount = 0;

    for (const record of phones.rows) {
      const standardizedPhone = this.standardizePhone(record.phone);
      
      if (standardizedPhone) {
        await this.databaseService.query(
          'UPDATE customers SET phone = $1 WHERE id = $2',
          [standardizedPhone, record.id]
        );
        cleanedCount++;
      }
    }

    return {
      operation: 'standardize_phones',
      description: 'æ ‡å‡†åŒ–æ‰‹æœºå·æ ¼å¼',
      processedCount: phones.rows.length,
      cleanedCount,
      details: `æ ‡å‡†åŒ–äº† ${cleanedCount} ä¸ªæ‰‹æœºå·`,
    };
  }

  private async cleanInvalidEmails(): Promise<CleansingOperation> {
    // æŸ¥æ‰¾æ— æ•ˆé‚®ç®±
    const emailsQuery = `
      SELECT id, email 
      FROM customers 
      WHERE email IS NOT NULL 
      AND email !~ '^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$'
    `;

    const emails = await this.databaseService.query(emailsQuery);
    let cleanedCount = 0;

    for (const record of emails.rows) {
      // å°è¯•ä¿®å¤å¸¸è§çš„é‚®ç®±é”™è¯¯
      const fixedEmail = this.fixCommonEmailErrors(record.email);
      
      if (fixedEmail && this.isValidEmail(fixedEmail)) {
        await this.databaseService.query(
          'UPDATE customers SET email = $1 WHERE id = $2',
          [fixedEmail, record.id]
        );
        cleanedCount++;
      } else {
        // æ— æ³•ä¿®å¤ï¼Œè®¾ä¸ºnull
        await this.databaseService.query(
          'UPDATE customers SET email = NULL WHERE id = $1',
          [record.id]
        );
        cleanedCount++;
      }
    }

    return {
      operation: 'clean_emails',
      description: 'æ¸…ç†æ— æ•ˆé‚®ç®±',
      processedCount: emails.rows.length,
      cleanedCount,
      details: `æ¸…ç†äº† ${cleanedCount} ä¸ªæ— æ•ˆé‚®ç®±`,
    };
  }

  private async completeCustomerInfo(): Promise<CleansingOperation> {
    // åŸºäºå†å²è®¢å•è¡¥å…¨å®¢æˆ·ä¿¡æ¯
    const incompleteQuery = `
      SELECT c.id, c.name, c.phone, c.email
      FROM customers c
      WHERE c.name IS NULL OR c.phone IS NULL OR c.email IS NULL
    `;

    const incomplete = await this.databaseService.query(incompleteQuery);
    let cleanedCount = 0;

    for (const customer of incomplete.rows) {
      const completed = await this.enrichCustomerData(customer);
      if (completed) {
        cleanedCount++;
      }
    }

    return {
      operation: 'complete_info',
      description: 'è¡¥å…¨å®¢æˆ·ä¿¡æ¯',
      processedCount: incomplete.rows.length,
      cleanedCount,
      details: `è¡¥å…¨äº† ${cleanedCount} ä¸ªå®¢æˆ·çš„ä¿¡æ¯`,
    };
  }

  private standardizePhone(phone: string): string | null {
    // ç§»é™¤æ‰€æœ‰éæ•°å­—å­—ç¬¦
    const cleaned = phone.replace(/\D/g, '');
    
    // å¤„ç†ä¸åŒæ ¼å¼çš„æ‰‹æœºå·
    if (cleaned.length === 11 && cleaned.startsWith('1')) {
      return cleaned;
    } else if (cleaned.length === 13 && cleaned.startsWith('86')) {
      return cleaned.substring(2);
    } else if (cleaned.length === 10) {
      return '1' + cleaned;
    }
    
    return null;
  }

  private fixCommonEmailErrors(email: string): string | null {
    let fixed = email.toLowerCase().trim();
    
    // ä¿®å¤å¸¸è§é”™è¯¯
    fixed = fixed.replace(/\.{2,}/g, '.');  // å¤šä¸ªç‚¹
    fixed = fixed.replace(/^\.+|\.+$/g, ''); // å¼€å¤´ç»“å°¾çš„ç‚¹
    fixed = fixed.replace(/\s+/g, '');       // ç©ºæ ¼
    
    // ä¿®å¤å¸¸è§åŸŸåé”™è¯¯
    const domainFixes = {
      'gmial.com': 'gmail.com',
      'gmai.com': 'gmail.com',
      'yahooo.com': 'yahoo.com',
      'hotmial.com': 'hotmail.com',
    };
    
    for (const [wrong, correct] of Object.entries(domainFixes)) {
      fixed = fixed.replace(wrong, correct);
    }
    
    return fixed;
  }

  private isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  private async mergeCustomerData(keepId: number, removeIds: number[]): Promise<void> {
    // åˆå¹¶è®¢å•
    await this.databaseService.query(
      'UPDATE orders SET customer_id = $1 WHERE customer_id = ANY($2)',
      [keepId, removeIds]
    );

    // åˆå¹¶çº¿ç´¢
    await this.databaseService.query(
      'UPDATE leads SET customer_id = $1 WHERE customer_id = ANY($2)',
      [keepId, removeIds]
    );

    // åˆå¹¶å…¶ä»–ç›¸å…³æ•°æ®...
  }

  private async enrichCustomerData(customer: any): Promise<boolean> {
    // ä»è®¢å•ä¸­è·å–å®¢æˆ·ä¿¡æ¯
    const orderInfoQuery = `
      SELECT DISTINCT 
        shipping_name, 
        shipping_phone, 
        shipping_email
      FROM orders 
      WHERE customer_id = $1 
      AND (shipping_name IS NOT NULL OR shipping_phone IS NOT NULL OR shipping_email IS NOT NULL)
      ORDER BY created_at DESC
      LIMIT 1
    `;

    const orderInfo = await this.databaseService.query(orderInfoQuery, [customer.id]);
    
    if (orderInfo.rows.length > 0) {
      const info = orderInfo.rows[0];
      const updates: string[] = [];
      const values: any[] = [];
      let paramIndex = 1;

      if (!customer.name && info.shipping_name) {
        updates.push(`name = $${paramIndex++}`);
        values.push(info.shipping_name);
      }

      if (!customer.phone && info.shipping_phone) {
        updates.push(`phone = $${paramIndex++}`);
        values.push(info.shipping_phone);
      }

      if (!customer.email && info.shipping_email) {
        updates.push(`email = $${paramIndex++}`);
        values.push(info.shipping_email);
      }

      if (updates.length > 0) {
        values.push(customer.id);
        await this.databaseService.query(
          `UPDATE customers SET ${updates.join(', ')} WHERE id = $${paramIndex}`,
          values
        );
        return true;
      }
    }

    return false;
  }

  private async logCleansingResult(result: CleansingResult): Promise<void> {
    await this.logService.log({
      level: 'info',
      category: 'data_cleansing',
      message: `æ•°æ®æ¸…æ´—å®Œæˆ - ${result.tableName}`,
      details: result,
    });
  }
}

// æ•°æ®æ¸…æ´—æ¥å£å®šä¹‰
interface CleansingOperation {
  operation: string;
  description: string;
  processedCount: number;
  cleanedCount: number;
  details: string;
}

interface CleansingResult {
  tableName: string;
  operations: CleansingOperation[];
  totalProcessed: number;
  totalCleansed: number;
  duration: number;
  timestamp: Date;
}
```

---

## ğŸ¢ ä¸»æ•°æ®ç®¡ç†

### 1. ä¸»æ•°æ®æ¶æ„è®¾è®¡

#### 1.1 ä¸»æ•°æ®æ¨¡å‹
```typescript
// ä¸»æ•°æ®ç®¡ç†æœåŠ¡
// src/services/master-data/master-data.service.ts

export class MasterDataService {
  constructor(
    private databaseService: DatabaseService,
    private cacheService: CacheService,
    private eventBus: EventBus
  ) {}

  // å®¢æˆ·ä¸»æ•°æ®ç®¡ç†
  async createCustomerMaster(customerData: CustomerMasterData): Promise<CustomerMaster> {
    // 1. æ•°æ®éªŒè¯
    await this.validateCustomerData(customerData);

    // 2. é‡å¤æ£€æŸ¥
    const duplicates = await this.findDuplicateCustomers(customerData);
    if (duplicates.length > 0) {
      throw new Error(`å‘ç°é‡å¤å®¢æˆ·: ${duplicates.map(d => d.id).join(', ')}`);
    }

    // 3. ç”Ÿæˆä¸»æ•°æ®ID
    const masterId = await this.generateMasterId('customer');

    // 4. åˆ›å»ºä¸»æ•°æ®è®°å½•
    const masterRecord = await this.databaseService.query(`
      INSERT INTO customer_master (
        master_id, name, phone, email, company, 
        industry, source, status, created_at, updated_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW())
      RETURNING *
    `, [
      masterId,
      customerData.name,
      customerData.phone,
      customerData.email,
      customerData.company,
      customerData.industry,
      customerData.source,
      'active'
    ]);

    const master = masterRecord.rows[0];

    // 5. æ›´æ–°ç¼“å­˜
    await this.updateCustomerCache(master);

    // 6. å‘å¸ƒäº‹ä»¶
    await this.eventBus.publish('customer.master.created', {
      masterId: master.master_id,
      customerData: master,
    });

    return master;
  }

  async updateCustomerMaster(masterId: string, updates: Partial<CustomerMasterData>): Promise<CustomerMaster> {
    // 1. éªŒè¯ä¸»æ•°æ®å­˜åœ¨
    const existing = await this.getCustomerMaster(masterId);
    if (!existing) {
      throw new Error(`å®¢æˆ·ä¸»æ•°æ®ä¸å­˜åœ¨: ${masterId}`);
    }

    // 2. æ•°æ®éªŒè¯
    await this.validateCustomerData({ ...existing, ...updates });

    // 3. æ›´æ–°è®°å½•
    const updateFields = Object.keys(updates).map((key, index) => `${key} = $${index + 2}`).join(', ');
    const values = [masterId, ...Object.values(updates)];

    const result = await this.databaseService.query(`
      UPDATE customer_master 
      SET ${updateFields}, updated_at = NOW()
      WHERE master_id = $1
      RETURNING *
    `, values);

    const updated = result.rows[0];

    // 4. æ›´æ–°ç¼“å­˜
    await this.updateCustomerCache(updated);

    // 5. åŒæ­¥åˆ°ä¸‹æ¸¸ç³»ç»Ÿ
    await this.syncCustomerToDownstream(updated);

    // 6. å‘å¸ƒäº‹ä»¶
    await this.eventBus.publish('customer.master.updated', {
      masterId,
      oldData: existing,
      newData: updated,
      changes: updates,
    });

    return updated;
  }

  async getCustomerMaster(masterId: string): Promise<CustomerMaster | null> {
    // å…ˆä»ç¼“å­˜è·å–
    const cached = await this.cacheService.get(`customer:master:${masterId}`);
    if (cached) {
      return JSON.parse(cached);
    }

    // ä»æ•°æ®åº“è·å–
    const result = await this.databaseService.query(
      'SELECT * FROM customer_master WHERE master_id = $1',
      [masterId]
    );

    if (result.rows.length === 0) {
      return null;
    }

    const master = result.rows[0];
    
    // æ›´æ–°ç¼“å­˜
    await this.cacheService.set(
      `customer:master:${masterId}`,
      JSON.stringify(master),
      3600 // 1å°æ—¶è¿‡æœŸ
    );

    return master;
  }

  async linkCustomerRecord(masterId: string, systemId: string, recordId: string): Promise<void> {
    // åˆ›å»ºå…³è”è®°å½•
    await this.databaseService.query(`
      INSERT INTO customer_master_links (master_id, system_id, record_id, created_at)
      VALUES ($1, $2, $3, NOW())
      ON CONFLICT (master_id, system_id, record_id) DO NOTHING
    `, [masterId, systemId, recordId]);

    // å‘å¸ƒäº‹ä»¶
    await this.eventBus.publish('customer.master.linked', {
      masterId,
      systemId,
      recordId,
    });
  }

  async findDuplicateCustomers(customerData: CustomerMasterData): Promise<CustomerMaster[]> {
    const conditions: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    // åŸºäºæ‰‹æœºå·æŸ¥æ‰¾
    if (customerData.phone) {
      conditions.push(`phone = $${paramIndex++}`);
      values.push(customerData.phone);
    }

    // åŸºäºé‚®ç®±æŸ¥æ‰¾
    if (customerData.email) {
      conditions.push(`email = $${paramIndex++}`);
      values.push(customerData.email);
    }

    // åŸºäºå…¬å¸åç§°å’Œè”ç³»äººå§“åæŸ¥æ‰¾
    if (customerData.company && customerData.name) {
      conditions.push(`(company = $${paramIndex++} AND name = $${paramIndex++})`);
      values.push(customerData.company, customerData.name);
    }

    if (conditions.length === 0) {
      return [];
    }

    const query = `
      SELECT * FROM customer_master 
      WHERE status = 'active' AND (${conditions.join(' OR ')})
    `;

    const result = await this.databaseService.query(query, values);
    return result.rows;
  }

  private async validateCustomerData(data: Partial<CustomerMasterData>): Promise<void> {
    const errors: string[] = [];

    // å¿…å¡«å­—æ®µéªŒè¯
    if (!data.name || data.name.trim().length === 0) {
      errors.push('å®¢æˆ·å§“åä¸èƒ½ä¸ºç©º');
    }

    // æ‰‹æœºå·éªŒè¯
    if (data.phone && !/^1[3-9]\d{9}$/.test(data.phone)) {
      errors.push('æ‰‹æœºå·æ ¼å¼ä¸æ­£ç¡®');
    }

    // é‚®ç®±éªŒè¯
    if (data.email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(data.email)) {
      errors.push('é‚®ç®±æ ¼å¼ä¸æ­£ç¡®');
    }

    // è‡³å°‘éœ€è¦ä¸€ä¸ªè”ç³»æ–¹å¼
    if (!data.phone && !data.email) {
      errors.push('è‡³å°‘éœ€è¦æä¾›æ‰‹æœºå·æˆ–é‚®ç®±');
    }

    if (errors.length > 0) {
      throw new Error(`æ•°æ®éªŒè¯å¤±è´¥: ${errors.join(', ')}`);
    }
  }

  private async generateMasterId(type: string): Promise<string> {
    const prefix = type.toUpperCase();
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substring(2, 8);
    return `${prefix}_${timestamp}_${random}`.toUpperCase();
  }

  private async updateCustomerCache(customer: CustomerMaster): Promise<void> {
    const cacheKey = `customer:master:${customer.master_id}`;
    await this.cacheService.set(cacheKey, JSON.stringify(customer), 3600);

    // æ›´æ–°ç´¢å¼•ç¼“å­˜
    if (customer.phone) {
      await this.cacheService.set(`customer:phone:${customer.phone}`, customer.master_id, 3600);
    }
    if (customer.email) {
      await this.cacheService.set(`customer:email:${customer.email}`, customer.master_id, 3600);
    }
  }

  private async syncCustomerToDownstream(customer: CustomerMaster): Promise<void> {
    // è·å–æ‰€æœ‰å…³è”çš„ç³»ç»Ÿè®°å½•
    const links = await this.databaseService.query(
      'SELECT * FROM customer_master_links WHERE master_id = $1',
      [customer.master_id]
    );

    // åŒæ­¥åˆ°å„ä¸ªä¸‹æ¸¸ç³»ç»Ÿ
    for (const link of links.rows) {
      await this.syncToSystem(link.system_id, link.record_id, customer);
    }
  }

  private async syncToSystem(systemId: string, recordId: string, customer: CustomerMaster): Promise<void> {
    switch (systemId) {
      case 'crm':
        await this.syncToCRM(recordId, customer);
        break;
      case 'order':
        await this.syncToOrderSystem(recordId, customer);
        break;
      case 'marketing':
        await this.syncToMarketingSystem(recordId, customer);
        break;
      default:
        console.warn(`æœªçŸ¥çš„ç³»ç»ŸID: ${systemId}`);
    }
  }

  private async syncToCRM(recordId: string, customer: CustomerMaster): Promise<void> {
    await this.databaseService.query(`
      UPDATE customers SET 
        name = $1, 
        phone = $2, 
        email = $3, 
        company = $4,
        updated_at = NOW()
      WHERE id = $5
    `, [customer.name, customer.phone, customer.email, customer.company, recordId]);
  }

  private async syncToOrderSystem(recordId: string, customer: CustomerMaster): Promise<void> {
    // åŒæ­¥åˆ°è®¢å•ç³»ç»Ÿçš„å®¢æˆ·ä¿¡æ¯
    await this.databaseService.query(`
      UPDATE order_customers SET 
        name = $1, 
        phone = $2, 
        email = $3,
        updated_at = NOW()
      WHERE id = $5
    `, [customer.name, customer.phone, customer.email, recordId]);
  }

  private async syncToMarketingSystem(recordId: string, customer: CustomerMaster): Promise<void> {
    // åŒæ­¥åˆ°è¥é”€ç³»ç»Ÿçš„å®¢æˆ·ä¿¡æ¯
    // è¿™é‡Œå¯ä»¥è°ƒç”¨è¥é”€ç³»ç»Ÿçš„API
  }
}

// ä¸»æ•°æ®æ¥å£å®šä¹‰
interface CustomerMasterData {
  name: string;
  phone?: string;
  email?: string;
  company?: string;
  industry?: string;
  source?: string;
}

interface CustomerMaster extends CustomerMasterData {
  master_id: string;
  status: 'active' | 'inactive' | 'merged';
  created_at: Date;
  updated_at: Date;
}
```

### 2. ä¸»æ•°æ®åŒæ­¥æœºåˆ¶

#### 2.1 æ•°æ®åŒæ­¥é…ç½®
```yaml
# ä¸»æ•°æ®åŒæ­¥é…ç½®
# config/master-data-sync.yml
sync_config:
  customer:
    source_system: "master_data"
    target_systems:
      - system_id: "crm"
        table: "customers"
        mapping:
          master_id: "master_customer_id"
          name: "name"
          phone: "phone"
          email: "email"
          company: "company"
        sync_mode: "real_time"
        
      - system_id: "order"
        table: "order_customers"
        mapping:
          master_id: "master_customer_id"
          name: "customer_name"
          phone: "customer_phone"
          email: "customer_email"
        sync_mode: "batch"
        batch_interval: "1h"
        
      - system_id: "marketing"
        api_endpoint: "https://marketing.luolai.com/api/customers"
        mapping:
          master_id: "customerId"
          name: "customerName"
          phone: "phoneNumber"
          email: "emailAddress"
          company: "companyName"
        sync_mode: "real_time"
        retry_policy:
          max_retries: 3
          retry_interval: "5m"

  product:
    source_system: "master_data"
    target_systems:
      - system_id: "catalog"
        table: "products"
        mapping:
          master_id: "master_product_id"
          name: "product_name"
          sku: "sku_code"
          category: "category_id"
          price: "base_price"
        sync_mode: "real_time"
        
      - system_id: "inventory"
        table: "inventory_items"
        mapping:
          master_id: "master_product_id"
          sku: "item_sku"
          name: "item_name"
        sync_mode: "real_time"

sync_monitoring:
  enabled: true
  metrics:
    - sync_success_rate
    - sync_latency
    - sync_error_count
    - data_consistency_score
  alerts:
    - condition: "sync_success_rate < 95%"
      severity: "high"
      notification: ["email", "slack"]
    - condition: "sync_latency > 30s"
      severity: "medium"
      notification: ["slack"]
```

---

## ğŸ“ˆ å…ƒæ•°æ®ç®¡ç†

### 1. å…ƒæ•°æ®æ¶æ„

#### 1.1 å…ƒæ•°æ®æ¨¡å‹è®¾è®¡
```sql
-- å…ƒæ•°æ®ç®¡ç†è¡¨ç»“æ„
-- database/migrations/create_metadata_tables.sql

-- æ•°æ®æºè¡¨
CREATE TABLE data_sources (
    id SERIAL PRIMARY KEY,
    source_id VARCHAR(100) UNIQUE NOT NULL,
    name VARCHAR(200) NOT NULL,
    type VARCHAR(50) NOT NULL, -- database, api, file, stream
    connection_info JSONB,
    description TEXT,
    owner_id INTEGER,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- æ•°æ®è¡¨å…ƒæ•°æ®
CREATE TABLE data_tables (
    id SERIAL PRIMARY KEY,
    table_id VARCHAR(100) UNIQUE NOT NULL,
    source_id VARCHAR(100) REFERENCES data_sources(source_id),
    schema_name VARCHAR(100),
    table_name VARCHAR(100) NOT NULL,
    table_type VARCHAR(50), -- table, view, materialized_view
    description TEXT,
    business_purpose TEXT,
    data_classification VARCHAR(50), -- public, internal, confidential, restricted
    retention_period INTEGER, -- ä¿ç•™æœŸé™ï¼ˆå¤©ï¼‰
    owner_id INTEGER,
    steward_id INTEGER,
    row_count BIGINT,
    size_mb DECIMAL(10,2),
    last_updated TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- æ•°æ®å­—æ®µå…ƒæ•°æ®
CREATE TABLE data_columns (
    id SERIAL PRIMARY KEY,
    column_id VARCHAR(100) UNIQUE NOT NULL,
    table_id VARCHAR(100) REFERENCES data_tables(table_id),
    column_name VARCHAR(100) NOT NULL,
    data_type VARCHAR(50) NOT NULL,
    max_length INTEGER,
    is_nullable BOOLEAN DEFAULT true,
    is_primary_key BOOLEAN DEFAULT false,
    is_foreign_key BOOLEAN DEFAULT false,
    default_value TEXT,
    description TEXT,
    business_name VARCHAR(200),
    business_rules TEXT,
    data_classification VARCHAR(50),
    sensitive_data_type VARCHAR(50), -- pii, financial, health, etc.
    quality_rules JSONB,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- æ•°æ®è¡€ç¼˜å…³ç³»
CREATE TABLE data_lineage (
    id SERIAL PRIMARY KEY,
    lineage_id VARCHAR(100) UNIQUE NOT NULL,
    source_table_id VARCHAR(100),
    source_column_id VARCHAR(100),
    target_table_id VARCHAR(100),
    target_column_id VARCHAR(100),
    transformation_type VARCHAR(50), -- direct, calculated, aggregated, joined
    transformation_logic TEXT,
    process_id VARCHAR(100), -- ETLä½œä¸šID
    created_at TIMESTAMP DEFAULT NOW()
);

-- æ•°æ®å­—å…¸
CREATE TABLE data_dictionary (
    id SERIAL PRIMARY KEY,
    term_id VARCHAR(100) UNIQUE NOT NULL,
    term_name VARCHAR(200) NOT NULL,
    definition TEXT NOT NULL,
    business_context TEXT,
    synonyms TEXT[],
    related_terms TEXT[],
    domain VARCHAR(100),
    status VARCHAR(20) DEFAULT 'active',
    owner_id INTEGER,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- æ•°æ®è´¨é‡è§„åˆ™
CREATE TABLE data_quality_rules (
    id SERIAL PRIMARY KEY,
    rule_id VARCHAR(100) UNIQUE NOT NULL,
    rule_name VARCHAR(200) NOT NULL,
    table_id VARCHAR(100) REFERENCES data_tables(table_id),
    column_id VARCHAR(100),
    rule_type VARCHAR(50), -- completeness, accuracy, consistency, validity
    rule_expression TEXT NOT NULL,
    threshold_value DECIMAL(5,2),
    severity VARCHAR(20), -- low, medium, high, critical
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_data_tables_source_id ON data_tables(source_id);
CREATE INDEX idx_data_columns_table_id ON data_columns(table_id);
CREATE INDEX idx_data_lineage_source ON data_lineage(source_table_id, source_column_id);
CREATE INDEX idx_data_lineage_target ON data_lineage(target_table_id, target_column_id);
CREATE INDEX idx_data_dictionary_domain ON data_dictionary(domain);
CREATE INDEX idx_data_quality_rules_table ON data_quality_rules(table_id);
```

#### 1.2 å…ƒæ•°æ®é‡‡é›†æœåŠ¡
```typescript
// å…ƒæ•°æ®é‡‡é›†æœåŠ¡
// src/services/metadata/metadata-collector.service.ts

export class MetadataCollectorService {
  constructor(
    private databaseService: DatabaseService,
    private configService: ConfigService
  ) {}

  async collectDatabaseMetadata(sourceId: string): Promise<void> {
    console.log(`å¼€å§‹é‡‡é›†æ•°æ®æº ${sourceId} çš„å…ƒæ•°æ®...`);

    // 1. è·å–æ•°æ®æºé…ç½®
    const dataSource = await this.getDataSource(sourceId);
    if (!dataSource) {
      throw new Error(`æ•°æ®æºä¸å­˜åœ¨: ${sourceId}`);
    }

    // 2. å»ºç«‹æ•°æ®åº“è¿æ¥
    const connection = await this.createConnection(dataSource);

    try {
      // 3. é‡‡é›†è¡¨å…ƒæ•°æ®
      await this.collectTableMetadata(sourceId, connection);

      // 4. é‡‡é›†å­—æ®µå…ƒæ•°æ®
      await this.collectColumnMetadata(sourceId, connection);

      // 5. é‡‡é›†ç´¢å¼•ä¿¡æ¯
      await this.collectIndexMetadata(sourceId, connection);

      // 6. é‡‡é›†ç»Ÿè®¡ä¿¡æ¯
      await this.collectStatistics(sourceId, connection);

      console.log(`æ•°æ®æº ${sourceId} å…ƒæ•°æ®é‡‡é›†å®Œæˆ`);
    } finally {
      await connection.end();
    }
  }

  private async collectTableMetadata(sourceId: string, connection: any): Promise<void> {
    const tablesQuery = `
      SELECT 
        schemaname as schema_name,
        tablename as table_name,
        'table' as table_type,
        obj_description(c.oid) as description
      FROM pg_tables t
      LEFT JOIN pg_class c ON c.relname = t.tablename
      WHERE schemaname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
      
      UNION ALL
      
      SELECT 
        schemaname as schema_name,
        viewname as table_name,
        'view' as table_type,
        obj_description(c.oid) as description
      FROM pg_views v
      LEFT JOIN pg_class c ON c.relname = v.viewname
      WHERE schemaname NOT IN ('information_schema', 'pg_catalog')
    `;

    const tables = await connection.query(tablesQuery);

    for (const table of tables.rows) {
      const tableId = `${sourceId}.${table.schema_name}.${table.table_name}`;
      
      // è·å–è¡¨ç»Ÿè®¡ä¿¡æ¯
      const statsQuery = `
        SELECT 
          n_tup_ins + n_tup_upd + n_tup_del as total_operations,
          n_live_tup as row_count,
          pg_total_relation_size(c.oid) / 1024 / 1024 as size_mb
        FROM pg_stat_user_tables s
        JOIN pg_class c ON c.relname = s.relname
        WHERE s.schemaname = $1 AND s.relname = $2
      `;
      
      const stats = await connection.query(statsQuery, [table.schema_name, table.table_name]);
      const tableStats = stats.rows[0] || {};

      // æ’å…¥æˆ–æ›´æ–°è¡¨å…ƒæ•°æ®
      await this.databaseService.query(`
        INSERT INTO data_tables (
          table_id, source_id, schema_name, table_name, table_type,
          description, row_count, size_mb, last_updated, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW())
        ON CONFLICT (table_id) DO UPDATE SET
          description = EXCLUDED.description,
          row_count = EXCLUDED.row_count,
          size_mb = EXCLUDED.size_mb,
          last_updated = EXCLUDED.last_updated,
          updated_at = NOW()
      `, [
        tableId,
        sourceId,
        table.schema_name,
        table.table_name,
        table.table_type,
        table.description,
        tableStats.row_count || 0,
        tableStats.size_mb || 0
      ]);
    }
  }

  private async collectColumnMetadata(sourceId: string, connection: any): Promise<void> {
    const columnsQuery = `
      SELECT 
        t.table_schema as schema_name,
        t.table_name,
        t.column_name,
        t.data_type,
        t.character_maximum_length as max_length,
        t.is_nullable = 'YES' as is_nullable,
        t.column_default as default_value,
        col_description(c.oid, t.ordinal_position) as description,
        CASE WHEN pk.column_name IS NOT NULL THEN true ELSE false END as is_primary_key,
        CASE WHEN fk.column_name IS NOT NULL THEN true ELSE false END as is_foreign_key
      FROM information_schema.columns t
      LEFT JOIN pg_class c ON c.relname = t.table_name
      LEFT JOIN (
        SELECT ku.table_name, ku.column_name
        FROM information_schema.table_constraints tc
        JOIN information_schema.key_column_usage ku ON tc.constraint_name = ku.constraint_name
        WHERE tc.constraint_type = 'PRIMARY KEY'
      ) pk ON pk.table_name = t.table_name AND pk.column_name = t.column_name
      LEFT JOIN (
        SELECT ku.table_name, ku.column_name
        FROM information_schema.table_constraints tc
        JOIN information_schema.key_column_usage ku ON tc.constraint_name = ku.constraint_name
        WHERE tc.constraint_type = 'FOREIGN KEY'
      ) fk ON fk.table_name = t.table_name AND fk.column_name = t.column_name
      WHERE t.table_schema NOT IN ('information_schema', 'pg_catalog')
      ORDER BY t.table_schema, t.table_name, t.ordinal_position
    `;

    const columns = await connection.query(columnsQuery);

    for (const column of columns.rows) {
      const tableId = `${sourceId}.${column.schema_name}.${column.table_name}`;
      const columnId = `${tableId}.${column.column_name}`;

      // æ£€æµ‹æ•æ„Ÿæ•°æ®ç±»å‹
      const sensitiveDataType = this.detectSensitiveDataType(column.column_name, column.data_type);
      
      // ç¡®å®šæ•°æ®åˆ†ç±»
      const dataClassification = this.classifyData(column.column_name, sensitiveDataType);

      await this.databaseService.query(`
        INSERT INTO data_columns (
          column_id, table_id, column_name, data_type, max_length,
          is_nullable, is_primary_key, is_foreign_key, default_value,
          description, data_classification, sensitive_data_type, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, NOW())
        ON CONFLICT (column_id) DO UPDATE SET
          data_type = EXCLUDED.data_type,
          max_length = EXCLUDED.max_length,
          is_nullable = EXCLUDED.is_nullable,
          is_primary_key = EXCLUDED.is_primary_key,
          is_foreign_key = EXCLUDED.is_foreign_key,
          default_value = EXCLUDED.default_value,
          description = EXCLUDED.description,
          data_classification = EXCLUDED.data_classification,
          sensitive_data_type = EXCLUDED.sensitive_data_type,
          updated_at = NOW()
      `, [
        columnId,
        tableId,
        column.column_name,
        column.data_type,
        column.max_length,
        column.is_nullable,
        column.is_primary_key,
        column.is_foreign_key,
        column.default_value,
        column.description,
        dataClassification,
        sensitiveDataType
      ]);
    }
  }

  private detectSensitiveDataType(columnName: string, dataType: string): string | null {
    const sensitivePatterns = {
      'pii': [
        /name/i, /å§“å/i, /ç”¨æˆ·å/i,
        /phone/i, /ç”µè¯/i, /æ‰‹æœº/i,
        /email/i, /é‚®ç®±/i, /é‚®ä»¶/i,
        /address/i, /åœ°å€/i,
        /id_card/i, /èº«ä»½è¯/i
      ],
      'financial': [
        /price/i, /é‡‘é¢/i, /amount/i,
        /salary/i, /å·¥èµ„/i, /è–ªèµ„/i,
        /account/i, /è´¦æˆ·/i, /é“¶è¡Œ/i
      ],
      'auth': [
        /password/i, /å¯†ç /i, /pwd/i,
        /token/i, /secret/i, /key/i
      ]
    };

    for (const [type, patterns] of Object.entries(sensitivePatterns)) {
      if (patterns.some(pattern => pattern.test(columnName))) {
        return type;
      }
    }

    return null;
  }

  private classifyData(columnName: string, sensitiveDataType: string | null): string {
    if (sensitiveDataType === 'auth') {
      return 'restricted';
    } else if (sensitiveDataType === 'pii' || sensitiveDataType === 'financial') {
      return 'confidential';
    } else if (/internal|private/i.test(columnName)) {
      return 'internal';
    } else {
      return 'public';
    }
  }

  private async getDataSource(sourceId: string): Promise<any> {
    const result = await this.databaseService.query(
      'SELECT * FROM data_sources WHERE source_id = $1',
      [sourceId]
    );
    return result.rows[0];
  }

  private async createConnection(dataSource: any): Promise<any> {
    const { Pool } = require('pg');
    const pool = new Pool(dataSource.connection_info);
    return pool;
  }
}
```

### 2. æ•°æ®è¡€ç¼˜åˆ†æ

#### 2.1 è¡€ç¼˜å…³ç³»è¿½è¸ª
```typescript
// æ•°æ®è¡€ç¼˜åˆ†ææœåŠ¡
// src/services/metadata/data-lineage.service.ts

export class DataLineageService {
  constructor(
    private databaseService: DatabaseService,
    private metadataService: MetadataService
  ) {}

  async analyzeLineage(tableId: string): Promise<LineageGraph> {
    const upstreamTables = await this.getUpstreamTables(tableId);
    const downstreamTables = await this.getDownstreamTables(tableId);
    
    const graph: LineageGraph = {
      rootTable: tableId,
      upstream: await this.buildLineageTree(upstreamTables, 'upstream'),
      downstream: await this.buildLineageTree(downstreamTables, 'downstream'),
      metadata: await this.getTableMetadata(tableId),
    };

    return graph;
  }

  async trackColumnLineage(columnId: string): Promise<ColumnLineage> {
    const column = await this.getColumnMetadata(columnId);
    if (!column) {
      throw new Error(`å­—æ®µä¸å­˜åœ¨: ${columnId}`);
    }

    // æŸ¥æ‰¾ä¸Šæ¸¸å­—æ®µ
    const upstreamQuery = `
      SELECT 
        l.*,
        st.table_name as source_table_name,
        sc.column_name as source_column_name,
        tt.table_name as target_table_name,
        tc.column_name as target_column_name
      FROM data_lineage l
      LEFT JOIN data_tables st ON st.table_id = l.source_table_id
      LEFT JOIN data_columns sc ON sc.column_id = l.source_column_id
      LEFT JOIN data_tables tt ON tt.table_id = l.target_table_id
      LEFT JOIN data_columns tc ON tc.column_id = l.target_column_id
      WHERE l.target_column_id = $1
    `;

    const upstream = await this.databaseService.query(upstreamQuery, [columnId]);

    // æŸ¥æ‰¾ä¸‹æ¸¸å­—æ®µ
    const downstreamQuery = `
      SELECT 
        l.*,
        st.table_name as source_table_name,
        sc.column_name as source_column_name,
        tt.table_name as target_table_name,
        tc.column_name as target_column_name
      FROM data_lineage l
      LEFT JOIN data_tables st ON st.table_id = l.source_table_id
      LEFT JOIN data_columns sc ON sc.column_id = l.source_column_id
      LEFT JOIN data_tables tt ON tt.table_id = l.target_table_id
      LEFT JOIN data_columns tc ON tc.column_id = l.target_column_id
      WHERE l.source_column_id = $1
    `;

    const downstream = await this.databaseService.query(downstreamQuery, [columnId]);

    return {
      column,
      upstream: upstream.rows,
      downstream: downstream.rows,
      impactAnalysis: await this.analyzeImpact(columnId),
    };
  }

  async recordLineage(lineageData: LineageRecord): Promise<void> {
    const lineageId = this.generateLineageId(lineageData);

    await this.databaseService.query(`
      INSERT INTO data_lineage (
        lineage_id, source_table_id, source_column_id,
        target_table_id, target_column_id, transformation_type,
        transformation_logic, process_id
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      ON CONFLICT (lineage_id) DO UPDATE SET
        transformation_type = EXCLUDED.transformation_type,
        transformation_logic = EXCLUDED.transformation_logic,
        process_id = EXCLUDED.process_id
    `, [
      lineageId,
      lineageData.sourceTableId,
      lineageData.sourceColumnId,
      lineageData.targetTableId,
      lineageData.targetColumnId,
      lineageData.transformationType,
      lineageData.transformationLogic,
      lineageData.processId
    ]);
  }

  async generateLineageReport(tableId: string): Promise<LineageReport> {
    const lineage = await this.analyzeLineage(tableId);
    const table = await this.getTableMetadata(tableId);
    
    const report: LineageReport = {
      tableId,
      tableName: table.table_name,
      reportDate: new Date(),
      upstreamCount: lineage.upstream.length,
      downstreamCount: lineage.downstream.length,
      totalImpactedTables: await this.countImpactedTables(tableId),
      criticalDependencies: await this.findCriticalDependencies(tableId),
      recommendations: await this.generateRecommendations(lineage),
    };

    return report;
  }

  private async getUpstreamTables(tableId: string): Promise<string[]> {
    const result = await this.databaseService.query(
      'SELECT DISTINCT source_table_id FROM data_lineage WHERE target_table_id = $1',
      [tableId]
    );
    return result.rows.map(row => row.source_table_id);
  }

  private async getDownstreamTables(tableId: string): Promise<string[]> {
    const result = await this.databaseService.query(
      'SELECT DISTINCT target_table_id FROM data_lineage WHERE source_table_id = $1',
      [tableId]
    );
    return result.rows.map(row => row.target_table_id);
  }

  private generateLineageId(lineageData: LineageRecord): string {
    const parts = [
      lineageData.sourceTableId,
      lineageData.sourceColumnId || 'table',
      lineageData.targetTableId,
      lineageData.targetColumnId || 'table'
    ];
    return parts.join('->');
  }
}

// æ•°æ®è¡€ç¼˜æ¥å£å®šä¹‰
interface LineageRecord {
  sourceTableId: string;
  sourceColumnId?: string;
  targetTableId: string;
  targetColumnId?: string;
  transformationType: string;
  transformationLogic?: string;
  processId?: string;
}

interface LineageGraph {
  rootTable: string;
  upstream: LineageNode[];
  downstream: LineageNode[];
  metadata: any;
}

interface LineageNode {
  tableId: string;
  tableName: string;
  transformationType: string;
  children: LineageNode[];
}

interface ColumnLineage {
  column: any;
  upstream: any[];
  downstream: any[];
  impactAnalysis: ImpactAnalysis;
}

interface ImpactAnalysis {
  affectedTables: string[];
  affectedReports: string[];
  businessImpact: string;
  riskLevel: 'low' | 'medium' | 'high';
}

interface LineageReport {
  tableId: string;
  tableName: string;
  reportDate: Date;
  upstreamCount: number;
  downstreamCount: number;
  totalImpactedTables: number;
  criticalDependencies: string[];
  recommendations: string[];
}
```

---

## ğŸ”’ æ•°æ®å®‰å…¨å’Œåˆè§„

### 1. æ•°æ®åˆ†ç±»åˆ†çº§

#### 1.1 æ•°æ®åˆ†ç±»æ ‡å‡†
```typescript
// æ•°æ®åˆ†ç±»æœåŠ¡
// src/services/data-governance/data-classification.service.ts

export class DataClassificationService {
  private classificationRules: ClassificationRule[] = [
    {
      id: 'pii_phone',
      name: 'ä¸ªäººæ‰‹æœºå·',
      pattern: /phone|ç”µè¯|æ‰‹æœº/i,
      dataType: 'varchar',
      classification: 'confidential',
      sensitiveType: 'pii',
      protectionLevel: 'high',
      retentionPeriod: 2555, // 7å¹´
      encryptionRequired: true,
      maskingRule: 'phone_masking',
    },
    {
      id: 'pii_email',
      name: 'ä¸ªäººé‚®ç®±',
      pattern: /email|é‚®ç®±|é‚®ä»¶/i,
      dataType: 'varchar',
      classification: 'confidential',
      sensitiveType: 'pii',
      protectionLevel: 'high',
      retentionPeriod: 2555,
      encryptionRequired: true,
      maskingRule: 'email_masking',
    },
    {
      id: 'financial_amount',
      name: 'é‡‘èé‡‘é¢',
      pattern: /amount|price|é‡‘é¢|ä»·æ ¼|è´¹ç”¨/i,
      dataType: 'numeric',
      classification: 'confidential',
      sensitiveType: 'financial',
      protectionLevel: 'high',
      retentionPeriod: 3650, // 10å¹´
      encryptionRequired: false,
      maskingRule: 'amount_masking',
    },
    {
      id: 'auth_password',
      name: 'è®¤è¯å¯†ç ',
      pattern: /password|pwd|å¯†ç /i,
      dataType: 'varchar',
      classification: 'restricted',
      sensitiveType: 'auth',
      protectionLevel: 'critical',
      retentionPeriod: 365,
      encryptionRequired: true,
      maskingRule: 'full_masking',
    },
  ];

  async classifyTable(tableId: string): Promise<TableClassification> {
    const columns = await this.getTableColumns(tableId);
    const classifiedColumns: ColumnClassification[] = [];
    
    for (const column of columns) {
      const classification = await this.classifyColumn(column);
      classifiedColumns.push(classification);
    }

    // ç¡®å®šè¡¨çº§åˆ«åˆ†ç±»ï¼ˆå–æœ€é«˜çº§åˆ«ï¼‰
    const tableClassification = this.determineTableClassification(classifiedColumns);
    
    // ä¿å­˜åˆ†ç±»ç»“æœ
    await this.saveClassificationResult(tableId, tableClassification, classifiedColumns);

    return {
      tableId,
      classification: tableClassification,
      columns: classifiedColumns,
      protectionRequirements: this.generateProtectionRequirements(classifiedColumns),
      complianceRequirements: this.generateComplianceRequirements(classifiedColumns),
    };
  }

  private async classifyColumn(column: any): Promise<ColumnClassification> {
    // åº”ç”¨åˆ†ç±»è§„åˆ™
    for (const rule of this.classificationRules) {
      if (this.matchesRule(column, rule)) {
        return {
          columnId: column.column_id,
          columnName: column.column_name,
          classification: rule.classification,
          sensitiveType: rule.sensitiveType,
          protectionLevel: rule.protectionLevel,
          retentionPeriod: rule.retentionPeriod,
          encryptionRequired: rule.encryptionRequired,
          maskingRule: rule.maskingRule,
          appliedRule: rule.id,
          confidence: this.calculateConfidence(column, rule),
        };
      }
    }

    // é»˜è®¤åˆ†ç±»
    return {
      columnId: column.column_id,
      columnName: column.column_name,
      classification: 'public',
      sensitiveType: null,
      protectionLevel: 'low',
      retentionPeriod: 1095, // 3å¹´
      encryptionRequired: false,
      maskingRule: null,
      appliedRule: 'default',
      confidence: 1.0,
    };
  }

  private matchesRule(column: any, rule: ClassificationRule): boolean {
    const nameMatch = rule.pattern.test(column.column_name);
    const typeMatch = !rule.dataType || column.data_type.includes(rule.dataType);
    return nameMatch && typeMatch;
  }

  private calculateConfidence(column: any, rule: ClassificationRule): number {
    let confidence = 0.5;
    
    // åç§°åŒ¹é…åº¦
    if (rule.pattern.test(column.column_name)) {
      confidence += 0.3;
    }
    
    // æ•°æ®ç±»å‹åŒ¹é…åº¦
    if (rule.dataType && column.data_type.includes(rule.dataType)) {
      confidence += 0.2;
    }
    
    return Math.min(confidence, 1.0);
  }

  private determineTableClassification(columns: ColumnClassification[]): string {
    const levels = ['public', 'internal', 'confidential', 'restricted'];
    let maxLevel = 'public';
    
    for (const column of columns) {
      const currentIndex = levels.indexOf(column.classification);
      const maxIndex = levels.indexOf(maxLevel);
      if (currentIndex > maxIndex) {
        maxLevel = column.classification;
      }
    }
    
    return maxLevel;
  }

  private generateProtectionRequirements(columns: ColumnClassification[]): ProtectionRequirement[] {
    const requirements: ProtectionRequirement[] = [];
    
    // åŠ å¯†è¦æ±‚
    const encryptionColumns = columns.filter(c => c.encryptionRequired);
    if (encryptionColumns.length > 0) {
      requirements.push({
        type: 'encryption',
        description: 'å­—æ®µçº§åŠ å¯†',
        columns: encryptionColumns.map(c => c.columnName),
        priority: 'high',
      });
    }
    
    // è„±æ•è¦æ±‚
    const maskingColumns = columns.filter(c => c.maskingRule);
    if (maskingColumns.length > 0) {
      requirements.push({
        type: 'masking',
        description: 'æ•°æ®è„±æ•',
        columns: maskingColumns.map(c => c.columnName),
        priority: 'medium',
      });
    }
    
    // è®¿é—®æ§åˆ¶è¦æ±‚
    const restrictedColumns = columns.filter(c => c.classification === 'restricted');
    if (restrictedColumns.length > 0) {
      requirements.push({
        type: 'access_control',
        description: 'ä¸¥æ ¼è®¿é—®æ§åˆ¶',
        columns: restrictedColumns.map(c => c.columnName),
        priority: 'critical',
      });
    }
    
    return requirements;
  }
}

// æ•°æ®åˆ†ç±»æ¥å£å®šä¹‰
interface ClassificationRule {
  id: string;
  name: string;
  pattern: RegExp;
  dataType?: string;
  classification: string;
  sensitiveType: string;
  protectionLevel: string;
  retentionPeriod: number;
  encryptionRequired: boolean;
  maskingRule: string | null;
}

interface ColumnClassification {
  columnId: string;
  columnName: string;
  classification: string;
  sensitiveType: string | null;
  protectionLevel: string;
  retentionPeriod: number;
  encryptionRequired: boolean;
  maskingRule: string | null;
  appliedRule: string;
  confidence: number;
}

interface TableClassification {
  tableId: string;
  classification: string;
  columns: ColumnClassification[];
  protectionRequirements: ProtectionRequirement[];
  complianceRequirements: ComplianceRequirement[];
}

interface ProtectionRequirement {
  type: string;
  description: string;
  columns: string[];
  priority: string;
}

interface ComplianceRequirement {
  regulation: string;
  requirement: string;
  applicableColumns: string[];
  deadline?: Date;
}
```

### 2. æ•°æ®ç”Ÿå‘½å‘¨æœŸç®¡ç†

#### 2.1 æ•°æ®ä¿ç•™ç­–ç•¥
```typescript
// æ•°æ®ç”Ÿå‘½å‘¨æœŸç®¡ç†æœåŠ¡
// src/services/data-governance/data-lifecycle.service.ts

export class DataLifecycleService {
  constructor(
    private databaseService: DatabaseService,
    private archiveService: ArchiveService,
    private notificationService: NotificationService
  ) {}

  async executeRetentionPolicy(): Promise<RetentionExecutionResult> {
    console.log('å¼€å§‹æ‰§è¡Œæ•°æ®ä¿ç•™ç­–ç•¥...');
    
    const results: RetentionResult[] = [];
    const policies = await this.getActiveRetentionPolicies();
    
    for (const policy of policies) {
      try {
        const result = await this.executePolicy(policy);
        results.push(result);
      } catch (error) {
        console.error(`æ‰§è¡Œä¿ç•™ç­–ç•¥å¤±è´¥: ${policy.id}`, error);
        results.push({
          policyId: policy.id,
          tableName: policy.tableName,
          success: false,
          error: error.message,
          processedRecords: 0,
          archivedRecords: 0,
          deletedRecords: 0,
        });
      }
    }
    
    const summary = this.generateExecutionSummary(results);
    await this.sendExecutionReport(summary);
    
    return summary;
  }

  private async executePolicy(policy: RetentionPolicy): Promise<RetentionResult> {
    const cutoffDate = this.calculateCutoffDate(policy);
    
    // æŸ¥æ‰¾éœ€è¦å¤„ç†çš„è®°å½•
    const recordsToProcess = await this.findRecordsToProcess(policy, cutoffDate);
    
    let archivedRecords = 0;
    let deletedRecords = 0;
    
    if (recordsToProcess.length > 0) {
      if (policy.action === 'archive') {
        archivedRecords = await this.archiveRecords(policy, recordsToProcess);
      } else if (policy.action === 'delete') {
        deletedRecords = await this.deleteRecords(policy, recordsToProcess);
      } else if (policy.action === 'archive_then_delete') {
        archivedRecords = await this.archiveRecords(policy, recordsToProcess);
        // ç­‰å¾…å½’æ¡£å®Œæˆååˆ é™¤
        await this.delay(5000);
        deletedRecords = await this.deleteRecords(policy, recordsToProcess);
      }
    }
    
    // è®°å½•æ‰§è¡Œæ—¥å¿—
    await this.logPolicyExecution(policy, {
      processedRecords: recordsToProcess.length,
      archivedRecords,
      deletedRecords,
      cutoffDate,
    });
    
    return {
      policyId: policy.id,
      tableName: policy.tableName,
      success: true,
      processedRecords: recordsToProcess.length,
      archivedRecords,
      deletedRecords,
      cutoffDate,
    };
  }

  private async getActiveRetentionPolicies(): Promise<RetentionPolicy[]> {
    const result = await this.databaseService.query(`
      SELECT 
        p.*,
        t.table_name,
        t.schema_name
      FROM data_retention_policies p
      JOIN data_tables t ON t.table_id = p.table_id
      WHERE p.is_active = true
      ORDER BY p.priority DESC
    `);
    
    return result.rows.map(row => ({
      id: row.id,
      tableId: row.table_id,
      tableName: row.table_name,
      schemaName: row.schema_name,
      retentionPeriodDays: row.retention_period_days,
      action: row.action,
      dateColumn: row.date_column,
      conditions: row.conditions ? JSON.parse(row.conditions) : null,
      priority: row.priority,
      isActive: row.is_active,
    }));
  }

  private calculateCutoffDate(policy: RetentionPolicy): Date {
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - policy.retentionPeriodDays);
    return cutoff;
  }

  private async findRecordsToProcess(policy: RetentionPolicy, cutoffDate: Date): Promise<any[]> {
    let whereClause = `${policy.dateColumn} < $1`;
    const params = [cutoffDate];
    
    // æ·»åŠ é¢å¤–æ¡ä»¶
    if (policy.conditions) {
      for (const [key, value] of Object.entries(policy.conditions)) {
        whereClause += ` AND ${key} = $${params.length + 1}`;
        params.push(value);
      }
    }
    
    const query = `
      SELECT id FROM ${policy.schemaName}.${policy.tableName}
      WHERE ${whereClause}
      LIMIT 10000
    `;
    
    const result = await this.databaseService.query(query, params);
    return result.rows;
  }

  private async archiveRecords(policy: RetentionPolicy, records: any[]): Promise<number> {
    const batchSize = 1000;
    let archivedCount = 0;
    
    for (let i = 0; i < records.length; i += batchSize) {
      const batch = records.slice(i, i + batchSize);
      const ids = batch.map(r => r.id);
      
      // è·å–å®Œæ•´è®°å½•æ•°æ®
      const dataQuery = `
        SELECT * FROM ${policy.schemaName}.${policy.tableName}
        WHERE id = ANY($1)
      `;
      const dataResult = await this.databaseService.query(dataQuery, [ids]);
      
      // å½’æ¡£åˆ°å½’æ¡£è¡¨æˆ–å¤–éƒ¨å­˜å‚¨
      await this.archiveService.archiveRecords(
        `${policy.schemaName}.${policy.tableName}`,
        dataResult.rows
      );
      
      archivedCount += batch.length;
    }
    
    return archivedCount;
  }

  private async deleteRecords(policy: RetentionPolicy, records: any[]): Promise<number> {
    const batchSize = 1000;
    let deletedCount = 0;
    
    for (let i = 0; i < records.length; i += batchSize) {
      const batch = records.slice(i, i + batchSize);
      const ids = batch.map(r => r.id);
      
      const deleteQuery = `
        DELETE FROM ${policy.schemaName}.${policy.tableName}
        WHERE id = ANY($1)
      `;
      
      const result = await this.databaseService.query(deleteQuery, [ids]);
      deletedCount += result.rowCount;
    }
    
    return deletedCount;
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// æ•°æ®ç”Ÿå‘½å‘¨æœŸæ¥å£å®šä¹‰
interface RetentionPolicy {
  id: string;
  tableId: string;
  tableName: string;
  schemaName: string;
  retentionPeriodDays: number;
  action: 'archive' | 'delete' | 'archive_then_delete';
  dateColumn: string;
  conditions?: Record<string, any>;
  priority: number;
  isActive: boolean;
}

interface RetentionResult {
  policyId: string;
  tableName: string;
  success: boolean;
  error?: string;
  processedRecords: number;
  archivedRecords: number;
  deletedRecords: number;
  cutoffDate?: Date;
}

interface RetentionExecutionResult {
  executionDate: Date;
  totalPolicies: number;
  successfulPolicies: number;
  failedPolicies: number;
  totalProcessedRecords: number;
  totalArchivedRecords: number;
  totalDeletedRecords: number;
  results: RetentionResult[];
}
```

---

## ğŸ“‹ æ•°æ®æ²»ç†ç›‘æ§å’ŒæŠ¥å‘Š

### 1. æ²»ç†ä»ªè¡¨æ¿

#### 1.1 æ²»ç†æŒ‡æ ‡ç›‘æ§
```typescript
// æ•°æ®æ²»ç†ç›‘æ§æœåŠ¡
// src/services/data-governance/governance-monitoring.service.ts

export class GovernanceMonitoringService {
  async generateGovernanceDashboard(): Promise<GovernanceDashboard> {
    const [
      qualityMetrics,
      complianceMetrics,
      lineageMetrics,
      securityMetrics,
      lifecycleMetrics
    ] = await Promise.all([
      this.getDataQualityMetrics(),
      this.getComplianceMetrics(),
      this.getLineageMetrics(),
      this.getSecurityMetrics(),
      this.getLifecycleMetrics()
    ]);

    return {
      lastUpdated: new Date(),
      overallScore: this.calculateOverallScore([
        qualityMetrics,
        complianceMetrics,
        lineageMetrics,
        securityMetrics,
        lifecycleMetrics
      ]),
      dataQuality: qualityMetrics,
      compliance: complianceMetrics,
      lineage: lineageMetrics,
      security: securityMetrics,
      lifecycle: lifecycleMetrics,
      alerts: await this.getActiveAlerts(),
      trends: await this.getTrends(),
    };
  }

  private async getDataQualityMetrics(): Promise<QualityMetrics> {
    const qualityQuery = `
      SELECT 
        COUNT(*) as total_tables,
        AVG(quality_score) as avg_quality_score,
        COUNT(CASE WHEN quality_score >= 95 THEN 1 END) as high_quality_tables,
        COUNT(CASE WHEN quality_score < 80 THEN 1 END) as low_quality_tables,
        SUM(total_violations) as total_violations
      FROM data_quality_reports
      WHERE report_date >= CURRENT_DATE - INTERVAL '7 days'
    `;

    const result = await this.databaseService.query(qualityQuery);
    const metrics = result.rows[0];

    return {
      totalTables: parseInt(metrics.total_tables),
      averageQualityScore: parseFloat(metrics.avg_quality_score) || 0,
      highQualityTables: parseInt(metrics.high_quality_tables),
      lowQualityTables: parseInt(metrics.low_quality_tables),
      totalViolations: parseInt(metrics.total_violations),
      qualityTrend: await this.getQualityTrend(),
    };
  }

  private async getComplianceMetrics(): Promise<ComplianceMetrics> {
    const complianceQuery = `
      SELECT 
        COUNT(DISTINCT table_id) as classified_tables,
        COUNT(CASE WHEN classification = 'restricted' THEN 1 END) as restricted_tables,
        COUNT(CASE WHEN classification = 'confidential' THEN 1 END) as confidential_tables,
        COUNT(CASE WHEN encryption_required = true THEN 1 END) as encrypted_columns
      FROM data_classification
    `;

    const result = await this.databaseService.query(complianceQuery);
    const metrics = result.rows[0];

    const retentionCompliance = await this.getRetentionCompliance();

    return {
      classifiedTables: parseInt(metrics.classified_tables),
      restrictedTables: parseInt(metrics.restricted_tables),
      confidentialTables: parseInt(metrics.confidential_tables),
      encryptedColumns: parseInt(metrics.encrypted_columns),
      retentionCompliance: retentionCompliance,
      complianceScore: this.calculateComplianceScore(metrics, retentionCompliance),
    };
  }

  async generateGovernanceReport(period: 'weekly' | 'monthly' | 'quarterly'): Promise<GovernanceReport> {
    const startDate = this.getReportStartDate(period);
    const endDate = new Date();

    const report: GovernanceReport = {
      reportPeriod: period,
      startDate,
      endDate,
      executiveSummary: await this.generateExecutiveSummary(startDate, endDate),
      dataQualitySection: await this.generateQualitySection(startDate, endDate),
      complianceSection: await this.generateComplianceSection(startDate, endDate),
      securitySection: await this.generateSecuritySection(startDate, endDate),
      recommendationsSection: await this.generateRecommendations(startDate, endDate),
      appendices: await this.generateAppendices(startDate, endDate),
    };

    return report;
  }
}
```

è¿™ä¸ªæ•°æ®æ²»ç†æ¡†æ¶è®¾è®¡æ–¹æ¡ˆæä¾›äº†å®Œæ•´çš„æ•°æ®æ²»ç†ä½“ç³»ï¼ŒåŒ…æ‹¬æ•°æ®è´¨é‡ç®¡ç†ã€ä¸»æ•°æ®ç®¡ç†ã€å…ƒæ•°æ®ç®¡ç†ã€æ•°æ®å®‰å…¨åˆè§„å’Œç”Ÿå‘½å‘¨æœŸç®¡ç†ç­‰æ ¸å¿ƒåŠŸèƒ½ï¼Œç¡®ä¿ä¼ä¸šæ•°æ®èµ„äº§çš„æœ‰æ•ˆç®¡ç†å’Œä»·å€¼æœ€å¤§åŒ–ã€‚
