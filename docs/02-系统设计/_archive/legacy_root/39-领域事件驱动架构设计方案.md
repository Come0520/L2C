# ç½—è±L2Cé”€å”®ç®¡ç†ç³»ç»Ÿ - é¢†åŸŸäº‹ä»¶é©±åŠ¨æ¶æ„è®¾è®¡æ–¹æ¡ˆ

## ğŸ“‹ ç›®å½•
- [è®¾è®¡ç›®æ ‡ä¸ä»·å€¼](#è®¾è®¡ç›®æ ‡ä¸ä»·å€¼)
- [äº‹ä»¶é©±åŠ¨æ¶æ„æ¦‚è¿°](#äº‹ä»¶é©±åŠ¨æ¶æ„æ¦‚è¿°)
- [é¢†åŸŸäº‹ä»¶è®¾è®¡](#é¢†åŸŸäº‹ä»¶è®¾è®¡)
- [äº‹ä»¶å‘å¸ƒè®¢é˜…æœºåˆ¶](#äº‹ä»¶å‘å¸ƒè®¢é˜…æœºåˆ¶)
- [äº‹ä»¶å¤„ç†å™¨è®¾è®¡](#äº‹ä»¶å¤„ç†å™¨è®¾è®¡)
- [äº‹ä»¶å­˜å‚¨å’Œé‡æ”¾](#äº‹ä»¶å­˜å‚¨å’Œé‡æ”¾)
- [ç›‘æ§å’Œè¿ç»´](#ç›‘æ§å’Œè¿ç»´)

---

## ğŸ¯ è®¾è®¡ç›®æ ‡ä¸ä»·å€¼

### 1. è®¾è®¡ç›®æ ‡
- **è§£è€¦ä¸šåŠ¡æ¨¡å—**ï¼šé€šè¿‡äº‹ä»¶æœºåˆ¶å®ç°æ¨¡å—é—´çš„æ¾è€¦åˆ
- **æå‡ç³»ç»Ÿæ‰©å±•æ€§**ï¼šæ”¯æŒæ–°åŠŸèƒ½çš„å¿«é€Ÿæ¥å…¥å’Œæ‰©å±•
- **ä¿è¯æ•°æ®ä¸€è‡´æ€§**ï¼šé€šè¿‡äº‹ä»¶ç¡®ä¿è·¨æ¨¡å—æ•°æ®çš„æœ€ç»ˆä¸€è‡´æ€§
- **å¢å¼ºç³»ç»Ÿå¯è§‚æµ‹æ€§**ï¼šé€šè¿‡äº‹ä»¶æµè¿½è¸ªä¸šåŠ¡æµç¨‹
- **æ”¯æŒå¼‚æ­¥å¤„ç†**ï¼šæå‡ç³»ç»Ÿæ€§èƒ½å’Œç”¨æˆ·ä½“éªŒ

### 2. ä¸šåŠ¡ä»·å€¼
- **ä¸šåŠ¡æµç¨‹é€æ˜åŒ–**ï¼šå®Œæ•´è®°å½•ä¸šåŠ¡äº‹ä»¶æµè½¬è¿‡ç¨‹
- **å¿«é€Ÿå“åº”å˜åŒ–**ï¼šæ”¯æŒä¸šåŠ¡è§„åˆ™çš„çµæ´»è°ƒæ•´
- **æå‡ç”¨æˆ·ä½“éªŒ**ï¼šå¼‚æ­¥å¤„ç†æå‡ç³»ç»Ÿå“åº”é€Ÿåº¦
- **é™ä½ç»´æŠ¤æˆæœ¬**ï¼šæ¨¡å—è§£è€¦é™ä½ç³»ç»Ÿå¤æ‚åº¦

---

## ğŸ—ï¸ äº‹ä»¶é©±åŠ¨æ¶æ„æ¦‚è¿°

### 1. æ¶æ„æ€»è§ˆ

```mermaid
graph TB
    subgraph "ä¸šåŠ¡é¢†åŸŸå±‚"
        A[çº¿ç´¢ç®¡ç†] --> E[äº‹ä»¶æ€»çº¿]
        B[è®¢å•ç®¡ç†] --> E
        C[å®¢æˆ·ç®¡ç†] --> E
        D[ç§¯åˆ†ç³»ç»Ÿ] --> E
    end
    
    subgraph "äº‹ä»¶åŸºç¡€è®¾æ–½"
        E --> F[äº‹ä»¶å­˜å‚¨]
        E --> G[äº‹ä»¶åˆ†å‘å™¨]
        G --> H[äº‹ä»¶å¤„ç†å™¨1]
        G --> I[äº‹ä»¶å¤„ç†å™¨2]
        G --> J[äº‹ä»¶å¤„ç†å™¨N]
    end
    
    subgraph "å¤–éƒ¨ç³»ç»Ÿ"
        H --> K[é€šçŸ¥ç³»ç»Ÿ]
        I --> L[æ•°æ®åˆ†æ]
        J --> M[ç¬¬ä¸‰æ–¹é›†æˆ]
    end
```

### 2. æ ¸å¿ƒç»„ä»¶

#### 2.1 äº‹ä»¶æ€»çº¿ (Event Bus)
```typescript
// äº‹ä»¶æ€»çº¿æ¥å£
// src/infrastructure/events/event-bus.interface.ts

export interface IEventBus {
  publish<T extends DomainEvent>(event: T): Promise<void>;
  publishAll(events: DomainEvent[]): Promise<void>;
  subscribe<T extends DomainEvent>(
    eventType: string,
    handler: EventHandler<T>
  ): void;
  unsubscribe(eventType: string, handlerId: string): void;
}

// äº‹ä»¶æ€»çº¿å®ç°
// src/infrastructure/events/event-bus.service.ts

@Injectable()
export class EventBusService implements IEventBus {
  private handlers = new Map<string, EventHandler[]>();
  private eventStore: IEventStore;
  private logger: Logger;

  constructor(
    @Inject('EVENT_STORE') eventStore: IEventStore,
    logger: Logger
  ) {
    this.eventStore = eventStore;
    this.logger = logger;
  }

  async publish<T extends DomainEvent>(event: T): Promise<void> {
    try {
      // 1. æŒä¹…åŒ–äº‹ä»¶
      await this.eventStore.save(event);
      
      // 2. åˆ†å‘äº‹ä»¶
      await this.dispatch(event);
      
      this.logger.log(`Event published: ${event.eventType}`, {
        eventId: event.eventId,
        aggregateId: event.aggregateId,
        eventType: event.eventType,
      });
    } catch (error) {
      this.logger.error(`Failed to publish event: ${event.eventType}`, error);
      throw error;
    }
  }

  async publishAll(events: DomainEvent[]): Promise<void> {
    // æ‰¹é‡å‘å¸ƒäº‹ä»¶ï¼Œä¿è¯åŸå­æ€§
    const transaction = await this.eventStore.beginTransaction();
    
    try {
      for (const event of events) {
        await this.eventStore.save(event, transaction);
      }
      
      await transaction.commit();
      
      // äº‹åŠ¡æäº¤æˆåŠŸååˆ†å‘äº‹ä»¶
      for (const event of events) {
        await this.dispatch(event);
      }
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }

  subscribe<T extends DomainEvent>(
    eventType: string,
    handler: EventHandler<T>
  ): void {
    if (!this.handlers.has(eventType)) {
      this.handlers.set(eventType, []);
    }
    
    this.handlers.get(eventType)!.push(handler);
    
    this.logger.log(`Handler subscribed to event: ${eventType}`, {
      handlerId: handler.id,
      eventType,
    });
  }

  unsubscribe(eventType: string, handlerId: string): void {
    const handlers = this.handlers.get(eventType);
    if (handlers) {
      const index = handlers.findIndex(h => h.id === handlerId);
      if (index !== -1) {
        handlers.splice(index, 1);
        this.logger.log(`Handler unsubscribed from event: ${eventType}`, {
          handlerId,
          eventType,
        });
      }
    }
  }

  private async dispatch<T extends DomainEvent>(event: T): Promise<void> {
    const handlers = this.handlers.get(event.eventType) || [];
    
    // å¹¶è¡Œå¤„ç†æ‰€æœ‰å¤„ç†å™¨
    const promises = handlers.map(async (handler) => {
      try {
        await handler.handle(event);
        this.logger.log(`Event handled successfully`, {
          eventId: event.eventId,
          handlerId: handler.id,
          eventType: event.eventType,
        });
      } catch (error) {
        this.logger.error(`Event handler failed`, {
          eventId: event.eventId,
          handlerId: handler.id,
          eventType: event.eventType,
          error: error.message,
        });
        
        // è®°å½•å¤±è´¥äº‹ä»¶ï¼Œç”¨äºé‡è¯•
        await this.recordFailedEvent(event, handler.id, error);
      }
    });
    
    await Promise.allSettled(promises);
  }

  private async recordFailedEvent(
    event: DomainEvent,
    handlerId: string,
    error: Error
  ): Promise<void> {
    const failedEvent: FailedEvent = {
      id: generateId(),
      eventId: event.eventId,
      handlerId,
      eventType: event.eventType,
      eventData: event,
      error: error.message,
      failedAt: new Date(),
      retryCount: 0,
      maxRetries: 3,
    };
    
    await this.eventStore.saveFailedEvent(failedEvent);
  }
}
```

---

## ğŸ“ é¢†åŸŸäº‹ä»¶è®¾è®¡

### 1. äº‹ä»¶åŸºç±»è®¾è®¡

```typescript
// é¢†åŸŸäº‹ä»¶åŸºç±»
// src/domain/events/domain-event.base.ts

export abstract class DomainEvent {
  public readonly eventId: string;
  public readonly eventType: string;
  public readonly aggregateId: string;
  public readonly aggregateType: string;
  public readonly occurredOn: Date;
  public readonly version: number;
  public readonly metadata: EventMetadata;

  constructor(
    aggregateId: string,
    aggregateType: string,
    eventData: any,
    metadata: Partial<EventMetadata> = {}
  ) {
    this.eventId = generateId();
    this.eventType = this.constructor.name;
    this.aggregateId = aggregateId;
    this.aggregateType = aggregateType;
    this.occurredOn = new Date();
    this.version = 1;
    this.metadata = {
      userId: metadata.userId,
      correlationId: metadata.correlationId || generateId(),
      causationId: metadata.causationId,
      source: metadata.source || 'system',
      ...metadata,
    };
  }

  abstract getEventData(): any;
}

// äº‹ä»¶å…ƒæ•°æ®
export interface EventMetadata {
  userId?: string;
  correlationId: string;
  causationId?: string;
  source: string;
  traceId?: string;
  sessionId?: string;
  ipAddress?: string;
  userAgent?: string;
}
```

### 2. å…·ä½“ä¸šåŠ¡äº‹ä»¶

#### 2.1 çº¿ç´¢ç®¡ç†äº‹ä»¶
```typescript
// çº¿ç´¢ç›¸å…³äº‹ä»¶
// src/domain/leads/events/lead.events.ts

export class LeadCreatedEvent extends DomainEvent {
  constructor(
    leadId: string,
    private readonly leadData: {
      customerId: string;
      customerName: string;
      phone: string;
      email?: string;
      source: string;
      assignedTo?: string;
      priority: string;
      estimatedValue?: number;
    },
    metadata?: Partial<EventMetadata>
  ) {
    super(leadId, 'Lead', leadData, metadata);
  }

  getEventData() {
    return {
      leadId: this.aggregateId,
      customerId: this.leadData.customerId,
      customerName: this.leadData.customerName,
      phone: this.leadData.phone,
      email: this.leadData.email,
      source: this.leadData.source,
      assignedTo: this.leadData.assignedTo,
      priority: this.leadData.priority,
      estimatedValue: this.leadData.estimatedValue,
    };
  }
}

export class LeadAssignedEvent extends DomainEvent {
  constructor(
    leadId: string,
    private readonly assignmentData: {
      assignedTo: string;
      assignedBy: string;
      previousAssignee?: string;
      reason?: string;
    },
    metadata?: Partial<EventMetadata>
  ) {
    super(leadId, 'Lead', assignmentData, metadata);
  }

  getEventData() {
    return {
      leadId: this.aggregateId,
      assignedTo: this.assignmentData.assignedTo,
      assignedBy: this.assignmentData.assignedBy,
      previousAssignee: this.assignmentData.previousAssignee,
      reason: this.assignmentData.reason,
    };
  }
}

export class LeadStatusChangedEvent extends DomainEvent {
  constructor(
    leadId: string,
    private readonly statusData: {
      fromStatus: string;
      toStatus: string;
      changedBy: string;
      reason?: string;
    },
    metadata?: Partial<EventMetadata>
  ) {
    super(leadId, 'Lead', statusData, metadata);
  }

  getEventData() {
    return {
      leadId: this.aggregateId,
      fromStatus: this.statusData.fromStatus,
      toStatus: this.statusData.toStatus,
      changedBy: this.statusData.changedBy,
      reason: this.statusData.reason,
    };
  }
}

export class LeadConvertedToOrderEvent extends DomainEvent {
  constructor(
    leadId: string,
    private readonly conversionData: {
      orderId: string;
      convertedBy: string;
      conversionValue: number;
      conversionRate?: number;
    },
    metadata?: Partial<EventMetadata>
  ) {
    super(leadId, 'Lead', conversionData, metadata);
  }

  getEventData() {
    return {
      leadId: this.aggregateId,
      orderId: this.conversionData.orderId,
      convertedBy: this.conversionData.convertedBy,
      conversionValue: this.conversionData.conversionValue,
      conversionRate: this.conversionData.conversionRate,
    };
  }
}
```

#### 2.2 è®¢å•ç®¡ç†äº‹ä»¶
```typescript
// è®¢å•ç›¸å…³äº‹ä»¶
// src/domain/orders/events/order.events.ts

export class OrderCreatedEvent extends DomainEvent {
  constructor(
    orderId: string,
    private readonly orderData: {
      customerId: string;
      leadId?: string;
      salesPersonId: string;
      totalAmount: number;
      items: OrderItem[];
      deliveryAddress: Address;
    },
    metadata?: Partial<EventMetadata>
  ) {
    super(orderId, 'Order', orderData, metadata);
  }

  getEventData() {
    return {
      orderId: this.aggregateId,
      customerId: this.orderData.customerId,
      leadId: this.orderData.leadId,
      salesPersonId: this.orderData.salesPersonId,
      totalAmount: this.orderData.totalAmount,
      itemCount: this.orderData.items.length,
      deliveryAddress: this.orderData.deliveryAddress,
    };
  }
}

export class OrderStatusChangedEvent extends DomainEvent {
  constructor(
    orderId: string,
    private readonly statusData: {
      fromStatus: string;
      toStatus: string;
      changedBy: string;
      reason?: string;
      estimatedDeliveryDate?: Date;
    },
    metadata?: Partial<EventMetadata>
  ) {
    super(orderId, 'Order', statusData, metadata);
  }

  getEventData() {
    return {
      orderId: this.aggregateId,
      fromStatus: this.statusData.fromStatus,
      toStatus: this.statusData.toStatus,
      changedBy: this.statusData.changedBy,
      reason: this.statusData.reason,
      estimatedDeliveryDate: this.statusData.estimatedDeliveryDate,
    };
  }
}

export class OrderPaymentReceivedEvent extends DomainEvent {
  constructor(
    orderId: string,
    private readonly paymentData: {
      paymentId: string;
      amount: number;
      paymentMethod: string;
      paidBy: string;
      remainingAmount: number;
    },
    metadata?: Partial<EventMetadata>
  ) {
    super(orderId, 'Order', paymentData, metadata);
  }

  getEventData() {
    return {
      orderId: this.aggregateId,
      paymentId: this.paymentData.paymentId,
      amount: this.paymentData.amount,
      paymentMethod: this.paymentData.paymentMethod,
      paidBy: this.paymentData.paidBy,
      remainingAmount: this.paymentData.remainingAmount,
    };
  }
}
```

#### 2.3 å®¢æˆ·ç®¡ç†äº‹ä»¶
```typescript
// å®¢æˆ·ç›¸å…³äº‹ä»¶
// src/domain/customers/events/customer.events.ts

export class CustomerCreatedEvent extends DomainEvent {
  constructor(
    customerId: string,
    private readonly customerData: {
      name: string;
      phone: string;
      email?: string;
      address?: Address;
      source: string;
      tags?: string[];
    },
    metadata?: Partial<EventMetadata>
  ) {
    super(customerId, 'Customer', customerData, metadata);
  }

  getEventData() {
    return {
      customerId: this.aggregateId,
      name: this.customerData.name,
      phone: this.customerData.phone,
      email: this.customerData.email,
      address: this.customerData.address,
      source: this.customerData.source,
      tags: this.customerData.tags,
    };
  }
}

export class CustomerUpdatedEvent extends DomainEvent {
  constructor(
    customerId: string,
    private readonly updateData: {
      updatedFields: string[];
      updatedBy: string;
      previousData: any;
      newData: any;
    },
    metadata?: Partial<EventMetadata>
  ) {
    super(customerId, 'Customer', updateData, metadata);
  }

  getEventData() {
    return {
      customerId: this.aggregateId,
      updatedFields: this.updateData.updatedFields,
      updatedBy: this.updateData.updatedBy,
      changes: this.calculateChanges(),
    };
  }

  private calculateChanges() {
    const changes: any = {};
    for (const field of this.updateData.updatedFields) {
      changes[field] = {
        from: this.updateData.previousData[field],
        to: this.updateData.newData[field],
      };
    }
    return changes;
  }
}
```

---

## ğŸ”„ äº‹ä»¶å‘å¸ƒè®¢é˜…æœºåˆ¶

### 1. äº‹ä»¶å¤„ç†å™¨åŸºç±»

```typescript
// äº‹ä»¶å¤„ç†å™¨åŸºç±»
// src/infrastructure/events/event-handler.base.ts

export abstract class EventHandler<T extends DomainEvent = DomainEvent> {
  public readonly id: string;
  public readonly eventType: string;
  protected readonly logger: Logger;

  constructor(eventType: string, logger: Logger) {
    this.id = generateId();
    this.eventType = eventType;
    this.logger = logger;
  }

  abstract handle(event: T): Promise<void>;

  protected async withRetry<R>(
    operation: () => Promise<R>,
    maxRetries: number = 3,
    delay: number = 1000
  ): Promise<R> {
    let lastError: Error;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        
        if (attempt === maxRetries) {
          break;
        }
        
        this.logger.warn(`Attempt ${attempt} failed, retrying in ${delay}ms`, {
          error: error.message,
          attempt,
          maxRetries,
        });
        
        await this.sleep(delay * attempt); // æŒ‡æ•°é€€é¿
      }
    }
    
    throw lastError!;
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### 2. å…·ä½“äº‹ä»¶å¤„ç†å™¨

#### 2.1 é€šçŸ¥å¤„ç†å™¨
```typescript
// é€šçŸ¥äº‹ä»¶å¤„ç†å™¨
// src/application/handlers/notification.handlers.ts

@Injectable()
export class LeadCreatedNotificationHandler extends EventHandler<LeadCreatedEvent> {
  constructor(
    private readonly notificationService: NotificationService,
    private readonly userService: UserService,
    logger: Logger
  ) {
    super('LeadCreatedEvent', logger);
  }

  async handle(event: LeadCreatedEvent): Promise<void> {
    const eventData = event.getEventData();
    
    await this.withRetry(async () => {
      // 1. é€šçŸ¥åˆ†é…çš„é”€å”®äººå‘˜
      if (eventData.assignedTo) {
        const assignee = await this.userService.findById(eventData.assignedTo);
        if (assignee) {
          await this.notificationService.sendNotification({
            userId: assignee.id,
            type: 'lead_assigned',
            title: 'æ–°çº¿ç´¢åˆ†é…',
            message: `æ‚¨æœ‰ä¸€ä¸ªæ–°çš„çº¿ç´¢ï¼š${eventData.customerName}`,
            data: {
              leadId: eventData.leadId,
              customerName: eventData.customerName,
              priority: eventData.priority,
            },
          });
        }
      }

      // 2. é€šçŸ¥é”€å”®ç»ç†
      const managers = await this.userService.findByRole('sales_manager');
      for (const manager of managers) {
        await this.notificationService.sendNotification({
          userId: manager.id,
          type: 'lead_created',
          title: 'æ–°çº¿ç´¢åˆ›å»º',
          message: `æ–°çº¿ç´¢ï¼š${eventData.customerName}ï¼Œæ¥æºï¼š${eventData.source}`,
          data: {
            leadId: eventData.leadId,
            customerName: eventData.customerName,
            source: eventData.source,
            estimatedValue: eventData.estimatedValue,
          },
        });
      }

      this.logger.log('Lead created notifications sent', {
        leadId: eventData.leadId,
        eventId: event.eventId,
      });
    });
  }
}

@Injectable()
export class OrderStatusChangedNotificationHandler extends EventHandler<OrderStatusChangedEvent> {
  constructor(
    private readonly notificationService: NotificationService,
    private readonly customerService: CustomerService,
    logger: Logger
  ) {
    super('OrderStatusChangedEvent', logger);
  }

  async handle(event: OrderStatusChangedEvent): Promise<void> {
    const eventData = event.getEventData();
    
    await this.withRetry(async () => {
      // æ ¹æ®çŠ¶æ€å˜åŒ–å‘é€ä¸åŒé€šçŸ¥
      const notificationConfig = this.getNotificationConfig(
        eventData.fromStatus,
        eventData.toStatus
      );
      
      if (notificationConfig) {
        // é€šçŸ¥å®¢æˆ·
        const order = await this.orderService.findById(eventData.orderId);
        if (order) {
          await this.notificationService.sendCustomerNotification({
            customerId: order.customerId,
            type: notificationConfig.type,
            title: notificationConfig.title,
            message: notificationConfig.message,
            data: {
              orderId: eventData.orderId,
              status: eventData.toStatus,
              estimatedDeliveryDate: eventData.estimatedDeliveryDate,
            },
          });
        }
      }

      this.logger.log('Order status change notification sent', {
        orderId: eventData.orderId,
        fromStatus: eventData.fromStatus,
        toStatus: eventData.toStatus,
        eventId: event.eventId,
      });
    });
  }

  private getNotificationConfig(fromStatus: string, toStatus: string) {
    const configs = {
      'confirmed': {
        type: 'order_confirmed',
        title: 'è®¢å•ç¡®è®¤',
        message: 'æ‚¨çš„è®¢å•å·²ç¡®è®¤ï¼Œæˆ‘ä»¬å°†å°½å¿«å®‰æ’ç”Ÿäº§ã€‚',
      },
      'in_production': {
        type: 'order_production',
        title: 'è®¢å•ç”Ÿäº§ä¸­',
        message: 'æ‚¨çš„è®¢å•æ­£åœ¨ç”Ÿäº§ä¸­ï¼Œè¯·è€å¿ƒç­‰å¾…ã€‚',
      },
      'ready_for_delivery': {
        type: 'order_ready',
        title: 'è®¢å•å‡†å¤‡å‘è´§',
        message: 'æ‚¨çš„è®¢å•å·²å‡†å¤‡å°±ç»ªï¼Œå³å°†å®‰æ’å‘è´§ã€‚',
      },
      'delivered': {
        type: 'order_delivered',
        title: 'è®¢å•å·²é€è¾¾',
        message: 'æ‚¨çš„è®¢å•å·²æˆåŠŸé€è¾¾ï¼Œæ„Ÿè°¢æ‚¨çš„ä¿¡ä»»ï¼',
      },
    };
    
    return configs[toStatus];
  }
}
```

#### 2.2 ç§¯åˆ†å¤„ç†å™¨
```typescript
// ç§¯åˆ†äº‹ä»¶å¤„ç†å™¨
// src/application/handlers/points.handlers.ts

@Injectable()
export class OrderCreatedPointsHandler extends EventHandler<OrderCreatedEvent> {
  constructor(
    private readonly pointsService: PointsService,
    logger: Logger
  ) {
    super('OrderCreatedEvent', logger);
  }

  async handle(event: OrderCreatedEvent): Promise<void> {
    const eventData = event.getEventData();
    
    await this.withRetry(async () => {
      // è®¡ç®—ç§¯åˆ†å¥–åŠ±
      const pointsToAward = this.calculatePoints(eventData.totalAmount);
      
      if (pointsToAward > 0) {
        await this.pointsService.awardPoints({
          customerId: eventData.customerId,
          points: pointsToAward,
          reason: 'order_created',
          referenceId: eventData.orderId,
          referenceType: 'order',
          description: `è®¢å•åˆ›å»ºç§¯åˆ†å¥–åŠ±ï¼Œè®¢å•é‡‘é¢ï¼š${eventData.totalAmount}`,
        });

        this.logger.log('Points awarded for order creation', {
          orderId: eventData.orderId,
          customerId: eventData.customerId,
          pointsAwarded: pointsToAward,
          eventId: event.eventId,
        });
      }
    });
  }

  private calculatePoints(orderAmount: number): number {
    // æ¯100å…ƒå¥–åŠ±1ç§¯åˆ†
    return Math.floor(orderAmount / 100);
  }
}

@Injectable()
export class LeadConvertedPointsHandler extends EventHandler<LeadConvertedToOrderEvent> {
  constructor(
    private readonly pointsService: PointsService,
    private readonly userService: UserService,
    logger: Logger
  ) {
    super('LeadConvertedToOrderEvent', logger);
  }

  async handle(event: LeadConvertedToOrderEvent): Promise<void> {
    const eventData = event.getEventData();
    
    await this.withRetry(async () => {
      // ç»™é”€å”®äººå‘˜å¥–åŠ±ç§¯åˆ†
      const conversionPoints = this.calculateConversionPoints(eventData.conversionValue);
      
      if (conversionPoints > 0) {
        await this.pointsService.awardPoints({
          userId: eventData.convertedBy,
          points: conversionPoints,
          reason: 'lead_conversion',
          referenceId: eventData.leadId,
          referenceType: 'lead',
          description: `çº¿ç´¢è½¬åŒ–ç§¯åˆ†å¥–åŠ±ï¼Œè½¬åŒ–é‡‘é¢ï¼š${eventData.conversionValue}`,
        });

        this.logger.log('Points awarded for lead conversion', {
          leadId: eventData.leadId,
          orderId: eventData.orderId,
          convertedBy: eventData.convertedBy,
          pointsAwarded: conversionPoints,
          eventId: event.eventId,
        });
      }
    });
  }

  private calculateConversionPoints(conversionValue: number): number {
    // æ ¹æ®è½¬åŒ–é‡‘é¢è®¡ç®—ç§¯åˆ†ï¼Œæ¯1000å…ƒå¥–åŠ±10ç§¯åˆ†
    return Math.floor(conversionValue / 1000) * 10;
  }
}
```

---

## ğŸ’¾ äº‹ä»¶å­˜å‚¨å’Œé‡æ”¾

### 1. äº‹ä»¶å­˜å‚¨æ¥å£

```typescript
// äº‹ä»¶å­˜å‚¨æ¥å£
// src/infrastructure/events/event-store.interface.ts

export interface IEventStore {
  save(event: DomainEvent, transaction?: Transaction): Promise<void>;
  saveFailedEvent(failedEvent: FailedEvent): Promise<void>;
  getEvents(aggregateId: string, fromVersion?: number): Promise<DomainEvent[]>;
  getEventsByType(eventType: string, fromDate?: Date, toDate?: Date): Promise<DomainEvent[]>;
  getAllEvents(fromDate?: Date, toDate?: Date, limit?: number): Promise<DomainEvent[]>;
  getFailedEvents(maxRetries?: number): Promise<FailedEvent[]>;
  markFailedEventAsRetried(failedEventId: string): Promise<void>;
  beginTransaction(): Promise<Transaction>;
}

// äº‹ä»¶å­˜å‚¨å®ç°
// src/infrastructure/events/postgresql-event-store.service.ts

@Injectable()
export class PostgreSQLEventStore implements IEventStore {
  constructor(
    private readonly databaseService: DatabaseService,
    private readonly logger: Logger
  ) {}

  async save(event: DomainEvent, transaction?: Transaction): Promise<void> {
    const query = `
      INSERT INTO events (
        event_id, event_type, aggregate_id, aggregate_type,
        event_data, metadata, occurred_on, version
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    `;
    
    const params = [
      event.eventId,
      event.eventType,
      event.aggregateId,
      event.aggregateType,
      JSON.stringify(event.getEventData()),
      JSON.stringify(event.metadata),
      event.occurredOn,
      event.version,
    ];
    
    if (transaction) {
      await transaction.query(query, params);
    } else {
      await this.databaseService.query(query, params);
    }
    
    this.logger.log('Event saved to store', {
      eventId: event.eventId,
      eventType: event.eventType,
      aggregateId: event.aggregateId,
    });
  }

  async saveFailedEvent(failedEvent: FailedEvent): Promise<void> {
    const query = `
      INSERT INTO failed_events (
        id, event_id, handler_id, event_type, event_data,
        error, failed_at, retry_count, max_retries
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    `;
    
    const params = [
      failedEvent.id,
      failedEvent.eventId,
      failedEvent.handlerId,
      failedEvent.eventType,
      JSON.stringify(failedEvent.eventData),
      failedEvent.error,
      failedEvent.failedAt,
      failedEvent.retryCount,
      failedEvent.maxRetries,
    ];
    
    await this.databaseService.query(query, params);
    
    this.logger.warn('Failed event saved', {
      failedEventId: failedEvent.id,
      eventId: failedEvent.eventId,
      handlerId: failedEvent.handlerId,
    });
  }

  async getEvents(aggregateId: string, fromVersion?: number): Promise<DomainEvent[]> {
    let query = `
      SELECT * FROM events 
      WHERE aggregate_id = $1
    `;
    const params: any[] = [aggregateId];
    
    if (fromVersion !== undefined) {
      query += ` AND version >= $2`;
      params.push(fromVersion);
    }
    
    query += ` ORDER BY version ASC`;
    
    const result = await this.databaseService.query(query, params);
    return result.rows.map(row => this.deserializeEvent(row));
  }

  async getEventsByType(
    eventType: string,
    fromDate?: Date,
    toDate?: Date
  ): Promise<DomainEvent[]> {
    let query = `SELECT * FROM events WHERE event_type = $1`;
    const params: any[] = [eventType];
    
    if (fromDate) {
      query += ` AND occurred_on >= $${params.length + 1}`;
      params.push(fromDate);
    }
    
    if (toDate) {
      query += ` AND occurred_on <= $${params.length + 1}`;
      params.push(toDate);
    }
    
    query += ` ORDER BY occurred_on ASC`;
    
    const result = await this.databaseService.query(query, params);
    return result.rows.map(row => this.deserializeEvent(row));
  }

  async getAllEvents(
    fromDate?: Date,
    toDate?: Date,
    limit?: number
  ): Promise<DomainEvent[]> {
    let query = `SELECT * FROM events WHERE 1=1`;
    const params: any[] = [];
    
    if (fromDate) {
      query += ` AND occurred_on >= $${params.length + 1}`;
      params.push(fromDate);
    }
    
    if (toDate) {
      query += ` AND occurred_on <= $${params.length + 1}`;
      params.push(toDate);
    }
    
    query += ` ORDER BY occurred_on ASC`;
    
    if (limit) {
      query += ` LIMIT $${params.length + 1}`;
      params.push(limit);
    }
    
    const result = await this.databaseService.query(query, params);
    return result.rows.map(row => this.deserializeEvent(row));
  }

  async getFailedEvents(maxRetries?: number): Promise<FailedEvent[]> {
    let query = `
      SELECT * FROM failed_events 
      WHERE retry_count < max_retries
    `;
    const params: any[] = [];
    
    if (maxRetries !== undefined) {
      query += ` AND max_retries <= $${params.length + 1}`;
      params.push(maxRetries);
    }
    
    query += ` ORDER BY failed_at ASC`;
    
    const result = await this.databaseService.query(query, params);
    return result.rows.map(row => ({
      id: row.id,
      eventId: row.event_id,
      handlerId: row.handler_id,
      eventType: row.event_type,
      eventData: JSON.parse(row.event_data),
      error: row.error,
      failedAt: row.failed_at,
      retryCount: row.retry_count,
      maxRetries: row.max_retries,
    }));
  }

  async markFailedEventAsRetried(failedEventId: string): Promise<void> {
    const query = `
      UPDATE failed_events 
      SET retry_count = retry_count + 1,
          last_retry_at = CURRENT_TIMESTAMP
      WHERE id = $1
    `;
    
    await this.databaseService.query(query, [failedEventId]);
  }

  async beginTransaction(): Promise<Transaction> {
    return await this.databaseService.beginTransaction();
  }

  private deserializeEvent(row: any): DomainEvent {
    // è¿™é‡Œéœ€è¦æ ¹æ®äº‹ä»¶ç±»å‹ååºåˆ—åŒ–ä¸ºå…·ä½“çš„äº‹ä»¶å¯¹è±¡
    // å¯ä»¥ä½¿ç”¨å·¥å‚æ¨¡å¼æˆ–æ³¨å†Œè¡¨æ¨¡å¼
    const eventData = JSON.parse(row.event_data);
    const metadata = JSON.parse(row.metadata);
    
    // ç®€åŒ–ç¤ºä¾‹ï¼Œå®é™…åº”è¯¥æœ‰å®Œæ•´çš„äº‹ä»¶é‡å»ºé€»è¾‘
    return {
      eventId: row.event_id,
      eventType: row.event_type,
      aggregateId: row.aggregate_id,
      aggregateType: row.aggregate_type,
      occurredOn: row.occurred_on,
      version: row.version,
      metadata,
      getEventData: () => eventData,
    } as DomainEvent;
  }
}
```

### 2. äº‹ä»¶é‡æ”¾æœåŠ¡

```typescript
// äº‹ä»¶é‡æ”¾æœåŠ¡
// src/infrastructure/events/event-replay.service.ts

@Injectable()
export class EventReplayService {
  constructor(
    private readonly eventStore: IEventStore,
    private readonly eventBus: IEventBus,
    private readonly logger: Logger
  ) {}

  async replayEvents(
    fromDate: Date,
    toDate: Date,
    eventTypes?: string[]
  ): Promise<ReplayResult> {
    this.logger.log('Starting event replay', {
      fromDate,
      toDate,
      eventTypes,
    });

    const startTime = Date.now();
    let processedCount = 0;
    let errorCount = 0;
    const errors: ReplayError[] = [];

    try {
      // è·å–éœ€è¦é‡æ”¾çš„äº‹ä»¶
      const events = await this.getEventsForReplay(fromDate, toDate, eventTypes);
      
      this.logger.log(`Found ${events.length} events to replay`);

      // æŒ‰æ—¶é—´é¡ºåºé‡æ”¾äº‹ä»¶
      for (const event of events) {
        try {
          await this.replayEvent(event);
          processedCount++;
          
          if (processedCount % 100 === 0) {
            this.logger.log(`Replayed ${processedCount}/${events.length} events`);
          }
        } catch (error) {
          errorCount++;
          errors.push({
            eventId: event.eventId,
            eventType: event.eventType,
            error: error.message,
          });
          
          this.logger.error(`Failed to replay event ${event.eventId}`, error);
        }
      }

      const duration = Date.now() - startTime;
      
      this.logger.log('Event replay completed', {
        totalEvents: events.length,
        processedCount,
        errorCount,
        duration,
      });

      return {
        totalEvents: events.length,
        processedCount,
        errorCount,
        duration,
        errors,
      };
    } catch (error) {
      this.logger.error('Event replay failed', error);
      throw error;
    }
  }

  async replayFailedEvents(): Promise<ReplayResult> {
    this.logger.log('Starting failed events replay');

    const startTime = Date.now();
    let processedCount = 0;
    let errorCount = 0;
    const errors: ReplayError[] = [];

    try {
      const failedEvents = await this.eventStore.getFailedEvents();
      
      this.logger.log(`Found ${failedEvents.length} failed events to retry`);

      for (const failedEvent of failedEvents) {
        try {
          await this.retryFailedEvent(failedEvent);
          processedCount++;
        } catch (error) {
          errorCount++;
          errors.push({
            eventId: failedEvent.eventId,
            eventType: failedEvent.eventType,
            error: error.message,
          });
          
          // æ ‡è®°é‡è¯•æ¬¡æ•°
          await this.eventStore.markFailedEventAsRetried(failedEvent.id);
        }
      }

      const duration = Date.now() - startTime;
      
      this.logger.log('Failed events replay completed', {
        totalEvents: failedEvents.length,
        processedCount,
        errorCount,
        duration,
      });

      return {
        totalEvents: failedEvents.length,
        processedCount,
        errorCount,
        duration,
        errors,
      };
    } catch (error) {
      this.logger.error('Failed events replay failed', error);
      throw error;
    }
  }

  private async getEventsForReplay(
    fromDate: Date,
    toDate: Date,
    eventTypes?: string[]
  ): Promise<DomainEvent[]> {
    if (eventTypes && eventTypes.length > 0) {
      const allEvents: DomainEvent[] = [];
      
      for (const eventType of eventTypes) {
        const events = await this.eventStore.getEventsByType(eventType, fromDate, toDate);
        allEvents.push(...events);
      }
      
      // æŒ‰æ—¶é—´æ’åº
      return allEvents.sort((a, b) => a.occurredOn.getTime() - b.occurredOn.getTime());
    } else {
      return await this.eventStore.getAllEvents(fromDate, toDate);
    }
  }

  private async replayEvent(event: DomainEvent): Promise<void> {
    // é‡æ–°å‘å¸ƒäº‹ä»¶ï¼Œä½†ä¸ä¿å­˜åˆ°äº‹ä»¶å­˜å‚¨
    await this.eventBus.publish(event);
  }

  private async retryFailedEvent(failedEvent: FailedEvent): Promise<void> {
    // é‡å»ºäº‹ä»¶å¯¹è±¡å¹¶é‡æ–°å‘å¸ƒ
    const event = this.rebuildEvent(failedEvent);
    await this.eventBus.publish(event);
  }

  private rebuildEvent(failedEvent: FailedEvent): DomainEvent {
    // æ ¹æ®å¤±è´¥äº‹ä»¶æ•°æ®é‡å»ºäº‹ä»¶å¯¹è±¡
    // è¿™é‡Œéœ€è¦å®ç°å…·ä½“çš„äº‹ä»¶é‡å»ºé€»è¾‘
    return failedEvent.eventData as DomainEvent;
  }
}

// é‡æ”¾ç»“æœæ¥å£
interface ReplayResult {
  totalEvents: number;
  processedCount: number;
  errorCount: number;
  duration: number;
  errors: ReplayError[];
}

interface ReplayError {
  eventId: string;
  eventType: string;
  error: string;
}

// å¤±è´¥äº‹ä»¶æ¥å£
interface FailedEvent {
  id: string;
  eventId: string;
  handlerId: string;
  eventType: string;
  eventData: any;
  error: string;
  failedAt: Date;
  retryCount: number;
  maxRetries: number;
}
```

è¿™ä¸ªé¢†åŸŸäº‹ä»¶é©±åŠ¨æ¶æ„è®¾è®¡æ–¹æ¡ˆæä¾›äº†å®Œæ•´çš„äº‹ä»¶é©±åŠ¨æœºåˆ¶ï¼ŒåŒ…æ‹¬äº‹ä»¶å®šä¹‰ã€å‘å¸ƒè®¢é˜…ã€å­˜å‚¨é‡æ”¾ç­‰æ ¸å¿ƒåŠŸèƒ½ï¼Œç¡®ä¿ç³»ç»Ÿå„æ¨¡å—é—´çš„æ¾è€¦åˆå’Œé«˜æ‰©å±•æ€§ã€‚
