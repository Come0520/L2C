# ç½—è±L2Cé”€å”®ç®¡ç†ç³»ç»Ÿ - äº‹ä»¶æº¯æºæœºåˆ¶è®¾è®¡æ–¹æ¡ˆ

## ğŸ“‹ ç›®å½•
- [è®¾è®¡ç›®æ ‡ä¸ä»·å€¼](#è®¾è®¡ç›®æ ‡ä¸ä»·å€¼)
- [äº‹ä»¶æº¯æºæ¶æ„æ¦‚è¿°](#äº‹ä»¶æº¯æºæ¶æ„æ¦‚è¿°)
- [èšåˆæ ¹è®¾è®¡](#èšåˆæ ¹è®¾è®¡)
- [äº‹ä»¶å­˜å‚¨è®¾è®¡](#äº‹ä»¶å­˜å‚¨è®¾è®¡)
- [å¿«ç…§æœºåˆ¶](#å¿«ç…§æœºåˆ¶)
- [äº‹ä»¶é‡æ”¾ä¸æŠ•å½±](#äº‹ä»¶é‡æ”¾ä¸æŠ•å½±)
- [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
- [ç›‘æ§å’Œè¿ç»´](#ç›‘æ§å’Œè¿ç»´)

---

## ğŸ¯ è®¾è®¡ç›®æ ‡ä¸ä»·å€¼

### 1. è®¾è®¡ç›®æ ‡
- **å®Œæ•´å®¡è®¡è¿½è¸ª**ï¼šè®°å½•æ‰€æœ‰ä¸šåŠ¡çŠ¶æ€å˜æ›´çš„å®Œæ•´å†å²
- **æ—¶é—´æ—…è¡Œèƒ½åŠ›**ï¼šæ”¯æŒæŸ¥çœ‹ä»»æ„æ—¶é—´ç‚¹çš„ç³»ç»ŸçŠ¶æ€
- **äº‹ä»¶é‡æ”¾**ï¼šæ”¯æŒä»äº‹ä»¶æµé‡å»ºç³»ç»ŸçŠ¶æ€
- **æ•°æ®ä¸€è‡´æ€§**ï¼šé€šè¿‡äº‹ä»¶ç¡®ä¿æ•°æ®çš„å¼ºä¸€è‡´æ€§
- **ä¸šåŠ¡æ´å¯Ÿ**ï¼šé€šè¿‡äº‹ä»¶åˆ†æè·å¾—æ·±åº¦ä¸šåŠ¡æ´å¯Ÿ

### 2. ä¸šåŠ¡ä»·å€¼
- **åˆè§„å®¡è®¡**ï¼šæ»¡è¶³ä¸šåŠ¡åˆè§„å’Œå®¡è®¡è¦æ±‚
- **æ•…éšœæ¢å¤**ï¼šå¿«é€Ÿä»æ•…éšœä¸­æ¢å¤ç³»ç»ŸçŠ¶æ€
- **ä¸šåŠ¡åˆ†æ**ï¼šæ·±å…¥åˆ†æä¸šåŠ¡æµç¨‹å’Œç”¨æˆ·è¡Œä¸º
- **è°ƒè¯•èƒ½åŠ›**ï¼šç²¾ç¡®å®šä½å’Œé‡ç°é—®é¢˜
- **æ•°æ®æŒ–æ˜**ï¼šåŸºäºå®Œæ•´å†å²æ•°æ®è¿›è¡Œåˆ†æ

---

## ğŸ—ï¸ äº‹ä»¶æº¯æºæ¶æ„æ¦‚è¿°

### 1. æ¶æ„æ€»è§ˆ

```mermaid
graph TB
    subgraph "åº”ç”¨å±‚"
        A[å‘½ä»¤å¤„ç†å™¨] --> B[èšåˆæ ¹]
        C[æŸ¥è¯¢å¤„ç†å™¨] --> D[æŠ•å½±]
    end
    
    subgraph "é¢†åŸŸå±‚"
        B --> E[é¢†åŸŸäº‹ä»¶]
        E --> F[äº‹ä»¶æµ]
    end
    
    subgraph "åŸºç¡€è®¾æ–½å±‚"
        F --> G[äº‹ä»¶å­˜å‚¨]
        G --> H[äº‹ä»¶é‡æ”¾å™¨]
        H --> I[æŠ•å½±æ„å»ºå™¨]
        I --> D
        
        G --> J[å¿«ç…§å­˜å‚¨]
        B --> J
    end
    
    subgraph "å­˜å‚¨å±‚"
        G --> K[PostgreSQLäº‹ä»¶è¡¨]
        J --> L[PostgreSQLå¿«ç…§è¡¨]
        D --> M[PostgreSQLè¯»æ¨¡å‹]
        D --> N[Redisç¼“å­˜]
    end
```

### 2. æ ¸å¿ƒæ¦‚å¿µ

#### 2.1 äº‹ä»¶æº¯æºèšåˆæ ¹åŸºç±»
```typescript
// äº‹ä»¶æº¯æºèšåˆæ ¹åŸºç±»
// src/domain/common/event-sourced-aggregate.base.ts

export abstract class EventSourcedAggregate {
  protected id: string;
  protected version: number = 0;
  private uncommittedEvents: DomainEvent[] = [];
  private isReplaying: boolean = false;

  constructor(id?: string) {
    this.id = id || generateId();
  }

  // è·å–èšåˆæ ¹ID
  getId(): string {
    return this.id;
  }

  // è·å–ç‰ˆæœ¬å·
  getVersion(): number {
    return this.version;
  }

  // è·å–æœªæäº¤çš„äº‹ä»¶
  getUncommittedEvents(): DomainEvent[] {
    return [...this.uncommittedEvents];
  }

  // æ ‡è®°äº‹ä»¶ä¸ºå·²æäº¤
  markEventsAsCommitted(): void {
    this.uncommittedEvents = [];
  }

  // ä»äº‹ä»¶æµé‡å»ºèšåˆæ ¹
  static fromHistory<T extends EventSourcedAggregate>(
    aggregateClass: new (id: string) => T,
    events: DomainEvent[]
  ): T {
    if (events.length === 0) {
      throw new Error('Cannot rebuild aggregate from empty event stream');
    }

    const aggregate = new aggregateClass(events[0].aggregateId);
    aggregate.replay(events);
    return aggregate;
  }

  // é‡æ”¾äº‹ä»¶
  private replay(events: DomainEvent[]): void {
    this.isReplaying = true;
    
    for (const event of events) {
      this.applyEvent(event);
      this.version = event.version;
    }
    
    this.isReplaying = false;
  }

  // åº”ç”¨äº‹ä»¶
  protected applyEvent(event: DomainEvent): void {
    const handler = this.getEventHandler(event.eventType);
    if (handler) {
      handler.call(this, event);
    }
  }

  // å‘å¸ƒäº‹ä»¶
  protected publishEvent(event: DomainEvent): void {
    // è®¾ç½®äº‹ä»¶ç‰ˆæœ¬
    event.version = this.version + 1;
    
    // åº”ç”¨äº‹ä»¶åˆ°èšåˆæ ¹
    this.applyEvent(event);
    
    // æ›´æ–°ç‰ˆæœ¬
    this.version = event.version;
    
    // å¦‚æœä¸æ˜¯é‡æ”¾æ¨¡å¼ï¼Œæ·»åŠ åˆ°æœªæäº¤äº‹ä»¶åˆ—è¡¨
    if (!this.isReplaying) {
      this.uncommittedEvents.push(event);
    }
  }

  // è·å–äº‹ä»¶å¤„ç†å™¨
  private getEventHandler(eventType: string): Function | undefined {
    const handlerName = `on${eventType}`;
    return (this as any)[handlerName];
  }

  // åˆ›å»ºå¿«ç…§
  abstract createSnapshot(): AggregateSnapshot;

  // ä»å¿«ç…§æ¢å¤
  abstract restoreFromSnapshot(snapshot: AggregateSnapshot): void;
}

// èšåˆå¿«ç…§æ¥å£
export interface AggregateSnapshot {
  aggregateId: string;
  aggregateType: string;
  version: number;
  data: any;
  createdAt: Date;
}
```

#### 2.2 äº‹ä»¶å­˜å‚¨æ¥å£
```typescript
// äº‹ä»¶å­˜å‚¨æ¥å£
// src/infrastructure/event-sourcing/event-store.interface.ts

export interface IEventStore {
  // ä¿å­˜äº‹ä»¶
  saveEvents(
    aggregateId: string,
    events: DomainEvent[],
    expectedVersion: number
  ): Promise<void>;

  // è·å–äº‹ä»¶æµ
  getEventStream(
    aggregateId: string,
    fromVersion?: number
  ): Promise<DomainEvent[]>;

  // è·å–æ‰€æœ‰äº‹ä»¶
  getAllEvents(
    fromTimestamp?: Date,
    toTimestamp?: Date,
    eventTypes?: string[]
  ): Promise<DomainEvent[]>;

  // ä¿å­˜å¿«ç…§
  saveSnapshot(snapshot: AggregateSnapshot): Promise<void>;

  // è·å–å¿«ç…§
  getSnapshot(aggregateId: string): Promise<AggregateSnapshot | null>;

  // è·å–æœ€æ–°å¿«ç…§
  getLatestSnapshot(
    aggregateId: string,
    beforeVersion?: number
  ): Promise<AggregateSnapshot | null>;
}
```

---

## ğŸ¯ èšåˆæ ¹è®¾è®¡

### 1. çº¿ç´¢èšåˆæ ¹

```typescript
// çº¿ç´¢èšåˆæ ¹
// src/domain/leads/lead.aggregate.ts

export class Lead extends EventSourcedAggregate {
  private customerId: string;
  private status: LeadStatus;
  private priority: LeadPriority;
  private source: string;
  private estimatedValue?: number;
  private assignedTo?: string;
  private createdBy: string;
  private createdAt: Date;
  private updatedAt: Date;
  private notes?: string;
  private tags: string[] = [];
  private followUps: FollowUp[] = [];
  private activities: Activity[] = [];

  constructor(id?: string) {
    super(id);
  }

  // åˆ›å»ºçº¿ç´¢
  static create(
    customerId: string,
    priority: LeadPriority,
    source: string,
    estimatedValue?: number,
    assignedTo?: string,
    createdBy?: string,
    notes?: string
  ): Lead {
    const lead = new Lead();
    
    const event = new LeadCreatedEvent(
      lead.getId(),
      {
        customerId,
        priority,
        source,
        estimatedValue,
        assignedTo,
        createdBy,
        notes,
      }
    );
    
    lead.publishEvent(event);
    return lead;
  }

  // åˆ†é…çº¿ç´¢
  assignTo(assignedTo: string, assignedBy: string, reason?: string): void {
    if (this.status === LeadStatus.CONVERTED) {
      throw new DomainError('Cannot assign converted lead');
    }

    if (this.assignedTo === assignedTo) {
      throw new DomainError('Lead is already assigned to this person');
    }

    const event = new LeadAssignedEvent(
      this.getId(),
      {
        assignedTo,
        assignedBy,
        previousAssignee: this.assignedTo,
        reason,
      }
    );

    this.publishEvent(event);
  }

  // æ›´æ–°çŠ¶æ€
  updateStatus(newStatus: LeadStatus, changedBy: string, reason?: string): void {
    if (this.status === newStatus) {
      throw new DomainError('Lead is already in this status');
    }

    if (this.status === LeadStatus.CONVERTED && newStatus !== LeadStatus.CONVERTED) {
      throw new DomainError('Cannot change status of converted lead');
    }

    const event = new LeadStatusChangedEvent(
      this.getId(),
      {
        fromStatus: this.status,
        toStatus: newStatus,
        changedBy,
        reason,
      }
    );

    this.publishEvent(event);
  }

  // è½¬åŒ–ä¸ºè®¢å•
  convertToOrder(orderId: string, convertedBy: string): void {
    if (this.status === LeadStatus.CONVERTED) {
      throw new DomainError('Lead is already converted');
    }

    const conversionValue = this.estimatedValue || 0;
    
    const event = new LeadConvertedToOrderEvent(
      this.getId(),
      {
        orderId,
        convertedBy,
        conversionValue,
      }
    );

    this.publishEvent(event);
  }

  // æ·»åŠ è·Ÿè¿›è®°å½•
  addFollowUp(content: string, followUpBy: string, nextFollowUpDate?: Date): void {
    const event = new LeadFollowUpAddedEvent(
      this.getId(),
      {
        content,
        followUpBy,
        nextFollowUpDate,
      }
    );

    this.publishEvent(event);
  }

  // äº‹ä»¶å¤„ç†å™¨
  private onLeadCreatedEvent(event: LeadCreatedEvent): void {
    const data = event.getEventData();
    this.customerId = data.customerId;
    this.priority = data.priority;
    this.source = data.source;
    this.estimatedValue = data.estimatedValue;
    this.assignedTo = data.assignedTo;
    this.createdBy = data.createdBy;
    this.notes = data.notes;
    this.status = LeadStatus.NEW;
    this.createdAt = event.occurredOn;
    this.updatedAt = event.occurredOn;
  }

  private onLeadAssignedEvent(event: LeadAssignedEvent): void {
    const data = event.getEventData();
    this.assignedTo = data.assignedTo;
    this.updatedAt = event.occurredOn;
  }

  private onLeadStatusChangedEvent(event: LeadStatusChangedEvent): void {
    const data = event.getEventData();
    this.status = data.toStatus;
    this.updatedAt = event.occurredOn;
  }

  private onLeadConvertedToOrderEvent(event: LeadConvertedToOrderEvent): void {
    this.status = LeadStatus.CONVERTED;
    this.updatedAt = event.occurredOn;
  }

  private onLeadFollowUpAddedEvent(event: LeadFollowUpAddedEvent): void {
    const data = event.getEventData();
    this.followUps.push({
      id: generateId(),
      content: data.content,
      followUpBy: data.followUpBy,
      followUpDate: event.occurredOn,
      nextFollowUpDate: data.nextFollowUpDate,
    });
    this.updatedAt = event.occurredOn;
  }

  // åˆ›å»ºå¿«ç…§
  createSnapshot(): AggregateSnapshot {
    return {
      aggregateId: this.getId(),
      aggregateType: 'Lead',
      version: this.getVersion(),
      data: {
        customerId: this.customerId,
        status: this.status,
        priority: this.priority,
        source: this.source,
        estimatedValue: this.estimatedValue,
        assignedTo: this.assignedTo,
        createdBy: this.createdBy,
        createdAt: this.createdAt,
        updatedAt: this.updatedAt,
        notes: this.notes,
        tags: this.tags,
        followUps: this.followUps,
        activities: this.activities,
      },
      createdAt: new Date(),
    };
  }

  // ä»å¿«ç…§æ¢å¤
  restoreFromSnapshot(snapshot: AggregateSnapshot): void {
    const data = snapshot.data;
    this.customerId = data.customerId;
    this.status = data.status;
    this.priority = data.priority;
    this.source = data.source;
    this.estimatedValue = data.estimatedValue;
    this.assignedTo = data.assignedTo;
    this.createdBy = data.createdBy;
    this.createdAt = data.createdAt;
    this.updatedAt = data.updatedAt;
    this.notes = data.notes;
    this.tags = data.tags || [];
    this.followUps = data.followUps || [];
    this.activities = data.activities || [];
    this.version = snapshot.version;
  }

  // Getters
  getCustomerId(): string { return this.customerId; }
  getStatus(): LeadStatus { return this.status; }
  getPriority(): LeadPriority { return this.priority; }
  getSource(): string { return this.source; }
  getEstimatedValue(): number | undefined { return this.estimatedValue; }
  getAssignedTo(): string | undefined { return this.assignedTo; }
  getCreatedBy(): string { return this.createdBy; }
  getCreatedAt(): Date { return this.createdAt; }
  getUpdatedAt(): Date { return this.updatedAt; }
  getNotes(): string | undefined { return this.notes; }
  getTags(): string[] { return [...this.tags]; }
  getFollowUps(): FollowUp[] { return [...this.followUps]; }
  getActivities(): Activity[] { return [...this.activities]; }
}

// çº¿ç´¢çŠ¶æ€æšä¸¾
export enum LeadStatus {
  NEW = 'new',
  CONTACTED = 'contacted',
  QUALIFIED = 'qualified',
  PROPOSAL = 'proposal',
  NEGOTIATION = 'negotiation',
  CONVERTED = 'converted',
  LOST = 'lost',
}

// çº¿ç´¢ä¼˜å…ˆçº§æšä¸¾
export enum LeadPriority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  URGENT = 'urgent',
}
```

### 2. è®¢å•èšåˆæ ¹

```typescript
// è®¢å•èšåˆæ ¹
// src/domain/orders/order.aggregate.ts

export class Order extends EventSourcedAggregate {
  private orderNumber: string;
  private customerId: string;
  private salesPersonId: string;
  private status: OrderStatus;
  private items: OrderItem[] = [];
  private totalAmount: number;
  private paidAmount: number = 0;
  private deliveryAddress: Address;
  private estimatedDeliveryDate?: Date;
  private actualDeliveryDate?: Date;
  private createdAt: Date;
  private updatedAt: Date;
  private notes?: string;
  private leadId?: string;
  private payments: Payment[] = [];
  private statusHistory: OrderStatusChange[] = [];

  constructor(id?: string) {
    super(id);
  }

  // åˆ›å»ºè®¢å•
  static create(
    customerId: string,
    salesPersonId: string,
    items: OrderItem[],
    deliveryAddress: Address,
    notes?: string,
    leadId?: string
  ): Order {
    const order = new Order();
    const orderNumber = order.generateOrderNumber();
    const totalAmount = items.reduce((sum, item) => sum + item.totalPrice, 0);
    
    const event = new OrderCreatedEvent(
      order.getId(),
      {
        orderNumber,
        customerId,
        salesPersonId,
        items,
        totalAmount,
        deliveryAddress,
        notes,
        leadId,
      }
    );
    
    order.publishEvent(event);
    return order;
  }

  // æ›´æ–°çŠ¶æ€
  updateStatus(
    newStatus: OrderStatus,
    changedBy: string,
    reason?: string,
    estimatedDeliveryDate?: Date
  ): void {
    if (this.status === newStatus) {
      throw new DomainError('Order is already in this status');
    }

    if (this.status === OrderStatus.CANCELLED) {
      throw new DomainError('Cannot change status of cancelled order');
    }

    if (this.status === OrderStatus.DELIVERED && newStatus !== OrderStatus.DELIVERED) {
      throw new DomainError('Cannot change status of delivered order');
    }

    const event = new OrderStatusChangedEvent(
      this.getId(),
      {
        fromStatus: this.status,
        toStatus: newStatus,
        changedBy,
        reason,
        estimatedDeliveryDate,
      }
    );

    this.publishEvent(event);
  }

  // å¤„ç†ä»˜æ¬¾
  processPayment(
    amount: number,
    paymentMethod: string,
    paymentReference: string,
    paidBy: string
  ): void {
    if (amount <= 0) {
      throw new DomainError('Payment amount must be greater than 0');
    }

    if (this.paidAmount + amount > this.totalAmount) {
      throw new DomainError('Payment amount exceeds order total');
    }

    if (this.status === OrderStatus.CANCELLED) {
      throw new DomainError('Cannot process payment for cancelled order');
    }

    const event = new OrderPaymentReceivedEvent(
      this.getId(),
      {
        paymentId: generateId(),
        amount,
        paymentMethod,
        paymentReference,
        paidBy,
        remainingAmount: this.totalAmount - (this.paidAmount + amount),
      }
    );

    this.publishEvent(event);
  }

  // å–æ¶ˆè®¢å•
  cancel(cancelledBy: string, reason: string): void {
    if (this.status === OrderStatus.CANCELLED) {
      throw new DomainError('Order is already cancelled');
    }

    if (this.status === OrderStatus.DELIVERED) {
      throw new DomainError('Cannot cancel delivered order');
    }

    if (this.status === OrderStatus.IN_PRODUCTION) {
      throw new DomainError('Cannot cancel order that is in production');
    }

    const event = new OrderCancelledEvent(
      this.getId(),
      {
        cancelledBy,
        reason,
        refundAmount: this.paidAmount,
      }
    );

    this.publishEvent(event);
  }

  // æ·»åŠ è®¢å•é¡¹
  addItem(item: OrderItem, addedBy: string): void {
    if (this.status !== OrderStatus.PENDING) {
      throw new DomainError('Can only add items to pending orders');
    }

    const event = new OrderItemAddedEvent(
      this.getId(),
      {
        item,
        addedBy,
        newTotalAmount: this.totalAmount + item.totalPrice,
      }
    );

    this.publishEvent(event);
  }

  // ç§»é™¤è®¢å•é¡¹
  removeItem(itemId: string, removedBy: string): void {
    if (this.status !== OrderStatus.PENDING) {
      throw new DomainError('Can only remove items from pending orders');
    }

    const item = this.items.find(i => i.id === itemId);
    if (!item) {
      throw new DomainError('Item not found in order');
    }

    const event = new OrderItemRemovedEvent(
      this.getId(),
      {
        itemId,
        removedBy,
        newTotalAmount: this.totalAmount - item.totalPrice,
      }
    );

    this.publishEvent(event);
  }

  // äº‹ä»¶å¤„ç†å™¨
  private onOrderCreatedEvent(event: OrderCreatedEvent): void {
    const data = event.getEventData();
    this.orderNumber = data.orderNumber;
    this.customerId = data.customerId;
    this.salesPersonId = data.salesPersonId;
    this.items = data.items;
    this.totalAmount = data.totalAmount;
    this.deliveryAddress = data.deliveryAddress;
    this.notes = data.notes;
    this.leadId = data.leadId;
    this.status = OrderStatus.PENDING;
    this.createdAt = event.occurredOn;
    this.updatedAt = event.occurredOn;
  }

  private onOrderStatusChangedEvent(event: OrderStatusChangedEvent): void {
    const data = event.getEventData();
    this.status = data.toStatus;
    this.estimatedDeliveryDate = data.estimatedDeliveryDate;
    this.updatedAt = event.occurredOn;
    
    this.statusHistory.push({
      fromStatus: data.fromStatus,
      toStatus: data.toStatus,
      changedBy: data.changedBy,
      changedAt: event.occurredOn,
      reason: data.reason,
    });

    if (data.toStatus === OrderStatus.DELIVERED) {
      this.actualDeliveryDate = event.occurredOn;
    }
  }

  private onOrderPaymentReceivedEvent(event: OrderPaymentReceivedEvent): void {
    const data = event.getEventData();
    this.paidAmount += data.amount;
    this.updatedAt = event.occurredOn;
    
    this.payments.push({
      id: data.paymentId,
      amount: data.amount,
      paymentMethod: data.paymentMethod,
      paymentReference: data.paymentReference,
      paidBy: data.paidBy,
      paidAt: event.occurredOn,
    });
  }

  private onOrderCancelledEvent(event: OrderCancelledEvent): void {
    this.status = OrderStatus.CANCELLED;
    this.updatedAt = event.occurredOn;
  }

  private onOrderItemAddedEvent(event: OrderItemAddedEvent): void {
    const data = event.getEventData();
    this.items.push(data.item);
    this.totalAmount = data.newTotalAmount;
    this.updatedAt = event.occurredOn;
  }

  private onOrderItemRemovedEvent(event: OrderItemRemovedEvent): void {
    const data = event.getEventData();
    this.items = this.items.filter(item => item.id !== data.itemId);
    this.totalAmount = data.newTotalAmount;
    this.updatedAt = event.occurredOn;
  }

  // ç”Ÿæˆè®¢å•å·
  private generateOrderNumber(): string {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const random = Math.random().toString(36).substr(2, 6).toUpperCase();
    return `ORD${year}${month}${day}${random}`;
  }

  // åˆ›å»ºå¿«ç…§
  createSnapshot(): AggregateSnapshot {
    return {
      aggregateId: this.getId(),
      aggregateType: 'Order',
      version: this.getVersion(),
      data: {
        orderNumber: this.orderNumber,
        customerId: this.customerId,
        salesPersonId: this.salesPersonId,
        status: this.status,
        items: this.items,
        totalAmount: this.totalAmount,
        paidAmount: this.paidAmount,
        deliveryAddress: this.deliveryAddress,
        estimatedDeliveryDate: this.estimatedDeliveryDate,
        actualDeliveryDate: this.actualDeliveryDate,
        createdAt: this.createdAt,
        updatedAt: this.updatedAt,
        notes: this.notes,
        leadId: this.leadId,
        payments: this.payments,
        statusHistory: this.statusHistory,
      },
      createdAt: new Date(),
    };
  }

  // ä»å¿«ç…§æ¢å¤
  restoreFromSnapshot(snapshot: AggregateSnapshot): void {
    const data = snapshot.data;
    this.orderNumber = data.orderNumber;
    this.customerId = data.customerId;
    this.salesPersonId = data.salesPersonId;
    this.status = data.status;
    this.items = data.items;
    this.totalAmount = data.totalAmount;
    this.paidAmount = data.paidAmount;
    this.deliveryAddress = data.deliveryAddress;
    this.estimatedDeliveryDate = data.estimatedDeliveryDate;
    this.actualDeliveryDate = data.actualDeliveryDate;
    this.createdAt = data.createdAt;
    this.updatedAt = data.updatedAt;
    this.notes = data.notes;
    this.leadId = data.leadId;
    this.payments = data.payments || [];
    this.statusHistory = data.statusHistory || [];
    this.version = snapshot.version;
  }

  // Getters
  getOrderNumber(): string { return this.orderNumber; }
  getCustomerId(): string { return this.customerId; }
  getSalesPersonId(): string { return this.salesPersonId; }
  getStatus(): OrderStatus { return this.status; }
  getItems(): OrderItem[] { return [...this.items]; }
  getTotalAmount(): number { return this.totalAmount; }
  getPaidAmount(): number { return this.paidAmount; }
  getRemainingAmount(): number { return this.totalAmount - this.paidAmount; }
  getDeliveryAddress(): Address { return this.deliveryAddress; }
  getEstimatedDeliveryDate(): Date | undefined { return this.estimatedDeliveryDate; }
  getActualDeliveryDate(): Date | undefined { return this.actualDeliveryDate; }
  getCreatedAt(): Date { return this.createdAt; }
  getUpdatedAt(): Date { return this.updatedAt; }
  getNotes(): string | undefined { return this.notes; }
  getLeadId(): string | undefined { return this.leadId; }
  getPayments(): Payment[] { return [...this.payments]; }
  getStatusHistory(): OrderStatusChange[] { return [...this.statusHistory]; }
}

// è®¢å•çŠ¶æ€æšä¸¾
export enum OrderStatus {
  PENDING = 'pending',
  CONFIRMED = 'confirmed',
  IN_PRODUCTION = 'in_production',
  READY_FOR_DELIVERY = 'ready_for_delivery',
  DELIVERED = 'delivered',
  CANCELLED = 'cancelled',
}
```

---

## ğŸ’¾ äº‹ä»¶å­˜å‚¨è®¾è®¡

### 1. PostgreSQLäº‹ä»¶å­˜å‚¨å®ç°

```typescript
// PostgreSQLäº‹ä»¶å­˜å‚¨å®ç°
// src/infrastructure/event-sourcing/postgresql-event-store.service.ts

@Injectable()
export class PostgreSQLEventStore implements IEventStore {
  constructor(
    private readonly databaseService: DatabaseService,
    private readonly logger: Logger
  ) {}

  async saveEvents(
    aggregateId: string,
    events: DomainEvent[],
    expectedVersion: number
  ): Promise<void> {
    if (events.length === 0) {
      return;
    }

    const client = await this.databaseService.getClient();
    
    try {
      await client.query('BEGIN');

      // æ£€æŸ¥ç‰ˆæœ¬å†²çª
      await this.checkVersionConflict(client, aggregateId, expectedVersion);

      // ä¿å­˜äº‹ä»¶
      for (const event of events) {
        await this.saveEvent(client, event);
      }

      await client.query('COMMIT');

      this.logger.log('Events saved successfully', {
        aggregateId,
        eventCount: events.length,
        expectedVersion,
      });
    } catch (error) {
      await client.query('ROLLBACK');
      
      if (error.message.includes('version_conflict')) {
        throw new ConcurrencyError(
          `Concurrency conflict for aggregate ${aggregateId}. Expected version: ${expectedVersion}`
        );
      }
      
      this.logger.error('Failed to save events', {
        aggregateId,
        error: error.message,
      });
      
      throw error;
    } finally {
      client.release();
    }
  }

  async getEventStream(
    aggregateId: string,
    fromVersion?: number
  ): Promise<DomainEvent[]> {
    let query = `
      SELECT * FROM events 
      WHERE aggregate_id = $1
    `;
    const params: any[] = [aggregateId];

    if (fromVersion !== undefined) {
      query += ` AND version > $2`;
      params.push(fromVersion);
    }

    query += ` ORDER BY version ASC`;

    const result = await this.databaseService.query(query, params);
    
    return result.rows.map(row => this.deserializeEvent(row));
  }

  async getAllEvents(
    fromTimestamp?: Date,
    toTimestamp?: Date,
    eventTypes?: string[]
  ): Promise<DomainEvent[]> {
    let query = `SELECT * FROM events WHERE 1=1`;
    const params: any[] = [];

    if (fromTimestamp) {
      query += ` AND occurred_on >= $${params.length + 1}`;
      params.push(fromTimestamp);
    }

    if (toTimestamp) {
      query += ` AND occurred_on <= $${params.length + 1}`;
      params.push(toTimestamp);
    }

    if (eventTypes && eventTypes.length > 0) {
      query += ` AND event_type = ANY($${params.length + 1})`;
      params.push(eventTypes);
    }

    query += ` ORDER BY occurred_on ASC, version ASC`;

    const result = await this.databaseService.query(query, params);
    
    return result.rows.map(row => this.deserializeEvent(row));
  }

  async saveSnapshot(snapshot: AggregateSnapshot): Promise<void> {
    const query = `
      INSERT INTO snapshots (
        aggregate_id, aggregate_type, version, data, created_at
      ) VALUES ($1, $2, $3, $4, $5)
      ON CONFLICT (aggregate_id) 
      DO UPDATE SET 
        version = EXCLUDED.version,
        data = EXCLUDED.data,
        created_at = EXCLUDED.created_at
      WHERE snapshots.version < EXCLUDED.version
    `;

    const params = [
      snapshot.aggregateId,
      snapshot.aggregateType,
      snapshot.version,
      JSON.stringify(snapshot.data),
      snapshot.createdAt,
    ];

    await this.databaseService.query(query, params);

    this.logger.log('Snapshot saved', {
      aggregateId: snapshot.aggregateId,
      version: snapshot.version,
    });
  }

  async getSnapshot(aggregateId: string): Promise<AggregateSnapshot | null> {
    const query = `
      SELECT * FROM snapshots 
      WHERE aggregate_id = $1
    `;

    const result = await this.databaseService.query(query, [aggregateId]);
    
    if (result.rows.length === 0) {
      return null;
    }

    const row = result.rows[0];
    return {
      aggregateId: row.aggregate_id,
      aggregateType: row.aggregate_type,
      version: row.version,
      data: JSON.parse(row.data),
      createdAt: row.created_at,
    };
  }

  async getLatestSnapshot(
    aggregateId: string,
    beforeVersion?: number
  ): Promise<AggregateSnapshot | null> {
    let query = `
      SELECT * FROM snapshots 
      WHERE aggregate_id = $1
    `;
    const params: any[] = [aggregateId];

    if (beforeVersion !== undefined) {
      query += ` AND version < $2`;
      params.push(beforeVersion);
    }

    query += ` ORDER BY version DESC LIMIT 1`;

    const result = await this.databaseService.query(query, params);
    
    if (result.rows.length === 0) {
      return null;
    }

    const row = result.rows[0];
    return {
      aggregateId: row.aggregate_id,
      aggregateType: row.aggregate_type,
      version: row.version,
      data: JSON.parse(row.data),
      createdAt: row.created_at,
    };
  }

  private async checkVersionConflict(
    client: any,
    aggregateId: string,
    expectedVersion: number
  ): Promise<void> {
    const query = `
      SELECT MAX(version) as current_version 
      FROM events 
      WHERE aggregate_id = $1
    `;

    const result = await client.query(query, [aggregateId]);
    const currentVersion = result.rows[0]?.current_version || 0;

    if (currentVersion !== expectedVersion) {
      throw new Error('version_conflict');
    }
  }

  private async saveEvent(client: any, event: DomainEvent): Promise<void> {
    const query = `
      INSERT INTO events (
        event_id, event_type, aggregate_id, aggregate_type,
        version, event_data, metadata, occurred_on
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    `;

    const params = [
      event.eventId,
      event.eventType,
      event.aggregateId,
      event.aggregateType,
      event.version,
      JSON.stringify(event.getEventData()),
      JSON.stringify(event.metadata),
      event.occurredOn,
    ];

    await client.query(query, params);
  }

  private deserializeEvent(row: any): DomainEvent {
    // è¿™é‡Œéœ€è¦æ ¹æ®äº‹ä»¶ç±»å‹ååºåˆ—åŒ–ä¸ºå…·ä½“çš„äº‹ä»¶å¯¹è±¡
    // å¯ä»¥ä½¿ç”¨äº‹ä»¶å·¥å‚æˆ–æ³¨å†Œè¡¨æ¨¡å¼
    const eventData = JSON.parse(row.event_data);
    const metadata = JSON.parse(row.metadata);

    // ç®€åŒ–ç¤ºä¾‹ï¼Œå®é™…åº”è¯¥æœ‰å®Œæ•´çš„äº‹ä»¶é‡å»ºé€»è¾‘
    return {
      eventId: row.event_id,
      eventType: row.event_type,
      aggregateId: row.aggregate_id,
      aggregateType: row.aggregate_type,
      version: row.version,
      occurredOn: row.occurred_on,
      metadata,
      getEventData: () => eventData,
    } as DomainEvent;
  }
}
```

### 2. æ•°æ®åº“è¡¨ç»“æ„

```sql
-- äº‹ä»¶è¡¨
-- migrations/001_create_events_table.sql

CREATE TABLE events (
    event_id UUID PRIMARY KEY,
    event_type VARCHAR(255) NOT NULL,
    aggregate_id UUID NOT NULL,
    aggregate_type VARCHAR(100) NOT NULL,
    version INTEGER NOT NULL,
    event_data JSONB NOT NULL,
    metadata JSONB NOT NULL,
    occurred_on TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT unique_aggregate_version UNIQUE (aggregate_id, version)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_events_aggregate_id ON events (aggregate_id);
CREATE INDEX idx_events_aggregate_type ON events (aggregate_type);
CREATE INDEX idx_events_event_type ON events (event_type);
CREATE INDEX idx_events_occurred_on ON events (occurred_on);
CREATE INDEX idx_events_aggregate_id_version ON events (aggregate_id, version);

-- å¿«ç…§è¡¨
-- migrations/002_create_snapshots_table.sql

CREATE TABLE snapshots (
    aggregate_id UUID PRIMARY KEY,
    aggregate_type VARCHAR(100) NOT NULL,
    version INTEGER NOT NULL,
    data JSONB NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_snapshots_aggregate_type ON snapshots (aggregate_type);
CREATE INDEX idx_snapshots_version ON snapshots (version);
CREATE INDEX idx_snapshots_created_at ON snapshots (created_at);
```

---

## ğŸ“¸ å¿«ç…§æœºåˆ¶

### 1. å¿«ç…§ç­–ç•¥

```typescript
// å¿«ç…§ç­–ç•¥æ¥å£
// src/infrastructure/event-sourcing/snapshot-strategy.interface.ts

export interface ISnapshotStrategy {
  shouldCreateSnapshot(aggregateId: string, currentVersion: number): Promise<boolean>;
  getSnapshotFrequency(): number;
}

// åŸºäºç‰ˆæœ¬çš„å¿«ç…§ç­–ç•¥
export class VersionBasedSnapshotStrategy implements ISnapshotStrategy {
  constructor(private readonly snapshotFrequency: number = 10) {}

  async shouldCreateSnapshot(
    aggregateId: string,
    currentVersion: number
  ): Promise<boolean> {
    return currentVersion % this.snapshotFrequency === 0;
  }

  getSnapshotFrequency(): number {
    return this.snapshotFrequency;
  }
}

// åŸºäºæ—¶é—´çš„å¿«ç…§ç­–ç•¥
export class TimeBasedSnapshotStrategy implements ISnapshotStrategy {
  constructor(
    private readonly snapshotInterval: number = 24 * 60 * 60 * 1000, // 24å°æ—¶
    private readonly eventStore: IEventStore
  ) {}

  async shouldCreateSnapshot(
    aggregateId: string,
    currentVersion: number
  ): Promise<boolean> {
    const latestSnapshot = await this.eventStore.getLatestSnapshot(aggregateId);
    
    if (!latestSnapshot) {
      return true;
    }

    const timeSinceLastSnapshot = Date.now() - latestSnapshot.createdAt.getTime();
    return timeSinceLastSnapshot >= this.snapshotInterval;
  }

  getSnapshotFrequency(): number {
    return this.snapshotInterval;
  }
}
```

### 2. å¿«ç…§ç®¡ç†æœåŠ¡

```typescript
// å¿«ç…§ç®¡ç†æœåŠ¡
// src/infrastructure/event-sourcing/snapshot-manager.service.ts

@Injectable()
export class SnapshotManagerService {
  constructor(
    private readonly eventStore: IEventStore,
    private readonly snapshotStrategy: ISnapshotStrategy,
    private readonly logger: Logger
  ) {}

  async createSnapshotIfNeeded<T extends EventSourcedAggregate>(
    aggregate: T
  ): Promise<void> {
    const shouldCreate = await this.snapshotStrategy.shouldCreateSnapshot(
      aggregate.getId(),
      aggregate.getVersion()
    );

    if (shouldCreate) {
      await this.createSnapshot(aggregate);
    }
  }

  async createSnapshot<T extends EventSourcedAggregate>(
    aggregate: T
  ): Promise<void> {
    try {
      const snapshot = aggregate.createSnapshot();
      await this.eventStore.saveSnapshot(snapshot);

      this.logger.log('Snapshot created successfully', {
        aggregateId: aggregate.getId(),
        version: aggregate.getVersion(),
      });
    } catch (error) {
      this.logger.error('Failed to create snapshot', {
        aggregateId: aggregate.getId(),
        error: error.message,
      });
      throw error;
    }
  }

  async loadAggregateFromSnapshot<T extends EventSourcedAggregate>(
    aggregateClass: new (id: string) => T,
    aggregateId: string
  ): Promise<{ aggregate: T; fromVersion: number } | null> {
    try {
      const snapshot = await this.eventStore.getLatestSnapshot(aggregateId);
      
      if (!snapshot) {
        return null;
      }

      const aggregate = new aggregateClass(aggregateId);
      aggregate.restoreFromSnapshot(snapshot);

      this.logger.log('Aggregate loaded from snapshot', {
        aggregateId,
        snapshotVersion: snapshot.version,
      });

      return {
        aggregate,
        fromVersion: snapshot.version,
      };
    } catch (error) {
      this.logger.error('Failed to load aggregate from snapshot', {
        aggregateId,
        error: error.message,
      });
      return null;
    }
  }

  async cleanupOldSnapshots(
    aggregateId: string,
    keepCount: number = 5
  ): Promise<void> {
    // å®ç°å¿«ç…§æ¸…ç†é€»è¾‘
    // ä¿ç•™æœ€æ–°çš„å‡ ä¸ªå¿«ç…§ï¼Œåˆ é™¤æ—§çš„å¿«ç…§
    const query = `
      DELETE FROM snapshots 
      WHERE aggregate_id = $1 
      AND version NOT IN (
        SELECT version FROM snapshots 
        WHERE aggregate_id = $1 
        ORDER BY version DESC 
        LIMIT $2
      )
    `;

    await this.eventStore.query(query, [aggregateId, keepCount]);

    this.logger.log('Old snapshots cleaned up', {
      aggregateId,
      keepCount,
    });
  }
}
```

---

## ğŸ”„ äº‹ä»¶é‡æ”¾ä¸æŠ•å½±

### 1. äº‹ä»¶é‡æ”¾æœåŠ¡

```typescript
// äº‹ä»¶é‡æ”¾æœåŠ¡
// src/infrastructure/event-sourcing/event-replay.service.ts

@Injectable()
export class EventReplayService {
  constructor(
    private readonly eventStore: IEventStore,
    private readonly snapshotManager: SnapshotManagerService,
    private readonly logger: Logger
  ) {}

  async replayAggregate<T extends EventSourcedAggregate>(
    aggregateClass: new (id: string) => T,
    aggregateId: string,
    toVersion?: number
  ): Promise<T> {
    // å°è¯•ä»å¿«ç…§åŠ è½½
    const snapshotResult = await this.snapshotManager.loadAggregateFromSnapshot(
      aggregateClass,
      aggregateId
    );

    let aggregate: T;
    let fromVersion = 0;

    if (snapshotResult) {
      aggregate = snapshotResult.aggregate;
      fromVersion = snapshotResult.fromVersion;
    } else {
      aggregate = new aggregateClass(aggregateId);
    }

    // è·å–äº‹ä»¶æµ
    const events = await this.eventStore.getEventStream(aggregateId, fromVersion);
    
    // è¿‡æ»¤åˆ°æŒ‡å®šç‰ˆæœ¬
    const filteredEvents = toVersion 
      ? events.filter(event => event.version <= toVersion)
      : events;

    if (filteredEvents.length === 0 && !snapshotResult) {
      throw new AggregateNotFoundError(`Aggregate ${aggregateId} not found`);
    }

    // é‡æ”¾äº‹ä»¶
    if (filteredEvents.length > 0) {
      const replayedAggregate = EventSourcedAggregate.fromHistory(
        aggregateClass,
        filteredEvents
      );
      
      // å¦‚æœæœ‰å¿«ç…§ï¼Œéœ€è¦åˆå¹¶çŠ¶æ€
      if (snapshotResult) {
        // è¿™é‡Œéœ€è¦å®ç°çŠ¶æ€åˆå¹¶é€»è¾‘
        aggregate = this.mergeAggregateStates(aggregate, replayedAggregate);
      } else {
        aggregate = replayedAggregate;
      }
    }

    this.logger.log('Aggregate replayed successfully', {
      aggregateId,
      fromVersion,
      toVersion: aggregate.getVersion(),
      eventCount: filteredEvents.length,
    });

    return aggregate;
  }

  async replayAllEvents(
    fromTimestamp?: Date,
    toTimestamp?: Date,
    eventTypes?: string[]
  ): Promise<DomainEvent[]> {
    const events = await this.eventStore.getAllEvents(
      fromTimestamp,
      toTimestamp,
      eventTypes
    );

    this.logger.log('Events replayed', {
      eventCount: events.length,
      fromTimestamp,
      toTimestamp,
      eventTypes,
    });

    return events;
  }

  async replayEventsToProjection(
    projectionName: string,
    fromTimestamp?: Date,
    toTimestamp?: Date
  ): Promise<void> {
    const events = await this.replayAllEvents(fromTimestamp, toTimestamp);
    
    // è¿™é‡Œéœ€è¦æ ¹æ®æŠ•å½±åç§°æ‰¾åˆ°å¯¹åº”çš„æŠ•å½±å¤„ç†å™¨
    const projectionHandler = this.getProjectionHandler(projectionName);
    
    for (const event of events) {
      await projectionHandler.handle(event);
    }

    this.logger.log('Events replayed to projection', {
      projectionName,
      eventCount: events.length,
    });
  }

  private mergeAggregateStates<T extends EventSourcedAggregate>(
    snapshotAggregate: T,
    replayedAggregate: T
  ): T {
    // å®ç°èšåˆçŠ¶æ€åˆå¹¶é€»è¾‘
    // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„å®ç°ï¼Œå®é™…å¯èƒ½éœ€è¦æ›´å¤æ‚çš„åˆå¹¶ç­–ç•¥
    return replayedAggregate;
  }

  private getProjectionHandler(projectionName: string): any {
    // å®ç°æŠ•å½±å¤„ç†å™¨æŸ¥æ‰¾é€»è¾‘
    // å¯ä»¥ä½¿ç”¨ä¾èµ–æ³¨å…¥å®¹å™¨æˆ–æ³¨å†Œè¡¨æ¨¡å¼
    throw new Error('Projection handler not implemented');
  }
}
```

### 2. æŠ•å½±æ„å»ºå™¨

```typescript
// æŠ•å½±æ„å»ºå™¨åŸºç±»
// src/infrastructure/event-sourcing/projection-builder.base.ts

export abstract class ProjectionBuilder {
  protected abstract projectionName: string;
  
  constructor(
    protected readonly eventStore: IEventStore,
    protected readonly logger: Logger
  ) {}

  abstract handle(event: DomainEvent): Promise<void>;

  async rebuild(fromTimestamp?: Date): Promise<void> {
    this.logger.log(`Starting projection rebuild: ${this.projectionName}`);
    
    // æ¸…ç©ºç°æœ‰æŠ•å½±æ•°æ®
    await this.clearProjection();
    
    // è·å–æ‰€æœ‰ç›¸å…³äº‹ä»¶
    const events = await this.eventStore.getAllEvents(fromTimestamp);
    
    // é‡å»ºæŠ•å½±
    for (const event of events) {
      if (this.shouldHandleEvent(event)) {
        await this.handle(event);
      }
    }
    
    this.logger.log(`Projection rebuild completed: ${this.projectionName}`, {
      eventCount: events.length,
    });
  }

  protected abstract clearProjection(): Promise<void>;
  
  protected abstract shouldHandleEvent(event: DomainEvent): boolean;
}

// çº¿ç´¢ç»Ÿè®¡æŠ•å½±æ„å»ºå™¨
export class LeadStatisticsProjectionBuilder extends ProjectionBuilder {
  protected projectionName = 'LeadStatistics';

  constructor(
    eventStore: IEventStore,
    logger: Logger,
    private readonly databaseService: DatabaseService
  ) {
    super(eventStore, logger);
  }

  async handle(event: DomainEvent): Promise<void> {
    switch (event.eventType) {
      case 'LeadCreatedEvent':
        await this.handleLeadCreated(event);
        break;
      case 'LeadStatusChangedEvent':
        await this.handleLeadStatusChanged(event);
        break;
      case 'LeadConvertedToOrderEvent':
        await this.handleLeadConverted(event);
        break;
    }
  }

  protected async clearProjection(): Promise<void> {
    await this.databaseService.query('DELETE FROM lead_statistics');
  }

  protected shouldHandleEvent(event: DomainEvent): boolean {
    return event.aggregateType === 'Lead';
  }

  private async handleLeadCreated(event: DomainEvent): Promise<void> {
    const data = event.getEventData();
    
    await this.databaseService.query(`
      INSERT INTO lead_statistics (
        date, source, status, count, total_value
      ) VALUES ($1, $2, $3, 1, $4)
      ON CONFLICT (date, source, status)
      DO UPDATE SET 
        count = lead_statistics.count + 1,
        total_value = lead_statistics.total_value + $4
    `, [
      event.occurredOn.toISOString().split('T')[0],
      data.source,
      'new',
      data.estimatedValue || 0,
    ]);
  }

  private async handleLeadStatusChanged(event: DomainEvent): Promise<void> {
    const data = event.getEventData();
    
    // å‡å°‘æ—§çŠ¶æ€è®¡æ•°
    await this.databaseService.query(`
      UPDATE lead_statistics 
      SET count = count - 1 
      WHERE date = $1 AND status = $2
    `, [
      event.occurredOn.toISOString().split('T')[0],
      data.fromStatus,
    ]);

    // å¢åŠ æ–°çŠ¶æ€è®¡æ•°
    await this.databaseService.query(`
      INSERT INTO lead_statistics (
        date, source, status, count, total_value
      ) VALUES ($1, 'unknown', $2, 1, 0)
      ON CONFLICT (date, source, status)
      DO UPDATE SET count = lead_statistics.count + 1
    `, [
      event.occurredOn.toISOString().split('T')[0],
      data.toStatus,
    ]);
  }

  private async handleLeadConverted(event: DomainEvent): Promise<void> {
    const data = event.getEventData();
    
    await this.databaseService.query(`
      UPDATE lead_statistics 
      SET 
        conversion_count = conversion_count + 1,
        conversion_value = conversion_value + $2
      WHERE date = $1
    `, [
      event.occurredOn.toISOString().split('T')[0],
      data.conversionValue,
    ]);
  }
}
```

---

## âš¡ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. äº‹ä»¶å­˜å‚¨ä¼˜åŒ–

```typescript
// äº‹ä»¶å­˜å‚¨æ€§èƒ½ä¼˜åŒ–
// src/infrastructure/event-sourcing/optimized-event-store.service.ts

@Injectable()
export class OptimizedEventStore extends PostgreSQLEventStore {
  private readonly eventCache = new Map<string, DomainEvent[]>();
  private readonly snapshotCache = new Map<string, AggregateSnapshot>();
  
  constructor(
    databaseService: DatabaseService,
    logger: Logger,
    private readonly cacheService: CacheService,
    private readonly metricsService: MetricsService
  ) {
    super(databaseService, logger);
  }

  async getEventStream(
    aggregateId: string,
    fromVersion?: number
  ): Promise<DomainEvent[]> {
    const cacheKey = `events:${aggregateId}:${fromVersion || 0}`;
    
    // å°è¯•ä»ç¼“å­˜è·å–
    const cachedEvents = await this.cacheService.get(cacheKey);
    if (cachedEvents) {
      this.metricsService.incrementCounter('event_store.cache_hit');
      return cachedEvents;
    }

    // ä»æ•°æ®åº“è·å–
    const startTime = Date.now();
    const events = await super.getEventStream(aggregateId, fromVersion);
    const duration = Date.now() - startTime;

    // ç¼“å­˜ç»“æœ
    await this.cacheService.set(cacheKey, events, 300); // 5åˆ†é’Ÿç¼“å­˜
    
    this.metricsService.incrementCounter('event_store.cache_miss');
    this.metricsService.recordHistogram('event_store.query_duration', duration);
    
    return events;
  }

  async saveEvents(
    aggregateId: string,
    events: DomainEvent[],
    expectedVersion: number
  ): Promise<void> {
    const startTime = Date.now();
    
    await super.saveEvents(aggregateId, events, expectedVersion);
    
    // æ¸…é™¤ç›¸å…³ç¼“å­˜
    await this.invalidateCache(aggregateId);
    
    const duration = Date.now() - startTime;
    this.metricsService.recordHistogram('event_store.save_duration', duration);
    this.metricsService.incrementCounter('event_store.events_saved', events.length);
  }

  async getSnapshot(aggregateId: string): Promise<AggregateSnapshot | null> {
    const cacheKey = `snapshot:${aggregateId}`;
    
    // å°è¯•ä»ç¼“å­˜è·å–
    const cachedSnapshot = await this.cacheService.get(cacheKey);
    if (cachedSnapshot) {
      this.metricsService.incrementCounter('snapshot_store.cache_hit');
      return cachedSnapshot;
    }

    // ä»æ•°æ®åº“è·å–
    const snapshot = await super.getSnapshot(aggregateId);
    
    if (snapshot) {
      // ç¼“å­˜ç»“æœ
      await this.cacheService.set(cacheKey, snapshot, 600); // 10åˆ†é’Ÿç¼“å­˜
    }
    
    this.metricsService.incrementCounter('snapshot_store.cache_miss');
    
    return snapshot;
  }

  private async invalidateCache(aggregateId: string): Promise<void> {
    const patterns = [
      `events:${aggregateId}:*`,
      `snapshot:${aggregateId}`,
    ];

    for (const pattern of patterns) {
      await this.cacheService.deletePattern(pattern);
    }
  }
}
```

### 2. æ‰¹é‡å¤„ç†ä¼˜åŒ–

```typescript
// æ‰¹é‡äº‹ä»¶å¤„ç†å™¨
// src/infrastructure/event-sourcing/batch-event-processor.service.ts

@Injectable()
export class BatchEventProcessor {
  private readonly batchSize = 100;
  private readonly batchTimeout = 5000; // 5ç§’
  private readonly eventBatches = new Map<string, DomainEvent[]>();
  private readonly batchTimers = new Map<string, NodeJS.Timeout>();

  constructor(
    private readonly eventStore: IEventStore,
    private readonly logger: Logger
  ) {}

  async addEvent(event: DomainEvent): Promise<void> {
    const batchKey = this.getBatchKey(event);
    
    if (!this.eventBatches.has(batchKey)) {
      this.eventBatches.set(batchKey, []);
    }

    const batch = this.eventBatches.get(batchKey)!;
    batch.push(event);

    // æ£€æŸ¥æ˜¯å¦éœ€è¦ç«‹å³å¤„ç†
    if (batch.length >= this.batchSize) {
      await this.processBatch(batchKey);
    } else {
      // è®¾ç½®è¶…æ—¶å¤„ç†
      this.setBatchTimeout(batchKey);
    }
  }

  private getBatchKey(event: DomainEvent): string {
    // å¯ä»¥æ ¹æ®èšåˆç±»å‹æˆ–å…¶ä»–æ¡ä»¶åˆ†ç»„
    return event.aggregateType;
  }

  private setBatchTimeout(batchKey: string): void {
    // æ¸…é™¤ç°æœ‰å®šæ—¶å™¨
    if (this.batchTimers.has(batchKey)) {
      clearTimeout(this.batchTimers.get(batchKey)!);
    }

    // è®¾ç½®æ–°å®šæ—¶å™¨
    const timer = setTimeout(async () => {
      await this.processBatch(batchKey);
    }, this.batchTimeout);

    this.batchTimers.set(batchKey, timer);
  }

  private async processBatch(batchKey: string): Promise<void> {
    const batch = this.eventBatches.get(batchKey);
    if (!batch || batch.length === 0) {
      return;
    }

    try {
      // æŒ‰èšåˆIDåˆ†ç»„
      const eventsByAggregate = this.groupEventsByAggregate(batch);

      // æ‰¹é‡ä¿å­˜
      for (const [aggregateId, events] of eventsByAggregate) {
        await this.eventStore.saveEvents(
          aggregateId,
          events,
          events[0].version - 1
        );
      }

      this.logger.log('Batch processed successfully', {
        batchKey,
        eventCount: batch.length,
        aggregateCount: eventsByAggregate.size,
      });
    } catch (error) {
      this.logger.error('Failed to process batch', {
        batchKey,
        eventCount: batch.length,
        error: error.message,
      });
      throw error;
    } finally {
      // æ¸…ç†
      this.eventBatches.delete(batchKey);
      if (this.batchTimers.has(batchKey)) {
        clearTimeout(this.batchTimers.get(batchKey)!);
        this.batchTimers.delete(batchKey);
      }
    }
  }

  private groupEventsByAggregate(
    events: DomainEvent[]
  ): Map<string, DomainEvent[]> {
    const grouped = new Map<string, DomainEvent[]>();

    for (const event of events) {
      if (!grouped.has(event.aggregateId)) {
        grouped.set(event.aggregateId, []);
      }
      grouped.get(event.aggregateId)!.push(event);
    }

    // æŒ‰ç‰ˆæœ¬æ’åº
    for (const [, aggregateEvents] of grouped) {
      aggregateEvents.sort((a, b) => a.version - b.version);
    }

    return grouped;
  }
}
```

---

## ğŸ“Š ç›‘æ§å’Œè¿ç»´

### 1. äº‹ä»¶æº¯æºç›‘æ§

```typescript
// äº‹ä»¶æº¯æºç›‘æ§æœåŠ¡
// src/infrastructure/event-sourcing/event-sourcing-monitor.service.ts

@Injectable()
export class EventSourcingMonitorService {
  constructor(
    private readonly eventStore: IEventStore,
    private readonly metricsService: MetricsService,
    private readonly alertService: AlertService,
    private readonly logger: Logger
  ) {}

  @Cron('*/5 * * * *') // æ¯5åˆ†é’Ÿæ‰§è¡Œ
  async monitorEventStoreHealth(): Promise<void> {
    try {
      await this.checkEventStoreLatency();
      await this.checkEventStoreSize();
      await this.checkSnapshotHealth();
      await this.checkConcurrencyConflicts();
    } catch (error) {
      this.logger.error('Event store health check failed', {
        error: error.message,
      });
    }
  }

  private async checkEventStoreLatency(): Promise<void> {
    const startTime = Date.now();
    
    // æ‰§è¡Œç®€å•æŸ¥è¯¢æµ‹è¯•å»¶è¿Ÿ
    await this.eventStore.getAllEvents(
      new Date(Date.now() - 60000), // æœ€è¿‘1åˆ†é’Ÿ
      new Date()
    );
    
    const latency = Date.now() - startTime;
    
    this.metricsService.recordGauge('event_store.latency', latency);
    
    if (latency > 5000) { // è¶…è¿‡5ç§’
      await this.alertService.sendAlert({
        level: 'warning',
        message: `Event store latency is high: ${latency}ms`,
        component: 'event-store',
      });
    }
  }

  private async checkEventStoreSize(): Promise<void> {
    const query = `
      SELECT 
        COUNT(*) as event_count,
        pg_total_relation_size('events') as table_size
      FROM events
    `;
    
    const result = await this.eventStore.query(query);
    const { event_count, table_size } = result.rows[0];
    
    this.metricsService.recordGauge('event_store.event_count', event_count);
    this.metricsService.recordGauge('event_store.table_size', table_size);
    
    // æ£€æŸ¥è¡¨å¤§å°æ˜¯å¦è¿‡å¤§
    const sizeInGB = table_size / (1024 * 1024 * 1024);
    if (sizeInGB > 10) { // è¶…è¿‡10GB
      await this.alertService.sendAlert({
        level: 'warning',
        message: `Event store table size is large: ${sizeInGB.toFixed(2)}GB`,
        component: 'event-store',
      });
    }
  }

  private async checkSnapshotHealth(): Promise<void> {
    const query = `
      SELECT 
        aggregate_type,
        COUNT(*) as snapshot_count,
        AVG(version) as avg_version,
        MAX(created_at) as last_snapshot
      FROM snapshots
      GROUP BY aggregate_type
    `;
    
    const result = await this.eventStore.query(query);
    
    for (const row of result.rows) {
      const { aggregate_type, snapshot_count, avg_version, last_snapshot } = row;
      
      this.metricsService.recordGauge(
        'event_store.snapshot_count',
        snapshot_count,
        { aggregate_type }
      );
      
      this.metricsService.recordGauge(
        'event_store.avg_snapshot_version',
        avg_version,
        { aggregate_type }
      );
      
      // æ£€æŸ¥å¿«ç…§æ˜¯å¦è¿‡æ—§
      const hoursSinceLastSnapshot = 
        (Date.now() - new Date(last_snapshot).getTime()) / (1000 * 60 * 60);
      
      if (hoursSinceLastSnapshot > 24) { // è¶…è¿‡24å°æ—¶
        await this.alertService.sendAlert({
          level: 'info',
          message: `No recent snapshots for ${aggregate_type}: ${hoursSinceLastSnapshot.toFixed(1)} hours`,
          component: 'snapshot-manager',
        });
      }
    }
  }

  private async checkConcurrencyConflicts(): Promise<void> {
    // æ£€æŸ¥æœ€è¿‘çš„å¹¶å‘å†²çª
    const query = `
      SELECT COUNT(*) as conflict_count
      FROM application_logs
      WHERE level = 'ERROR'
      AND message LIKE '%ConcurrencyError%'
      AND created_at > NOW() - INTERVAL '1 hour'
    `;
    
    const result = await this.eventStore.query(query);
    const conflictCount = result.rows[0]?.conflict_count || 0;
    
    this.metricsService.recordGauge('event_store.concurrency_conflicts', conflictCount);
    
    if (conflictCount > 10) { // æ¯å°æ—¶è¶…è¿‡10æ¬¡å†²çª
      await this.alertService.sendAlert({
        level: 'warning',
        message: `High concurrency conflicts detected: ${conflictCount} in the last hour`,
        component: 'event-store',
      });
    }
  }

  async generateHealthReport(): Promise<EventStoreHealthReport> {
    const eventCountQuery = 'SELECT COUNT(*) as count FROM events';
    const snapshotCountQuery = 'SELECT COUNT(*) as count FROM snapshots';
    const tableSizeQuery = `
      SELECT pg_total_relation_size('events') as events_size,
             pg_total_relation_size('snapshots') as snapshots_size
    `;
    
    const [eventResult, snapshotResult, sizeResult] = await Promise.all([
      this.eventStore.query(eventCountQuery),
      this.eventStore.query(snapshotCountQuery),
      this.eventStore.query(tableSizeQuery),
    ]);
    
    return {
      eventCount: eventResult.rows[0].count,
      snapshotCount: snapshotResult.rows[0].count,
      eventsTableSize: sizeResult.rows[0].events_size,
      snapshotsTableSize: sizeResult.rows[0].snapshots_size,
      generatedAt: new Date(),
    };
  }
}

// å¥åº·æŠ¥å‘Šæ¥å£
export interface EventStoreHealthReport {
  eventCount: number;
  snapshotCount: number;
  eventsTableSize: number;
  snapshotsTableSize: number;
  generatedAt: Date;
}
```

### 2. äº‹ä»¶æº¯æºè¿ç»´å·¥å…·

```typescript
// äº‹ä»¶æº¯æºè¿ç»´å·¥å…·
// src/infrastructure/event-sourcing/event-sourcing-admin.service.ts

@Injectable()
export class EventSourcingAdminService {
  constructor(
    private readonly eventStore: IEventStore,
    private readonly snapshotManager: SnapshotManagerService,
    private readonly eventReplay: EventReplayService,
    private readonly logger: Logger
  ) {}

  async archiveOldEvents(beforeDate: Date): Promise<number> {
    const archiveQuery = `
      INSERT INTO events_archive 
      SELECT * FROM events 
      WHERE occurred_on < $1
    `;
    
    const deleteQuery = `
      DELETE FROM events 
      WHERE occurred_on < $1
    `;
    
    const client = await this.eventStore.getClient();
    
    try {
      await client.query('BEGIN');
      
      // å½’æ¡£äº‹ä»¶
      const archiveResult = await client.query(archiveQuery, [beforeDate]);
      
      // åˆ é™¤åŸäº‹ä»¶
      const deleteResult = await client.query(deleteQuery, [beforeDate]);
      
      await client.query('COMMIT');
      
      const archivedCount = deleteResult.rowCount;
      
      this.logger.log('Events archived successfully', {
        archivedCount,
        beforeDate,
      });
      
      return archivedCount;
    } catch (error) {
      await client.query('ROLLBACK');
      this.logger.error('Failed to archive events', {
        error: error.message,
        beforeDate,
      });
      throw error;
    } finally {
      client.release();
    }
  }

  async rebuildProjection(
    projectionName: string,
    fromDate?: Date
  ): Promise<void> {
    this.logger.log('Starting projection rebuild', {
      projectionName,
      fromDate,
    });
    
    await this.eventReplay.replayEventsToProjection(
      projectionName,
      fromDate
    );
    
    this.logger.log('Projection rebuild completed', {
      projectionName,
    });
  }

  async createSnapshotsForAllAggregates(
    aggregateType: string
  ): Promise<number> {
    const query = `
      SELECT DISTINCT aggregate_id 
      FROM events 
      WHERE aggregate_type = $1
    `;
    
    const result = await this.eventStore.query(query, [aggregateType]);
    const aggregateIds = result.rows.map(row => row.aggregate_id);
    
    let snapshotCount = 0;
    
    for (const aggregateId of aggregateIds) {
      try {
        // è¿™é‡Œéœ€è¦æ ¹æ®èšåˆç±»å‹åˆ›å»ºç›¸åº”çš„èšåˆå®ä¾‹
        // ç®€åŒ–ç¤ºä¾‹ï¼Œå®é™…éœ€è¦å·¥å‚æ¨¡å¼
        const aggregate = await this.eventReplay.replayAggregate(
          this.getAggregateClass(aggregateType),
          aggregateId
        );
        
        await this.snapshotManager.createSnapshot(aggregate);
        snapshotCount++;
      } catch (error) {
        this.logger.error('Failed to create snapshot', {
          aggregateId,
          error: error.message,
        });
      }
    }
    
    this.logger.log('Bulk snapshot creation completed', {
      aggregateType,
      totalAggregates: aggregateIds.length,
      successfulSnapshots: snapshotCount,
    });
    
    return snapshotCount;
  }

  async validateEventIntegrity(): Promise<ValidationResult> {
    const issues: string[] = [];
    
    // æ£€æŸ¥ç‰ˆæœ¬è¿ç»­æ€§
    const versionGapQuery = `
      SELECT aggregate_id, version, 
             LAG(version) OVER (PARTITION BY aggregate_id ORDER BY version) as prev_version
      FROM events
      ORDER BY aggregate_id, version
    `;
    
    const versionResult = await this.eventStore.query(versionGapQuery);
    
    for (const row of versionResult.rows) {
      if (row.prev_version && row.version !== row.prev_version + 1) {
        issues.push(
          `Version gap detected for aggregate ${row.aggregate_id}: ${row.prev_version} -> ${row.version}`
        );
      }
    }
    
    // æ£€æŸ¥é‡å¤äº‹ä»¶
    const duplicateQuery = `
      SELECT event_id, COUNT(*) as count
      FROM events
      GROUP BY event_id
      HAVING COUNT(*) > 1
    `;
    
    const duplicateResult = await this.eventStore.query(duplicateQuery);
    
    for (const row of duplicateResult.rows) {
      issues.push(`Duplicate event detected: ${row.event_id} (${row.count} times)`);
    }
    
    return {
      isValid: issues.length === 0,
      issues,
      checkedAt: new Date(),
    };
  }

  private getAggregateClass(aggregateType: string): any {
    // å®ç°èšåˆç±»å‹åˆ°ç±»çš„æ˜ å°„
    const aggregateClasses = {
      'Lead': Lead,
      'Order': Order,
      // æ·»åŠ å…¶ä»–èšåˆç±»å‹
    };
    
    return aggregateClasses[aggregateType];
  }
}

// éªŒè¯ç»“æœæ¥å£
export interface ValidationResult {
  isValid: boolean;
  issues: string[];
  checkedAt: Date;
}
```

è¿™ä¸ªå®Œæ•´çš„äº‹ä»¶æº¯æºæœºåˆ¶è®¾è®¡æ–¹æ¡ˆæä¾›äº†ä¼ä¸šçº§çš„äº‹ä»¶æº¯æºæ¶æ„ï¼ŒåŒ…æ‹¬èšåˆæ ¹è®¾è®¡ã€äº‹ä»¶å­˜å‚¨ã€å¿«ç…§æœºåˆ¶ã€äº‹ä»¶é‡æ”¾ã€æŠ•å½±æ„å»ºã€æ€§èƒ½ä¼˜åŒ–å’Œç›‘æ§è¿ç»´ç­‰å…¨æ–¹ä½åŠŸèƒ½ï¼Œç¡®ä¿ç³»ç»Ÿå…·å¤‡å®Œæ•´çš„å®¡è®¡è¿½è¸ªã€æ—¶é—´æ—…è¡Œå’Œæ•…éšœæ¢å¤èƒ½åŠ›ã€‚
