# ç½—è±L2Cé”€å”®ç®¡ç†ç³»ç»Ÿ - å…­è¾¹å½¢æ¶æ„è®¾è®¡æ–¹æ¡ˆ

## ğŸ“‹ ç›®å½•
- [è®¾è®¡ç›®æ ‡ä¸ä»·å€¼](#è®¾è®¡ç›®æ ‡ä¸ä»·å€¼)
- [å…­è¾¹å½¢æ¶æ„æ¦‚è¿°](#å…­è¾¹å½¢æ¶æ„æ¦‚è¿°)
- [ç«¯å£è®¾è®¡](#ç«¯å£è®¾è®¡)
- [é€‚é…å™¨è®¾è®¡](#é€‚é…å™¨è®¾è®¡)
- [åº”ç”¨æ ¸å¿ƒè®¾è®¡](#åº”ç”¨æ ¸å¿ƒè®¾è®¡)
- [ä¾èµ–æ³¨å…¥é…ç½®](#ä¾èµ–æ³¨å…¥é…ç½®)
- [æµ‹è¯•ç­–ç•¥](#æµ‹è¯•ç­–ç•¥)
- [éƒ¨ç½²é…ç½®](#éƒ¨ç½²é…ç½®)

---

## ğŸ¯ è®¾è®¡ç›®æ ‡ä¸ä»·å€¼

### 1. è®¾è®¡ç›®æ ‡
- **ä¸šåŠ¡é€»è¾‘éš”ç¦»**ï¼šå°†æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ä¸å¤–éƒ¨ä¾èµ–å®Œå…¨éš”ç¦»
- **å¯æµ‹è¯•æ€§**ï¼šé€šè¿‡ç«¯å£æŠ½è±¡å®ç°é«˜åº¦å¯æµ‹è¯•çš„æ¶æ„
- **å¯æ‰©å±•æ€§**ï¼šæ”¯æŒå¤šç§å¤–éƒ¨ç³»ç»Ÿå’ŒæŠ€æœ¯æ ˆçš„çµæ´»åˆ‡æ¢
- **æŠ€æœ¯æ— å…³æ€§**ï¼šæ ¸å¿ƒä¸šåŠ¡é€»è¾‘ä¸ä¾èµ–ä»»ä½•ç‰¹å®šæŠ€æœ¯
- **æ¸…æ™°è¾¹ç•Œ**ï¼šæ˜ç¡®å®šä¹‰å†…éƒ¨å’Œå¤–éƒ¨ç³»ç»Ÿçš„äº¤äº’è¾¹ç•Œ

### 2. ä¸šåŠ¡ä»·å€¼
- **é™ä½è€¦åˆåº¦**ï¼šå‡å°‘ç³»ç»Ÿå„éƒ¨åˆ†ä¹‹é—´çš„ä¾èµ–å…³ç³»
- **æé«˜å¯ç»´æŠ¤æ€§**ï¼šä¸šåŠ¡é€»è¾‘å˜æ›´ä¸å½±å“å¤–éƒ¨ç³»ç»Ÿé›†æˆ
- **å¢å¼ºçµæ´»æ€§**ï¼šæ”¯æŒå¿«é€Ÿé€‚é…æ–°çš„å¤–éƒ¨ç³»ç»Ÿå’ŒæŠ€æœ¯
- **ç®€åŒ–æµ‹è¯•**ï¼šé€šè¿‡æ¨¡æ‹Ÿé€‚é…å™¨å®ç°é«˜æ•ˆçš„å•å…ƒæµ‹è¯•
- **é£é™©æ§åˆ¶**ï¼šå¤–éƒ¨ç³»ç»Ÿå˜æ›´ä¸ä¼šå½±å“æ ¸å¿ƒä¸šåŠ¡é€»è¾‘

---

## ğŸ—ï¸ å…­è¾¹å½¢æ¶æ„æ¦‚è¿°

### 1. æ¶æ„æ€»è§ˆ

```mermaid
graph TB
    subgraph "å¤–éƒ¨ç³»ç»Ÿ"
        A[Web UI] 
        B[Mobile App]
        C[API Gateway]
        D[Message Queue]
        E[Database]
        F[External CRM]
        G[Payment Gateway]
        H[Email Service]
    end
    
    subgraph "é€‚é…å™¨å±‚ (Adapters)"
        A1[Web Controller]
        A2[Mobile Controller] 
        A3[REST API Adapter]
        A4[Message Adapter]
        A5[Database Adapter]
        A6[CRM Adapter]
        A7[Payment Adapter]
        A8[Email Adapter]
    end
    
    subgraph "ç«¯å£å±‚ (Ports)"
        P1[Input Ports]
        P2[Output Ports]
    end
    
    subgraph "åº”ç”¨æ ¸å¿ƒ (Application Core)"
        AC1[Use Cases]
        AC2[Domain Services]
        AC3[Domain Models]
        AC4[Business Rules]
    end
    
    A --> A1
    B --> A2
    C --> A3
    D --> A4
    E --> A5
    F --> A6
    G --> A7
    H --> A8
    
    A1 --> P1
    A2 --> P1
    A3 --> P1
    A4 --> P1
    
    P1 --> AC1
    AC1 --> AC2
    AC2 --> AC3
    AC3 --> AC4
    
    AC1 --> P2
    AC2 --> P2
    
    P2 --> A5
    P2 --> A6
    P2 --> A7
    P2 --> A8
```

### 2. æ ¸å¿ƒæ¦‚å¿µ

#### 2.1 ç«¯å£ (Ports)
ç«¯å£å®šä¹‰äº†åº”ç”¨æ ¸å¿ƒä¸å¤–éƒ¨ä¸–ç•Œçš„äº¤äº’å¥‘çº¦ï¼Œåˆ†ä¸ºè¾“å…¥ç«¯å£å’Œè¾“å‡ºç«¯å£ã€‚

#### 2.2 é€‚é…å™¨ (Adapters)
é€‚é…å™¨å®ç°ç«¯å£æ¥å£ï¼Œè´Ÿè´£å°†å¤–éƒ¨ç³»ç»Ÿçš„è°ƒç”¨è½¬æ¢ä¸ºåº”ç”¨æ ¸å¿ƒèƒ½ç†è§£çš„æ ¼å¼ã€‚

#### 2.3 åº”ç”¨æ ¸å¿ƒ (Application Core)
åŒ…å«æ‰€æœ‰ä¸šåŠ¡é€»è¾‘ã€é¢†åŸŸæ¨¡å‹å’Œç”¨ä¾‹ï¼Œå®Œå…¨ç‹¬ç«‹äºå¤–éƒ¨æŠ€æœ¯ã€‚

---

## ğŸ”Œ ç«¯å£è®¾è®¡

### 1. è¾“å…¥ç«¯å£ (Input Ports)

```typescript
// çº¿ç´¢ç®¡ç†è¾“å…¥ç«¯å£
// src/application/ports/input/lead-management.port.ts

export interface ILeadManagementPort {
  createLead(command: CreateLeadCommand): Promise<LeadDto>;
  updateLead(command: UpdateLeadCommand): Promise<LeadDto>;
  assignLead(command: AssignLeadCommand): Promise<void>;
  convertLead(command: ConvertLeadCommand): Promise<OrderDto>;
  getLeadById(leadId: string): Promise<LeadDto>;
  searchLeads(query: SearchLeadsQuery): Promise<PaginatedResult<LeadDto>>;
  addFollowUp(command: AddFollowUpCommand): Promise<void>;
  updateLeadStatus(command: UpdateLeadStatusCommand): Promise<void>;
}

// è®¢å•ç®¡ç†è¾“å…¥ç«¯å£
// src/application/ports/input/order-management.port.ts

export interface IOrderManagementPort {
  createOrder(command: CreateOrderCommand): Promise<OrderDto>;
  updateOrderStatus(command: UpdateOrderStatusCommand): Promise<void>;
  processPayment(command: ProcessPaymentCommand): Promise<PaymentDto>;
  cancelOrder(command: CancelOrderCommand): Promise<void>;
  getOrderById(orderId: string): Promise<OrderDto>;
  searchOrders(query: SearchOrdersQuery): Promise<PaginatedResult<OrderDto>>;
  addOrderItem(command: AddOrderItemCommand): Promise<void>;
  removeOrderItem(command: RemoveOrderItemCommand): Promise<void>;
  updateDeliveryInfo(command: UpdateDeliveryInfoCommand): Promise<void>;
}

// å®¢æˆ·ç®¡ç†è¾“å…¥ç«¯å£
// src/application/ports/input/customer-management.port.ts

export interface ICustomerManagementPort {
  createCustomer(command: CreateCustomerCommand): Promise<CustomerDto>;
  updateCustomer(command: UpdateCustomerCommand): Promise<CustomerDto>;
  getCustomerById(customerId: string): Promise<CustomerDto>;
  searchCustomers(query: SearchCustomersQuery): Promise<PaginatedResult<CustomerDto>>;
  getCustomerLeads(customerId: string): Promise<LeadDto[]>;
  getCustomerOrders(customerId: string): Promise<OrderDto[]>;
  mergeCustomers(command: MergeCustomersCommand): Promise<CustomerDto>;
  deactivateCustomer(command: DeactivateCustomerCommand): Promise<void>;
}

// æŠ¥è¡¨åˆ†æè¾“å…¥ç«¯å£
// src/application/ports/input/analytics.port.ts

export interface IAnalyticsPort {
  getSalesReport(query: SalesReportQuery): Promise<SalesReportDto>;
  getLeadConversionReport(query: LeadConversionQuery): Promise<ConversionReportDto>;
  getCustomerAnalytics(query: CustomerAnalyticsQuery): Promise<CustomerAnalyticsDto>;
  getPerformanceMetrics(query: PerformanceQuery): Promise<PerformanceMetricsDto>;
  exportReport(command: ExportReportCommand): Promise<ExportResultDto>;
}
```

### 2. è¾“å‡ºç«¯å£ (Output Ports)

```typescript
// æ•°æ®æŒä¹…åŒ–è¾“å‡ºç«¯å£
// src/application/ports/output/persistence.port.ts

export interface ILeadRepositoryPort {
  save(lead: Lead): Promise<void>;
  findById(id: string): Promise<Lead | null>;
  findByCustomerId(customerId: string): Promise<Lead[]>;
  search(criteria: LeadSearchCriteria): Promise<PaginatedResult<Lead>>;
  delete(id: string): Promise<void>;
  exists(id: string): Promise<boolean>;
}

export interface IOrderRepositoryPort {
  save(order: Order): Promise<void>;
  findById(id: string): Promise<Order | null>;
  findByCustomerId(customerId: string): Promise<Order[]>;
  search(criteria: OrderSearchCriteria): Promise<PaginatedResult<Order>>;
  findByStatus(status: OrderStatus): Promise<Order[]>;
  delete(id: string): Promise<void>;
}

export interface ICustomerRepositoryPort {
  save(customer: Customer): Promise<void>;
  findById(id: string): Promise<Customer | null>;
  findByEmail(email: string): Promise<Customer | null>;
  findByPhone(phone: string): Promise<Customer | null>;
  search(criteria: CustomerSearchCriteria): Promise<PaginatedResult<Customer>>;
  delete(id: string): Promise<void>;
}

// å¤–éƒ¨ç³»ç»Ÿé›†æˆè¾“å‡ºç«¯å£
// src/application/ports/output/external-systems.port.ts

export interface INotificationPort {
  sendEmail(notification: EmailNotification): Promise<void>;
  sendSMS(notification: SMSNotification): Promise<void>;
  sendPushNotification(notification: PushNotification): Promise<void>;
  sendWebhook(webhook: WebhookNotification): Promise<void>;
}

export interface IPaymentPort {
  processPayment(payment: PaymentRequest): Promise<PaymentResult>;
  refundPayment(refund: RefundRequest): Promise<RefundResult>;
  getPaymentStatus(paymentId: string): Promise<PaymentStatus>;
  validatePaymentMethod(method: PaymentMethod): Promise<boolean>;
}

export interface ICRMIntegrationPort {
  syncCustomer(customer: Customer): Promise<void>;
  syncLead(lead: Lead): Promise<void>;
  syncOrder(order: Order): Promise<void>;
  getCustomerFromCRM(crmId: string): Promise<CRMCustomer | null>;
  updateCustomerInCRM(customer: Customer): Promise<void>;
}

export interface IFileStoragePort {
  uploadFile(file: FileUpload): Promise<FileMetadata>;
  downloadFile(fileId: string): Promise<FileContent>;
  deleteFile(fileId: string): Promise<void>;
  getFileMetadata(fileId: string): Promise<FileMetadata>;
  generatePresignedUrl(fileId: string, expiresIn: number): Promise<string>;
}

// äº‹ä»¶å‘å¸ƒè¾“å‡ºç«¯å£
// src/application/ports/output/event-publisher.port.ts

export interface IEventPublisherPort {
  publishDomainEvent(event: DomainEvent): Promise<void>;
  publishIntegrationEvent(event: IntegrationEvent): Promise<void>;
  publishBatch(events: DomainEvent[]): Promise<void>;
}

// ç¼“å­˜è¾“å‡ºç«¯å£
// src/application/ports/output/cache.port.ts

export interface ICachePort {
  get<T>(key: string): Promise<T | null>;
  set<T>(key: string, value: T, ttl?: number): Promise<void>;
  delete(key: string): Promise<void>;
  deletePattern(pattern: string): Promise<void>;
  exists(key: string): Promise<boolean>;
  increment(key: string, value?: number): Promise<number>;
  expire(key: string, ttl: number): Promise<void>;
}
```

---

## ğŸ”§ é€‚é…å™¨è®¾è®¡

### 1. è¾“å…¥é€‚é…å™¨ (Input Adapters)

```typescript
// Webæ§åˆ¶å™¨é€‚é…å™¨
// src/adapters/input/web/lead-management.controller.ts

@Controller('api/leads')
@ApiTags('Lead Management')
export class LeadManagementController {
  constructor(
    private readonly leadManagementPort: ILeadManagementPort
  ) {}

  @Post()
  @ApiOperation({ summary: 'Create a new lead' })
  @ApiResponse({ status: 201, description: 'Lead created successfully' })
  async createLead(
    @Body() request: CreateLeadRequest,
    @CurrentUser() user: UserContext
  ): Promise<ApiResponse<LeadDto>> {
    try {
      const command = new CreateLeadCommand(
        request.customerId,
        request.priority,
        request.source,
        request.estimatedValue,
        user.id,
        request.notes
      );

      const lead = await this.leadManagementPort.createLead(command);

      return {
        success: true,
        data: lead,
        message: 'Lead created successfully',
      };
    } catch (error) {
      throw new BadRequestException(error.message);
    }
  }

  @Put(':id/assign')
  @ApiOperation({ summary: 'Assign lead to sales person' })
  async assignLead(
    @Param('id') leadId: string,
    @Body() request: AssignLeadRequest,
    @CurrentUser() user: UserContext
  ): Promise<ApiResponse<void>> {
    try {
      const command = new AssignLeadCommand(
        leadId,
        request.assignedTo,
        user.id,
        request.reason
      );

      await this.leadManagementPort.assignLead(command);

      return {
        success: true,
        message: 'Lead assigned successfully',
      };
    } catch (error) {
      throw new BadRequestException(error.message);
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get lead by ID' })
  async getLeadById(
    @Param('id') leadId: string
  ): Promise<ApiResponse<LeadDto>> {
    try {
      const lead = await this.leadManagementPort.getLeadById(leadId);

      if (!lead) {
        throw new NotFoundException('Lead not found');
      }

      return {
        success: true,
        data: lead,
      };
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      throw new BadRequestException(error.message);
    }
  }

  @Get()
  @ApiOperation({ summary: 'Search leads' })
  async searchLeads(
    @Query() query: SearchLeadsRequest
  ): Promise<ApiResponse<PaginatedResult<LeadDto>>> {
    try {
      const searchQuery = new SearchLeadsQuery(
        query.keyword,
        query.status,
        query.priority,
        query.source,
        query.assignedTo,
        query.dateFrom,
        query.dateTo,
        query.page,
        query.limit
      );

      const result = await this.leadManagementPort.searchLeads(searchQuery);

      return {
        success: true,
        data: result,
      };
    } catch (error) {
      throw new BadRequestException(error.message);
    }
  }
}

// æ¶ˆæ¯é˜Ÿåˆ—é€‚é…å™¨
// src/adapters/input/messaging/lead-event.handler.ts

@EventsHandler(CustomerCreatedEvent)
export class CustomerCreatedEventHandler implements IEventHandler<CustomerCreatedEvent> {
  constructor(
    private readonly leadManagementPort: ILeadManagementPort,
    private readonly logger: Logger
  ) {}

  async handle(event: CustomerCreatedEvent): Promise<void> {
    try {
      this.logger.log('Processing customer created event', {
        customerId: event.customerId,
        eventId: event.eventId,
      });

      // å¦‚æœå®¢æˆ·æ¥æºæ˜¯è¥é”€æ´»åŠ¨ï¼Œè‡ªåŠ¨åˆ›å»ºçº¿ç´¢
      if (event.source === 'marketing_campaign') {
        const command = new CreateLeadCommand(
          event.customerId,
          LeadPriority.MEDIUM,
          event.source,
          undefined,
          'system',
          'Auto-created from customer registration'
        );

        await this.leadManagementPort.createLead(command);

        this.logger.log('Auto-created lead for new customer', {
          customerId: event.customerId,
        });
      }
    } catch (error) {
      this.logger.error('Failed to handle customer created event', {
        customerId: event.customerId,
        error: error.message,
      });
      throw error;
    }
  }
}

// GraphQLé€‚é…å™¨
// src/adapters/input/graphql/lead.resolver.ts

@Resolver(() => Lead)
export class LeadResolver {
  constructor(
    private readonly leadManagementPort: ILeadManagementPort
  ) {}

  @Query(() => Lead, { nullable: true })
  async lead(@Args('id') id: string): Promise<LeadDto | null> {
    return await this.leadManagementPort.getLeadById(id);
  }

  @Query(() => LeadConnection)
  async leads(
    @Args() args: LeadsArgs
  ): Promise<PaginatedResult<LeadDto>> {
    const query = new SearchLeadsQuery(
      args.filter?.keyword,
      args.filter?.status,
      args.filter?.priority,
      args.filter?.source,
      args.filter?.assignedTo,
      args.filter?.dateFrom,
      args.filter?.dateTo,
      args.pagination?.page,
      args.pagination?.limit
    );

    return await this.leadManagementPort.searchLeads(query);
  }

  @Mutation(() => Lead)
  async createLead(
    @Args('input') input: CreateLeadInput,
    @Context('user') user: UserContext
  ): Promise<LeadDto> {
    const command = new CreateLeadCommand(
      input.customerId,
      input.priority,
      input.source,
      input.estimatedValue,
      user.id,
      input.notes
    );

    return await this.leadManagementPort.createLead(command);
  }

  @Mutation(() => Boolean)
  async assignLead(
    @Args('input') input: AssignLeadInput,
    @Context('user') user: UserContext
  ): Promise<boolean> {
    const command = new AssignLeadCommand(
      input.leadId,
      input.assignedTo,
      user.id,
      input.reason
    );

    await this.leadManagementPort.assignLead(command);
    return true;
  }
}
```

### 2. è¾“å‡ºé€‚é…å™¨ (Output Adapters)

```typescript
// æ•°æ®åº“é€‚é…å™¨
// src/adapters/output/persistence/lead.repository.ts

@Injectable()
export class LeadRepository implements ILeadRepositoryPort {
  constructor(
    private readonly databaseService: DatabaseService,
    private readonly leadMapper: LeadMapper,
    private readonly logger: Logger
  ) {}

  async save(lead: Lead): Promise<void> {
    try {
      const leadData = this.leadMapper.toData(lead);
      
      const query = `
        INSERT INTO leads (
          id, customer_id, status, priority, source, estimated_value,
          assigned_to, created_by, created_at, updated_at, notes
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
        ON CONFLICT (id) 
        DO UPDATE SET
          status = EXCLUDED.status,
          priority = EXCLUDED.priority,
          estimated_value = EXCLUDED.estimated_value,
          assigned_to = EXCLUDED.assigned_to,
          updated_at = EXCLUDED.updated_at,
          notes = EXCLUDED.notes
      `;

      const params = [
        leadData.id,
        leadData.customerId,
        leadData.status,
        leadData.priority,
        leadData.source,
        leadData.estimatedValue,
        leadData.assignedTo,
        leadData.createdBy,
        leadData.createdAt,
        leadData.updatedAt,
        leadData.notes,
      ];

      await this.databaseService.query(query, params);

      this.logger.log('Lead saved successfully', { leadId: lead.getId() });
    } catch (error) {
      this.logger.error('Failed to save lead', {
        leadId: lead.getId(),
        error: error.message,
      });
      throw new PersistenceError('Failed to save lead', error);
    }
  }

  async findById(id: string): Promise<Lead | null> {
    try {
      const query = `
        SELECT * FROM leads WHERE id = $1
      `;

      const result = await this.databaseService.query(query, [id]);

      if (result.rows.length === 0) {
        return null;
      }

      return this.leadMapper.toDomain(result.rows[0]);
    } catch (error) {
      this.logger.error('Failed to find lead by ID', {
        leadId: id,
        error: error.message,
      });
      throw new PersistenceError('Failed to find lead', error);
    }
  }

  async search(criteria: LeadSearchCriteria): Promise<PaginatedResult<Lead>> {
    try {
      const { query, params } = this.buildSearchQuery(criteria);
      
      const result = await this.databaseService.query(query, params);
      const leads = result.rows.map(row => this.leadMapper.toDomain(row));

      // è·å–æ€»æ•°
      const countQuery = this.buildCountQuery(criteria);
      const countResult = await this.databaseService.query(countQuery.query, countQuery.params);
      const total = parseInt(countResult.rows[0].count);

      return {
        items: leads,
        total,
        page: criteria.page || 1,
        limit: criteria.limit || 20,
        totalPages: Math.ceil(total / (criteria.limit || 20)),
      };
    } catch (error) {
      this.logger.error('Failed to search leads', {
        criteria,
        error: error.message,
      });
      throw new PersistenceError('Failed to search leads', error);
    }
  }

  private buildSearchQuery(criteria: LeadSearchCriteria): { query: string; params: any[] } {
    let query = `
      SELECT * FROM leads 
      WHERE 1=1
    `;
    const params: any[] = [];

    if (criteria.keyword) {
      query += ` AND (notes ILIKE $${params.length + 1} OR source ILIKE $${params.length + 1})`;
      params.push(`%${criteria.keyword}%`);
    }

    if (criteria.status) {
      query += ` AND status = $${params.length + 1}`;
      params.push(criteria.status);
    }

    if (criteria.priority) {
      query += ` AND priority = $${params.length + 1}`;
      params.push(criteria.priority);
    }

    if (criteria.assignedTo) {
      query += ` AND assigned_to = $${params.length + 1}`;
      params.push(criteria.assignedTo);
    }

    if (criteria.dateFrom) {
      query += ` AND created_at >= $${params.length + 1}`;
      params.push(criteria.dateFrom);
    }

    if (criteria.dateTo) {
      query += ` AND created_at <= $${params.length + 1}`;
      params.push(criteria.dateTo);
    }

    query += ` ORDER BY created_at DESC`;

    if (criteria.limit) {
      query += ` LIMIT $${params.length + 1}`;
      params.push(criteria.limit);
    }

    if (criteria.page && criteria.limit) {
      const offset = (criteria.page - 1) * criteria.limit;
      query += ` OFFSET $${params.length + 1}`;
      params.push(offset);
    }

    return { query, params };
  }

  private buildCountQuery(criteria: LeadSearchCriteria): { query: string; params: any[] } {
    let query = `
      SELECT COUNT(*) as count FROM leads 
      WHERE 1=1
    `;
    const params: any[] = [];

    // å¤åˆ¶æœç´¢æ¡ä»¶é€»è¾‘ï¼Œä½†ä¸åŒ…æ‹¬ LIMIT å’Œ OFFSET
    if (criteria.keyword) {
      query += ` AND (notes ILIKE $${params.length + 1} OR source ILIKE $${params.length + 1})`;
      params.push(`%${criteria.keyword}%`);
    }

    if (criteria.status) {
      query += ` AND status = $${params.length + 1}`;
      params.push(criteria.status);
    }

    if (criteria.priority) {
      query += ` AND priority = $${params.length + 1}`;
      params.push(criteria.priority);
    }

    if (criteria.assignedTo) {
      query += ` AND assigned_to = $${params.length + 1}`;
      params.push(criteria.assignedTo);
    }

    if (criteria.dateFrom) {
      query += ` AND created_at >= $${params.length + 1}`;
      params.push(criteria.dateFrom);
    }

    if (criteria.dateTo) {
      query += ` AND created_at <= $${params.length + 1}`;
      params.push(criteria.dateTo);
    }

    return { query, params };
  }
}

// é€šçŸ¥é€‚é…å™¨
// src/adapters/output/notification/email-notification.adapter.ts

@Injectable()
export class EmailNotificationAdapter implements INotificationPort {
  constructor(
    private readonly emailService: EmailService,
    private readonly templateService: TemplateService,
    private readonly logger: Logger
  ) {}

  async sendEmail(notification: EmailNotification): Promise<void> {
    try {
      const template = await this.templateService.getTemplate(
        notification.templateId,
        notification.language || 'zh-CN'
      );

      const renderedContent = await this.templateService.render(
        template,
        notification.data
      );

      await this.emailService.send({
        to: notification.recipients,
        subject: renderedContent.subject,
        html: renderedContent.html,
        text: renderedContent.text,
        attachments: notification.attachments,
      });

      this.logger.log('Email sent successfully', {
        recipients: notification.recipients,
        templateId: notification.templateId,
      });
    } catch (error) {
      this.logger.error('Failed to send email', {
        recipients: notification.recipients,
        error: error.message,
      });
      throw new NotificationError('Failed to send email', error);
    }
  }

  async sendSMS(notification: SMSNotification): Promise<void> {
    try {
      // SMSå‘é€é€»è¾‘
      this.logger.log('SMS sent successfully', {
        recipients: notification.recipients,
      });
    } catch (error) {
      this.logger.error('Failed to send SMS', {
        recipients: notification.recipients,
        error: error.message,
      });
      throw new NotificationError('Failed to send SMS', error);
    }
  }

  async sendPushNotification(notification: PushNotification): Promise<void> {
    try {
      // æ¨é€é€šçŸ¥é€»è¾‘
      this.logger.log('Push notification sent successfully', {
        recipients: notification.recipients,
      });
    } catch (error) {
      this.logger.error('Failed to send push notification', {
        recipients: notification.recipients,
        error: error.message,
      });
      throw new NotificationError('Failed to send push notification', error);
    }
  }

  async sendWebhook(webhook: WebhookNotification): Promise<void> {
    try {
      // Webhookå‘é€é€»è¾‘
      this.logger.log('Webhook sent successfully', {
        url: webhook.url,
      });
    } catch (error) {
      this.logger.error('Failed to send webhook', {
        url: webhook.url,
        error: error.message,
      });
      throw new NotificationError('Failed to send webhook', error);
    }
  }
}

// æ”¯ä»˜é€‚é…å™¨
// src/adapters/output/payment/alipay-payment.adapter.ts

@Injectable()
export class AlipayPaymentAdapter implements IPaymentPort {
  constructor(
    private readonly alipayClient: AlipayClient,
    private readonly configService: ConfigService,
    private readonly logger: Logger
  ) {}

  async processPayment(payment: PaymentRequest): Promise<PaymentResult> {
    try {
      const alipayRequest = {
        out_trade_no: payment.orderId,
        total_amount: payment.amount.toString(),
        subject: payment.description,
        body: payment.description,
        timeout_express: '30m',
        product_code: 'QUICK_WAP_WAY',
      };

      const response = await this.alipayClient.exec('alipay.trade.wap.pay', alipayRequest);

      this.logger.log('Payment processed successfully', {
        orderId: payment.orderId,
        amount: payment.amount,
        paymentId: response.trade_no,
      });

      return {
        paymentId: response.trade_no,
        status: 'pending',
        amount: payment.amount,
        currency: payment.currency,
        paymentUrl: response.body,
        expiresAt: new Date(Date.now() + 30 * 60 * 1000), // 30åˆ†é’Ÿåè¿‡æœŸ
      };
    } catch (error) {
      this.logger.error('Failed to process payment', {
        orderId: payment.orderId,
        error: error.message,
      });
      throw new PaymentError('Failed to process payment', error);
    }
  }

  async refundPayment(refund: RefundRequest): Promise<RefundResult> {
    try {
      const alipayRequest = {
        trade_no: refund.paymentId,
        refund_amount: refund.amount.toString(),
        refund_reason: refund.reason,
        out_request_no: refund.refundId,
      };

      const response = await this.alipayClient.exec('alipay.trade.refund', alipayRequest);

      this.logger.log('Refund processed successfully', {
        paymentId: refund.paymentId,
        refundId: refund.refundId,
        amount: refund.amount,
      });

      return {
        refundId: response.out_request_no,
        status: response.code === '10000' ? 'success' : 'failed',
        amount: refund.amount,
        processedAt: new Date(),
      };
    } catch (error) {
      this.logger.error('Failed to process refund', {
        paymentId: refund.paymentId,
        error: error.message,
      });
      throw new PaymentError('Failed to process refund', error);
    }
  }

  async getPaymentStatus(paymentId: string): Promise<PaymentStatus> {
    try {
      const alipayRequest = {
        trade_no: paymentId,
      };

      const response = await this.alipayClient.exec('alipay.trade.query', alipayRequest);

      const statusMap = {
        'WAIT_BUYER_PAY': 'pending',
        'TRADE_SUCCESS': 'success',
        'TRADE_FINISHED': 'success',
        'TRADE_CLOSED': 'failed',
      };

      return {
        paymentId,
        status: statusMap[response.trade_status] || 'unknown',
        amount: parseFloat(response.total_amount),
        paidAt: response.send_pay_date ? new Date(response.send_pay_date) : undefined,
      };
    } catch (error) {
      this.logger.error('Failed to get payment status', {
        paymentId,
        error: error.message,
      });
      throw new PaymentError('Failed to get payment status', error);
    }
  }

  async validatePaymentMethod(method: PaymentMethod): Promise<boolean> {
    // éªŒè¯æ”¯ä»˜æ–¹å¼é€»è¾‘
    return method.type === 'alipay';
  }
}
```

---

## ğŸ’¼ åº”ç”¨æ ¸å¿ƒè®¾è®¡

### 1. ç”¨ä¾‹å®ç°

```typescript
// çº¿ç´¢ç®¡ç†ç”¨ä¾‹
// src/application/use-cases/lead-management.use-case.ts

@Injectable()
export class LeadManagementUseCase implements ILeadManagementPort {
  constructor(
    private readonly leadRepository: ILeadRepositoryPort,
    private readonly customerRepository: ICustomerRepositoryPort,
    private readonly eventPublisher: IEventPublisherPort,
    private readonly notificationPort: INotificationPort,
    private readonly logger: Logger
  ) {}

  async createLead(command: CreateLeadCommand): Promise<LeadDto> {
    try {
      // éªŒè¯å®¢æˆ·æ˜¯å¦å­˜åœ¨
      const customer = await this.customerRepository.findById(command.customerId);
      if (!customer) {
        throw new DomainError('Customer not found');
      }

      // åˆ›å»ºçº¿ç´¢èšåˆ
      const lead = Lead.create(
        command.customerId,
        command.priority,
        command.source,
        command.estimatedValue,
        command.assignedTo,
        command.createdBy,
        command.notes
      );

      // ä¿å­˜çº¿ç´¢
      await this.leadRepository.save(lead);

      // å‘å¸ƒé¢†åŸŸäº‹ä»¶
      const events = lead.getUncommittedEvents();
      for (const event of events) {
        await this.eventPublisher.publishDomainEvent(event);
      }
      lead.markEventsAsCommitted();

      // å‘é€é€šçŸ¥
      if (command.assignedTo) {
        await this.sendLeadAssignmentNotification(lead, command.assignedTo);
      }

      this.logger.log('Lead created successfully', {
        leadId: lead.getId(),
        customerId: command.customerId,
      });

      return LeadMapper.toDto(lead);
    } catch (error) {
      this.logger.error('Failed to create lead', {
        customerId: command.customerId,
        error: error.message,
      });
      throw error;
    }
  }

  async assignLead(command: AssignLeadCommand): Promise<void> {
    try {
      // è·å–çº¿ç´¢
      const lead = await this.leadRepository.findById(command.leadId);
      if (!lead) {
        throw new DomainError('Lead not found');
      }

      // åˆ†é…çº¿ç´¢
      lead.assignTo(command.assignedTo, command.assignedBy, command.reason);

      // ä¿å­˜æ›´æ–°
      await this.leadRepository.save(lead);

      // å‘å¸ƒäº‹ä»¶
      const events = lead.getUncommittedEvents();
      for (const event of events) {
        await this.eventPublisher.publishDomainEvent(event);
      }
      lead.markEventsAsCommitted();

      // å‘é€é€šçŸ¥
      await this.sendLeadAssignmentNotification(lead, command.assignedTo);

      this.logger.log('Lead assigned successfully', {
        leadId: command.leadId,
        assignedTo: command.assignedTo,
      });
    } catch (error) {
      this.logger.error('Failed to assign lead', {
        leadId: command.leadId,
        error: error.message,
      });
      throw error;
    }
  }

  async convertLead(command: ConvertLeadCommand): Promise<OrderDto> {
    try {
      // è·å–çº¿ç´¢
      const lead = await this.leadRepository.findById(command.leadId);
      if (!lead) {
        throw new DomainError('Lead not found');
      }

      // è·å–å®¢æˆ·ä¿¡æ¯
      const customer = await this.customerRepository.findById(lead.getCustomerId());
      if (!customer) {
        throw new DomainError('Customer not found');
      }

      // åˆ›å»ºè®¢å•
      const order = Order.create(
        customer.getId(),
        command.salesPersonId,
        command.items,
        command.deliveryAddress,
        command.notes,
        lead.getId()
      );

      // è½¬åŒ–çº¿ç´¢
      lead.convertToOrder(order.getId(), command.salesPersonId);

      // ä¿å­˜æ›´æ–°
      await this.leadRepository.save(lead);
      await this.orderRepository.save(order);

      // å‘å¸ƒäº‹ä»¶
      const leadEvents = lead.getUncommittedEvents();
      const orderEvents = order.getUncommittedEvents();
      
      for (const event of [...leadEvents, ...orderEvents]) {
        await this.eventPublisher.publishDomainEvent(event);
      }
      
      lead.markEventsAsCommitted();
      order.markEventsAsCommitted();

      this.logger.log('Lead converted successfully', {
        leadId: command.leadId,
        orderId: order.getId(),
      });

      return OrderMapper.toDto(order);
    } catch (error) {
      this.logger.error('Failed to convert lead', {
        leadId: command.leadId,
        error: error.message,
      });
      throw error;
    }
  }

  async getLeadById(leadId: string): Promise<LeadDto> {
    try {
      const lead = await this.leadRepository.findById(leadId);
      if (!lead) {
        throw new DomainError('Lead not found');
      }

      return LeadMapper.toDto(lead);
    } catch (error) {
      this.logger.error('Failed to get lead', {
        leadId,
        error: error.message,
      });
      throw error;
    }
  }

  async searchLeads(query: SearchLeadsQuery): Promise<PaginatedResult<LeadDto>> {
    try {
      const criteria = new LeadSearchCriteria(
        query.keyword,
        query.status,
        query.priority,
        query.source,
        query.assignedTo,
        query.dateFrom,
        query.dateTo,
        query.page,
        query.limit
      );

      const result = await this.leadRepository.search(criteria);

      return {
        items: result.items.map(lead => LeadMapper.toDto(lead)),
        total: result.total,
        page: result.page,
        limit: result.limit,
        totalPages: result.totalPages,
      };
    } catch (error) {
      this.logger.error('Failed to search leads', {
        query,
        error: error.message,
      });
      throw error;
    }
  }

  private async sendLeadAssignmentNotification(
    lead: Lead,
    assignedTo: string
  ): Promise<void> {
    try {
      const notification = new EmailNotification(
        [assignedTo],
        'lead_assignment',
        {
          leadId: lead.getId(),
          customerName: 'Customer Name', // éœ€è¦ä»å®¢æˆ·ä¿¡æ¯è·å–
          priority: lead.getPriority(),
          estimatedValue: lead.getEstimatedValue(),
        }
      );

      await this.notificationPort.sendEmail(notification);
    } catch (error) {
      this.logger.error('Failed to send lead assignment notification', {
        leadId: lead.getId(),
        assignedTo,
        error: error.message,
      });
      // ä¸æŠ›å‡ºé”™è¯¯ï¼Œé¿å…å½±å“ä¸»æµç¨‹
    }
  }
}
```

### 2. é¢†åŸŸæœåŠ¡

```typescript
// çº¿ç´¢è½¬åŒ–é¢†åŸŸæœåŠ¡
// src/domain/services/lead-conversion.service.ts

@Injectable()
export class LeadConversionService {
  constructor(
    private readonly leadRepository: ILeadRepositoryPort,
    private readonly customerRepository: ICustomerRepositoryPort,
    private readonly pricingService: PricingService,
    private readonly logger: Logger
  ) {}

  async calculateConversionProbability(leadId: string): Promise<number> {
    const lead = await this.leadRepository.findById(leadId);
    if (!lead) {
      throw new DomainError('Lead not found');
    }

    const customer = await this.customerRepository.findById(lead.getCustomerId());
    if (!customer) {
      throw new DomainError('Customer not found');
    }

    // åŸºäºå¤šä¸ªå› ç´ è®¡ç®—è½¬åŒ–æ¦‚ç‡
    let probability = 0.5; // åŸºç¡€æ¦‚ç‡

    // çº¿ç´¢ä¼˜å…ˆçº§å½±å“
    switch (lead.getPriority()) {
      case LeadPriority.URGENT:
        probability += 0.3;
        break;
      case LeadPriority.HIGH:
        probability += 0.2;
        break;
      case LeadPriority.MEDIUM:
        probability += 0.1;
        break;
      default:
        break;
    }

    // çº¿ç´¢æ¥æºå½±å“
    const sourceWeights = {
      'referral': 0.25,
      'website': 0.15,
      'social_media': 0.1,
      'cold_call': 0.05,
    };
    probability += sourceWeights[lead.getSource()] || 0;

    // å®¢æˆ·å†å²è®¢å•å½±å“
    const customerOrders = await this.getCustomerOrderHistory(customer.getId());
    if (customerOrders.length > 0) {
      probability += 0.2; // è€å®¢æˆ·è½¬åŒ–ç‡æ›´é«˜
    }

    // è·Ÿè¿›æ¬¡æ•°å½±å“
    const followUpCount = lead.getFollowUps().length;
    probability += Math.min(followUpCount * 0.05, 0.2);

    // ç¡®ä¿æ¦‚ç‡åœ¨0-1ä¹‹é—´
    return Math.min(Math.max(probability, 0), 1);
  }

  async suggestOptimalTiming(leadId: string): Promise<Date> {
    const lead = await this.leadRepository.findById(leadId);
    if (!lead) {
      throw new DomainError('Lead not found');
    }

    // åŸºäºçº¿ç´¢åˆ›å»ºæ—¶é—´å’Œè·Ÿè¿›å†å²å»ºè®®æœ€ä½³è”ç³»æ—¶é—´
    const lastFollowUp = lead.getFollowUps()
      .sort((a, b) => b.followUpDate.getTime() - a.followUpDate.getTime())[0];

    if (lastFollowUp) {
      // å¦‚æœæœ‰è·Ÿè¿›è®°å½•ï¼Œå»ºè®®åœ¨ä¸Šæ¬¡è·Ÿè¿›å3-5å¤©è”ç³»
      const daysSinceLastFollowUp = Math.floor(
        (Date.now() - lastFollowUp.followUpDate.getTime()) / (1000 * 60 * 60 * 24)
      );

      if (daysSinceLastFollowUp >= 3) {
        return new Date(); // ç«‹å³è”ç³»
      } else {
        return new Date(Date.now() + (3 - daysSinceLastFollowUp) * 24 * 60 * 60 * 1000);
      }
    } else {
      // å¦‚æœæ²¡æœ‰è·Ÿè¿›è®°å½•ï¼Œå»ºè®®åœ¨åˆ›å»ºå24å°æ—¶å†…è”ç³»
      const hoursSinceCreation = Math.floor(
        (Date.now() - lead.getCreatedAt().getTime()) / (1000 * 60 * 60)
      );

      if (hoursSinceCreation >= 24) {
        return new Date(); // ç«‹å³è”ç³»
      } else {
        return new Date(Date.now() + (24 - hoursSinceCreation) * 60 * 60 * 1000);
      }
    }
  }

  private async getCustomerOrderHistory(customerId: string): Promise<any[]> {
    // è·å–å®¢æˆ·å†å²è®¢å•
    // è¿™é‡Œéœ€è¦è°ƒç”¨è®¢å•ä»“å‚¨
    return [];
  }
}

// å®šä»·é¢†åŸŸæœåŠ¡
// src/domain/services/pricing.service.ts

@Injectable()
export class PricingService {
  constructor(
    private readonly configService: ConfigService,
    private readonly logger: Logger
  ) {}

  calculateOrderTotal(items: OrderItem[], customer: Customer): number {
    let total = 0;

    for (const item of items) {
      let itemPrice = item.unitPrice * item.quantity;

      // åº”ç”¨äº§å“æŠ˜æ‰£
      if (item.discountPercentage > 0) {
        itemPrice *= (1 - item.discountPercentage / 100);
      }

      total += itemPrice;
    }

    // åº”ç”¨å®¢æˆ·çº§åˆ«æŠ˜æ‰£
    const customerDiscount = this.getCustomerDiscount(customer);
    if (customerDiscount > 0) {
      total *= (1 - customerDiscount / 100);
    }

    // åº”ç”¨æ‰¹é‡æŠ˜æ‰£
    const volumeDiscount = this.getVolumeDiscount(total);
    if (volumeDiscount > 0) {
      total *= (1 - volumeDiscount / 100);
    }

    return Math.round(total * 100) / 100; // ä¿ç•™ä¸¤ä½å°æ•°
  }

  private getCustomerDiscount(customer: Customer): number {
    // æ ¹æ®å®¢æˆ·ç­‰çº§è¿”å›æŠ˜æ‰£
    const discountMap = {
      'vip': 10,
      'gold': 5,
      'silver': 2,
      'bronze': 0,
    };

    return discountMap[customer.getLevel()] || 0;
  }

  private getVolumeDiscount(total: number): number {
    // æ ¹æ®è®¢å•é‡‘é¢è¿”å›æ‰¹é‡æŠ˜æ‰£
    if (total >= 100000) return 15; // 10ä¸‡ä»¥ä¸Š15%æŠ˜æ‰£
    if (total >= 50000) return 10;  // 5ä¸‡ä»¥ä¸Š10%æŠ˜æ‰£
    if (total >= 20000) return 5;   // 2ä¸‡ä»¥ä¸Š5%æŠ˜æ‰£
    return 0;
  }
}
```

---

## ğŸ”§ ä¾èµ–æ³¨å…¥é…ç½®

### 1. å®¹å™¨é…ç½®

```typescript
// ä¾èµ–æ³¨å…¥å®¹å™¨é…ç½®
// src/infrastructure/di/container.config.ts

import { Container } from 'inversify';
import { TYPES } from './types';

// è¾“å…¥ç«¯å£
import { ILeadManagementPort } from '../application/ports/input/lead-management.port';
import { IOrderManagementPort } from '../application/ports/input/order-management.port';
import { ICustomerManagementPort } from '../application/ports/input/customer-management.port';
import { IAnalyticsPort } from '../application/ports/input/analytics.port';

// è¾“å‡ºç«¯å£
import { ILeadRepositoryPort } from '../application/ports/output/persistence.port';
import { IOrderRepositoryPort } from '../application/ports/output/persistence.port';
import { ICustomerRepositoryPort } from '../application/ports/output/persistence.port';
import { INotificationPort } from '../application/ports/output/external-systems.port';
import { IPaymentPort } from '../application/ports/output/external-systems.port';
import { ICRMIntegrationPort } from '../application/ports/output/external-systems.port';
import { IEventPublisherPort } from '../application/ports/output/event-publisher.port';
import { ICachePort } from '../application/ports/output/cache.port';

// ç”¨ä¾‹å®ç°
import { LeadManagementUseCase } from '../application/use-cases/lead-management.use-case';
import { OrderManagementUseCase } from '../application/use-cases/order-management.use-case';
import { CustomerManagementUseCase } from '../application/use-cases/customer-management.use-case';
import { AnalyticsUseCase } from '../application/use-cases/analytics.use-case';

// é€‚é…å™¨å®ç°
import { LeadRepository } from '../adapters/output/persistence/lead.repository';
import { OrderRepository } from '../adapters/output/persistence/order.repository';
import { CustomerRepository } from '../adapters/output/persistence/customer.repository';
import { EmailNotificationAdapter } from '../adapters/output/notification/email-notification.adapter';
import { AlipayPaymentAdapter } from '../adapters/output/payment/alipay-payment.adapter';
import { SalesforceCRMAdapter } from '../adapters/output/crm/salesforce-crm.adapter';
import { RedisEventPublisher } from '../adapters/output/events/redis-event-publisher';
import { RedisCacheAdapter } from '../adapters/output/cache/redis-cache.adapter';

// é¢†åŸŸæœåŠ¡
import { LeadConversionService } from '../domain/services/lead-conversion.service';
import { PricingService } from '../domain/services/pricing.service';

const container = new Container();

// ç»‘å®šè¾“å…¥ç«¯å£åˆ°ç”¨ä¾‹å®ç°
container.bind<ILeadManagementPort>(TYPES.LeadManagementPort).to(LeadManagementUseCase);
container.bind<IOrderManagementPort>(TYPES.OrderManagementPort).to(OrderManagementUseCase);
container.bind<ICustomerManagementPort>(TYPES.CustomerManagementPort).to(CustomerManagementUseCase);
container.bind<IAnalyticsPort>(TYPES.AnalyticsPort).to(AnalyticsUseCase);

// ç»‘å®šè¾“å‡ºç«¯å£åˆ°é€‚é…å™¨å®ç°
container.bind<ILeadRepositoryPort>(TYPES.LeadRepositoryPort).to(LeadRepository);
container.bind<IOrderRepositoryPort>(TYPES.OrderRepositoryPort).to(OrderRepository);
container.bind<ICustomerRepositoryPort>(TYPES.CustomerRepositoryPort).to(CustomerRepository);
container.bind<INotificationPort>(TYPES.NotificationPort).to(EmailNotificationAdapter);
container.bind<IPaymentPort>(TYPES.PaymentPort).to(AlipayPaymentAdapter);
container.bind<ICRMIntegrationPort>(TYPES.CRMIntegrationPort).to(SalesforceCRMAdapter);
container.bind<IEventPublisherPort>(TYPES.EventPublisherPort).to(RedisEventPublisher);
container.bind<ICachePort>(TYPES.CachePort).to(RedisCacheAdapter);

// ç»‘å®šé¢†åŸŸæœåŠ¡
container.bind<LeadConversionService>(TYPES.LeadConversionService).to(LeadConversionService);
container.bind<PricingService>(TYPES.PricingService).to(PricingService);

export { container };

// ç±»å‹å®šä¹‰
// src/infrastructure/di/types.ts

export const TYPES = {
  // è¾“å…¥ç«¯å£
  LeadManagementPort: Symbol.for('LeadManagementPort'),
  OrderManagementPort: Symbol.for('OrderManagementPort'),
  CustomerManagementPort: Symbol.for('CustomerManagementPort'),
  AnalyticsPort: Symbol.for('AnalyticsPort'),

  // è¾“å‡ºç«¯å£
  LeadRepositoryPort: Symbol.for('LeadRepositoryPort'),
  OrderRepositoryPort: Symbol.for('OrderRepositoryPort'),
  CustomerRepositoryPort: Symbol.for('CustomerRepositoryPort'),
  NotificationPort: Symbol.for('NotificationPort'),
  PaymentPort: Symbol.for('PaymentPort'),
  CRMIntegrationPort: Symbol.for('CRMIntegrationPort'),
  EventPublisherPort: Symbol.for('EventPublisherPort'),
  CachePort: Symbol.for('CachePort'),

  // é¢†åŸŸæœåŠ¡
  LeadConversionService: Symbol.for('LeadConversionService'),
  PricingService: Symbol.for('PricingService'),

  // åŸºç¡€è®¾æ–½
  DatabaseService: Symbol.for('DatabaseService'),
  ConfigService: Symbol.for('ConfigService'),
  Logger: Symbol.for('Logger'),
};
```

### 2. NestJSæ¨¡å—é…ç½®

```typescript
// NestJSæ¨¡å—é…ç½®
// src/infrastructure/modules/hexagonal.module.ts

import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';

// æ§åˆ¶å™¨
import { LeadManagementController } from '../adapters/input/web/lead-management.controller';
import { OrderManagementController } from '../adapters/input/web/order-management.controller';
import { CustomerManagementController } from '../adapters/input/web/customer-management.controller';

// ç”¨ä¾‹
import { LeadManagementUseCase } from '../application/use-cases/lead-management.use-case';
import { OrderManagementUseCase } from '../application/use-cases/order-management.use-case';
import { CustomerManagementUseCase } from '../application/use-cases/customer-management.use-case';

// é€‚é…å™¨
import { LeadRepository } from '../adapters/output/persistence/lead.repository';
import { OrderRepository } from '../adapters/output/persistence/order.repository';
import { CustomerRepository } from '../adapters/output/persistence/customer.repository';
import { EmailNotificationAdapter } from '../adapters/output/notification/email-notification.adapter';
import { AlipayPaymentAdapter } from '../adapters/output/payment/alipay-payment.adapter';

// ç«¯å£ä»¤ç‰Œ
import { LEAD_MANAGEMENT_PORT } from '../application/ports/input/lead-management.port';
import { ORDER_MANAGEMENT_PORT } from '../application/ports/input/order-management.port';
import { CUSTOMER_MANAGEMENT_PORT } from '../application/ports/input/customer-management.port';
import { LEAD_REPOSITORY_PORT } from '../application/ports/output/persistence.port';
import { ORDER_REPOSITORY_PORT } from '../application/ports/output/persistence.port';
import { CUSTOMER_REPOSITORY_PORT } from '../application/ports/output/persistence.port';
import { NOTIFICATION_PORT } from '../application/ports/output/external-systems.port';
import { PAYMENT_PORT } from '../application/ports/output/external-systems.port';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
    }),
  ],
  controllers: [
    LeadManagementController,
    OrderManagementController,
    CustomerManagementController,
  ],
  providers: [
    // ç”¨ä¾‹æä¾›è€…
    {
      provide: LEAD_MANAGEMENT_PORT,
      useClass: LeadManagementUseCase,
    },
    {
      provide: ORDER_MANAGEMENT_PORT,
      useClass: OrderManagementUseCase,
    },
    {
      provide: CUSTOMER_MANAGEMENT_PORT,
      useClass: CustomerManagementUseCase,
    },

    // ä»“å‚¨æä¾›è€…
    {
      provide: LEAD_REPOSITORY_PORT,
      useClass: LeadRepository,
    },
    {
      provide: ORDER_REPOSITORY_PORT,
      useClass: OrderRepository,
    },
    {
      provide: CUSTOMER_REPOSITORY_PORT,
      useClass: CustomerRepository,
    },

    // å¤–éƒ¨ç³»ç»Ÿé€‚é…å™¨æä¾›è€…
    {
      provide: NOTIFICATION_PORT,
      useClass: EmailNotificationAdapter,
    },
    {
      provide: PAYMENT_PORT,
      useClass: AlipayPaymentAdapter,
    },

    // é¢†åŸŸæœåŠ¡
    LeadConversionService,
    PricingService,
  ],
  exports: [
    LEAD_MANAGEMENT_PORT,
    ORDER_MANAGEMENT_PORT,
    CUSTOMER_MANAGEMENT_PORT,
  ],
})
export class HexagonalModule {}
```

---

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### 1. å•å…ƒæµ‹è¯•

```typescript
// ç”¨ä¾‹å•å…ƒæµ‹è¯•
// src/application/use-cases/__tests__/lead-management.use-case.spec.ts

import { Test, TestingModule } from '@nestjs/testing';
import { LeadManagementUseCase } from '../lead-management.use-case';
import { ILeadRepositoryPort } from '../../ports/output/persistence.port';
import { ICustomerRepositoryPort } from '../../ports/output/persistence.port';
import { IEventPublisherPort } from '../../ports/output/event-publisher.port';
import { INotificationPort } from '../../ports/output/external-systems.port';
import { CreateLeadCommand } from '../../commands/create-lead.command';
import { Lead } from '../../../domain/entities/lead.entity';
import { Customer } from '../../../domain/entities/customer.entity';
import { DomainError } from '../../../domain/errors/domain.error';

describe('LeadManagementUseCase', () => {
  let useCase: LeadManagementUseCase;
  let leadRepository: jest.Mocked<ILeadRepositoryPort>;
  let customerRepository: jest.Mocked<ICustomerRepositoryPort>;
  let eventPublisher: jest.Mocked<IEventPublisherPort>;
  let notificationPort: jest.Mocked<INotificationPort>;

  beforeEach(async () => {
    const leadRepositoryMock = {
      save: jest.fn(),
      findById: jest.fn(),
      findByCustomerId: jest.fn(),
      search: jest.fn(),
      delete: jest.fn(),
      exists: jest.fn(),
    };

    const customerRepositoryMock = {
      save: jest.fn(),
      findById: jest.fn(),
      findByEmail: jest.fn(),
      findByPhone: jest.fn(),
      search: jest.fn(),
      delete: jest.fn(),
    };

    const eventPublisherMock = {
      publishDomainEvent: jest.fn(),
      publishIntegrationEvent: jest.fn(),
      publishBatch: jest.fn(),
    };

    const notificationPortMock = {
      sendEmail: jest.fn(),
      sendSMS: jest.fn(),
      sendPushNotification: jest.fn(),
      sendWebhook: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        LeadManagementUseCase,
        {
          provide: 'ILeadRepositoryPort',
          useValue: leadRepositoryMock,
        },
        {
          provide: 'ICustomerRepositoryPort',
          useValue: customerRepositoryMock,
        },
        {
          provide: 'IEventPublisherPort',
          useValue: eventPublisherMock,
        },
        {
          provide: 'INotificationPort',
          useValue: notificationPortMock,
        },
        {
          provide: 'Logger',
          useValue: { log: jest.fn(), error: jest.fn() },
        },
      ],
    }).compile();

    useCase = module.get<LeadManagementUseCase>(LeadManagementUseCase);
    leadRepository = module.get('ILeadRepositoryPort');
    customerRepository = module.get('ICustomerRepositoryPort');
    eventPublisher = module.get('IEventPublisherPort');
    notificationPort = module.get('INotificationPort');
  });

  describe('createLead', () => {
    it('should create a lead successfully', async () => {
      // Arrange
      const customerId = 'customer-123';
      const command = new CreateLeadCommand(
        customerId,
        'HIGH',
        'website',
        50000,
        'sales-person-123',
        'user-123',
        'Test lead'
      );

      const customer = Customer.create(
        'John Doe',
        'john@example.com',
        '+1234567890',
        'Company Inc'
      );

      customerRepository.findById.mockResolvedValue(customer);
      leadRepository.save.mockResolvedValue(undefined);
      eventPublisher.publishDomainEvent.mockResolvedValue(undefined);
      notificationPort.sendEmail.mockResolvedValue(undefined);

      // Act
      const result = await useCase.createLead(command);

      // Assert
      expect(customerRepository.findById).toHaveBeenCalledWith(customerId);
      expect(leadRepository.save).toHaveBeenCalled();
      expect(eventPublisher.publishDomainEvent).toHaveBeenCalled();
      expect(notificationPort.sendEmail).toHaveBeenCalled();
      expect(result).toBeDefined();
      expect(result.customerId).toBe(customerId);
    });

    it('should throw error when customer not found', async () => {
      // Arrange
      const command = new CreateLeadCommand(
        'non-existent-customer',
        'HIGH',
        'website',
        50000,
        'sales-person-123',
        'user-123',
        'Test lead'
      );

      customerRepository.findById.mockResolvedValue(null);

      // Act & Assert
      await expect(useCase.createLead(command)).rejects.toThrow(DomainError);
      expect(customerRepository.findById).toHaveBeenCalled();
      expect(leadRepository.save).not.toHaveBeenCalled();
    });
  });

  describe('assignLead', () => {
    it('should assign lead successfully', async () => {
      // Arrange
      const leadId = 'lead-123';
      const assignedTo = 'sales-person-456';
      const command = new AssignLeadCommand(
        leadId,
        assignedTo,
        'manager-123',
        'Reassignment for better coverage'
      );

      const lead = Lead.create(
        'customer-123',
        'MEDIUM',
        'referral',
        30000,
        'sales-person-123',
        'user-123',
        'Existing lead'
      );

      leadRepository.findById.mockResolvedValue(lead);
      leadRepository.save.mockResolvedValue(undefined);
      eventPublisher.publishDomainEvent.mockResolvedValue(undefined);
      notificationPort.sendEmail.mockResolvedValue(undefined);

      // Act
      await useCase.assignLead(command);

      // Assert
      expect(leadRepository.findById).toHaveBeenCalledWith(leadId);
      expect(leadRepository.save).toHaveBeenCalled();
      expect(eventPublisher.publishDomainEvent).toHaveBeenCalled();
      expect(notificationPort.sendEmail).toHaveBeenCalled();
    });

    it('should throw error when lead not found', async () => {
      // Arrange
      const command = new AssignLeadCommand(
        'non-existent-lead',
        'sales-person-456',
        'manager-123',
        'Reassignment'
      );

      leadRepository.findById.mockResolvedValue(null);

      // Act & Assert
      await expect(useCase.assignLead(command)).rejects.toThrow(DomainError);
      expect(leadRepository.findById).toHaveBeenCalled();
      expect(leadRepository.save).not.toHaveBeenCalled();
    });
  });
});
```

### 2. é›†æˆæµ‹è¯•

```typescript
// é€‚é…å™¨é›†æˆæµ‹è¯•
// src/adapters/output/persistence/__tests__/lead.repository.integration.spec.ts

import { Test, TestingModule } from '@nestjs/testing';
import { LeadRepository } from '../lead.repository';
import { DatabaseService } from '../../../infrastructure/database/database.service';
import { LeadMapper } from '../mappers/lead.mapper';
import { Lead } from '../../../../domain/entities/lead.entity';
import { LeadSearchCriteria } from '../../../../domain/criteria/lead-search.criteria';

describe('LeadRepository Integration', () => {
  let repository: LeadRepository;
  let databaseService: DatabaseService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        LeadRepository,
        {
          provide: DatabaseService,
          useValue: {
            query: jest.fn(),
          },
        },
        {
          provide: LeadMapper,
          useValue: {
            toData: jest.fn(),
            toDomain: jest.fn(),
          },
        },
        {
          provide: 'Logger',
          useValue: { log: jest.fn(), error: jest.fn() },
        },
      ],
    }).compile();

    repository = module.get<LeadRepository>(LeadRepository);
    databaseService = module.get<DatabaseService>(DatabaseService);
  });

  describe('save', () => {
    it('should save lead to database', async () => {
      // Arrange
      const lead = Lead.create(
        'customer-123',
        'HIGH',
        'website',
        50000,
        'sales-person-123',
        'user-123',
        'Test lead'
      );

      const leadData = {
        id: lead.getId(),
        customerId: 'customer-123',
        status: 'NEW',
        priority: 'HIGH',
        source: 'website',
        estimatedValue: 50000,
        assignedTo: 'sales-person-123',
        createdBy: 'user-123',
        createdAt: lead.getCreatedAt(),
        updatedAt: lead.getUpdatedAt(),
        notes: 'Test lead',
      };

      jest.spyOn(repository['leadMapper'], 'toData').mockReturnValue(leadData);
      jest.spyOn(databaseService, 'query').mockResolvedValue({ rows: [] });

      // Act
      await repository.save(lead);

      // Assert
      expect(databaseService.query).toHaveBeenCalledWith(
        expect.stringContaining('INSERT INTO leads'),
        expect.arrayContaining([
          leadData.id,
          leadData.customerId,
          leadData.status,
          leadData.priority,
          leadData.source,
          leadData.estimatedValue,
          leadData.assignedTo,
          leadData.createdBy,
          leadData.createdAt,
          leadData.updatedAt,
          leadData.notes,
        ])
      );
    });
  });

  describe('findById', () => {
    it('should return lead when found', async () => {
      // Arrange
      const leadId = 'lead-123';
      const leadData = {
        id: leadId,
        customer_id: 'customer-123',
        status: 'NEW',
        priority: 'HIGH',
        source: 'website',
        estimated_value: 50000,
        assigned_to: 'sales-person-123',
        created_by: 'user-123',
        created_at: new Date(),
        updated_at: new Date(),
        notes: 'Test lead',
      };

      const lead = Lead.create(
        'customer-123',
        'HIGH',
        'website',
        50000,
        'sales-person-123',
        'user-123',
        'Test lead'
      );

      jest.spyOn(databaseService, 'query').mockResolvedValue({
        rows: [leadData],
      });
      jest.spyOn(repository['leadMapper'], 'toDomain').mockReturnValue(lead);

      // Act
      const result = await repository.findById(leadId);

      // Assert
      expect(databaseService.query).toHaveBeenCalledWith(
        'SELECT * FROM leads WHERE id = $1',
        [leadId]
      );
      expect(result).toBe(lead);
    });

    it('should return null when lead not found', async () => {
      // Arrange
      const leadId = 'non-existent-lead';

      jest.spyOn(databaseService, 'query').mockResolvedValue({
        rows: [],
      });

      // Act
      const result = await repository.findById(leadId);

      // Assert
      expect(result).toBeNull();
    });
  });
});
```

### 3. ç«¯åˆ°ç«¯æµ‹è¯•

```typescript
// ç«¯åˆ°ç«¯æµ‹è¯•
// src/__tests__/e2e/lead-management.e2e.spec.ts

import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from '../../app.module';
import { DatabaseService } from '../../infrastructure/database/database.service';

describe('Lead Management E2E', () => {
  let app: INestApplication;
  let databaseService: DatabaseService;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    databaseService = moduleFixture.get<DatabaseService>(DatabaseService);
    
    await app.init();
    
    // æ¸…ç†æµ‹è¯•æ•°æ®
    await databaseService.query('DELETE FROM leads WHERE created_by = $1', ['test-user']);
    await databaseService.query('DELETE FROM customers WHERE created_by = $1', ['test-user']);
  });

  afterEach(async () => {
    // æ¸…ç†æµ‹è¯•æ•°æ®
    await databaseService.query('DELETE FROM leads WHERE created_by = $1', ['test-user']);
    await databaseService.query('DELETE FROM customers WHERE created_by = $1', ['test-user']);
    
    await app.close();
  });

  describe('/api/leads (POST)', () => {
    it('should create a new lead', async () => {
      // é¦–å…ˆåˆ›å»ºä¸€ä¸ªå®¢æˆ·
      const customerResponse = await request(app.getHttpServer())
        .post('/api/customers')
        .send({
          name: 'Test Customer',
          email: 'test@example.com',
          phone: '+1234567890',
          company: 'Test Company',
        })
        .expect(201);

      const customerId = customerResponse.body.data.id;

      // åˆ›å»ºçº¿ç´¢
      const leadData = {
        customerId,
        priority: 'HIGH',
        source: 'website',
        estimatedValue: 50000,
        notes: 'Test lead from E2E test',
      };

      const response = await request(app.getHttpServer())
        .post('/api/leads')
        .send(leadData)
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data).toBeDefined();
      expect(response.body.data.customerId).toBe(customerId);
      expect(response.body.data.priority).toBe('HIGH');
      expect(response.body.data.source).toBe('website');
      expect(response.body.data.estimatedValue).toBe(50000);
    });

    it('should return 400 when customer not found', async () => {
      const leadData = {
        customerId: 'non-existent-customer',
        priority: 'HIGH',
        source: 'website',
        estimatedValue: 50000,
        notes: 'Test lead',
      };

      await request(app.getHttpServer())
        .post('/api/leads')
        .send(leadData)
        .expect(400);
    });
  });

  describe('/api/leads/:id (GET)', () => {
    it('should get lead by id', async () => {
      // åˆ›å»ºå®¢æˆ·å’Œçº¿ç´¢
      const customerResponse = await request(app.getHttpServer())
        .post('/api/customers')
        .send({
          name: 'Test Customer',
          email: 'test@example.com',
          phone: '+1234567890',
          company: 'Test Company',
        });

      const customerId = customerResponse.body.data.id;

      const leadResponse = await request(app.getHttpServer())
        .post('/api/leads')
        .send({
          customerId,
          priority: 'HIGH',
          source: 'website',
          estimatedValue: 50000,
          notes: 'Test lead',
        });

      const leadId = leadResponse.body.data.id;

      // è·å–çº¿ç´¢
      const response = await request(app.getHttpServer())
        .get(`/api/leads/${leadId}`)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.id).toBe(leadId);
      expect(response.body.data.customerId).toBe(customerId);
    });

    it('should return 404 when lead not found', async () => {
      await request(app.getHttpServer())
        .get('/api/leads/non-existent-lead')
        .expect(404);
    });
  });

  describe('/api/leads (GET)', () => {
    it('should search leads with filters', async () => {
      // åˆ›å»ºå¤šä¸ªçº¿ç´¢ç”¨äºæµ‹è¯•æœç´¢
      const customerResponse = await request(app.getHttpServer())
        .post('/api/customers')
        .send({
          name: 'Test Customer',
          email: 'test@example.com',
          phone: '+1234567890',
          company: 'Test Company',
        });

      const customerId = customerResponse.body.data.id;

      // åˆ›å»ºé«˜ä¼˜å…ˆçº§çº¿ç´¢
      await request(app.getHttpServer())
        .post('/api/leads')
        .send({
          customerId,
          priority: 'HIGH',
          source: 'website',
          estimatedValue: 50000,
          notes: 'High priority lead',
        });

      // åˆ›å»ºä¸­ä¼˜å…ˆçº§çº¿ç´¢
      await request(app.getHttpServer())
        .post('/api/leads')
        .send({
          customerId,
          priority: 'MEDIUM',
          source: 'referral',
          estimatedValue: 30000,
          notes: 'Medium priority lead',
        });

      // æœç´¢é«˜ä¼˜å…ˆçº§çº¿ç´¢
      const response = await request(app.getHttpServer())
        .get('/api/leads')
        .query({
          priority: 'HIGH',
          page: 1,
          limit: 10,
        })
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.items).toBeDefined();
      expect(response.body.data.items.length).toBeGreaterThan(0);
      expect(response.body.data.items[0].priority).toBe('HIGH');
    });
  });
});
```

---

## ğŸš€ éƒ¨ç½²é…ç½®

### 1. Dockeré…ç½®

```dockerfile
# å¤šé˜¶æ®µæ„å»ºDockerfile
# Dockerfile

# æ„å»ºé˜¶æ®µ
FROM node:18-alpine AS builder

WORKDIR /app

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY package*.json ./
COPY tsconfig*.json ./

# å®‰è£…ä¾èµ–
RUN npm ci --only=production && npm cache clean --force

# å¤åˆ¶æºä»£ç 
COPY src/ ./src/

# æ„å»ºåº”ç”¨
RUN npm run build

# ç”Ÿäº§é˜¶æ®µ
FROM node:18-alpine AS production

WORKDIR /app

# åˆ›å»ºérootç”¨æˆ·
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nestjs -u 1001

# å¤åˆ¶æ„å»ºäº§ç‰©å’Œä¾èµ–
COPY --from=builder --chown=nestjs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nestjs:nodejs /app/dist ./dist
COPY --from=builder --chown=nestjs:nodejs /app/package*.json ./

# åˆ‡æ¢åˆ°érootç”¨æˆ·
USER nestjs

# æš´éœ²ç«¯å£
EXPOSE 3000

# å¥åº·æ£€æŸ¥
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# å¯åŠ¨åº”ç”¨
CMD ["node", "dist/main.js"]
```

### 2. Kubernetesé…ç½®

```yaml
# Kuberneteséƒ¨ç½²é…ç½®
# k8s/deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: l2c-hexagonal-api
  namespace: l2c-system
  labels:
    app: l2c-hexagonal-api
    version: v1
spec:
  replicas: 3
  selector:
    matchLabels:
      app: l2c-hexagonal-api
  template:
    metadata:
      labels:
        app: l2c-hexagonal-api
        version: v1
    spec:
      containers:
      - name: api
        image: l2c/hexagonal-api:latest
        ports:
        - containerPort: 3000
          name: http
        env:
        - name: NODE_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: l2c-secrets
              key: database-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: l2c-secrets
              key: redis-url
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: l2c-secrets
              key: jwt-secret
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
        volumeMounts:
        - name: config
          mountPath: /app/config
          readOnly: true
      volumes:
      - name: config
        configMap:
          name: l2c-config
      imagePullSecrets:
      - name: l2c-registry-secret

---
apiVersion: v1
kind: Service
metadata:
  name: l2c-hexagonal-api-service
  namespace: l2c-system
  labels:
    app: l2c-hexagonal-api
spec:
  selector:
    app: l2c-hexagonal-api
  ports:
  - name: http
    port: 80
    targetPort: 3000
    protocol: TCP
  type: ClusterIP

---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: l2c-hexagonal-api-ingress
  namespace: l2c-system
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/use-regex: "true"
    cert-manager.io/cluster-issuer: letsencrypt-prod
spec:
  tls:
  - hosts:
    - api.l2c.example.com
    secretName: l2c-api-tls
  rules:
  - host: api.l2c.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: l2c-hexagonal-api-service
            port:
              number: 80
```

### 3. ç¯å¢ƒé…ç½®

```yaml
# é…ç½®æ˜ å°„
# k8s/configmap.yaml

apiVersion: v1
kind: ConfigMap
metadata:
  name: l2c-config
  namespace: l2c-system
data:
  application.yaml: |
    server:
      port: 3000
      cors:
        enabled: true
        origins:
          - https://app.l2c.example.com
          - https://admin.l2c.example.com
    
    database:
      type: postgresql
      host: postgres-service
      port: 5432
      database: l2c_db
      pool:
        min: 5
        max: 20
        acquireTimeoutMillis: 60000
        idleTimeoutMillis: 600000
    
    redis:
      host: redis-service
      port: 6379
      db: 0
      keyPrefix: l2c:
      ttl: 3600
    
    messaging:
      type: redis
      channels:
        events: l2c:events
        notifications: l2c:notifications
    
    external:
      crm:
        type: salesforce
        apiVersion: v52.0
        timeout: 30000
      
      payment:
        alipay:
          appId: ${ALIPAY_APP_ID}
          timeout: 30000
        
      notification:
        email:
          provider: sendgrid
          timeout: 10000
        sms:
          provider: twilio
          timeout: 5000
    
    monitoring:
      metrics:
        enabled: true
        endpoint: /metrics
      
      tracing:
        enabled: true
        jaeger:
          endpoint: http://jaeger-collector:14268/api/traces
      
      logging:
        level: info
        format: json
        destinations:
          - console
          - file

---
apiVersion: v1
kind: Secret
metadata:
  name: l2c-secrets
  namespace: l2c-system
type: Opaque
data:
  database-url: cG9zdGdyZXNxbDovL3VzZXI6cGFzc3dvcmRAcG9zdGdyZXMtc2VydmljZTo1NDMyL2wyY19kYg==
  redis-url: cmVkaXM6Ly9yZWRpcy1zZXJ2aWNlOjYzNzk=
  jwt-secret: eW91ci1qd3Qtc2VjcmV0LWtleQ==
  alipay-app-id: eW91ci1hbGlwYXktYXBwLWlk
  alipay-private-key: eW91ci1hbGlwYXktcHJpdmF0ZS1rZXk=
  sendgrid-api-key: eW91ci1zZW5kZ3JpZC1hcGkta2V5
  twilio-auth-token: eW91ci10d2lsaW8tYXV0aC10b2tlbg==
```

### 4. ç›‘æ§é…ç½®

```yaml
# Prometheusç›‘æ§é…ç½®
# k8s/monitoring.yaml

apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: l2c-hexagonal-api-monitor
  namespace: l2c-system
  labels:
    app: l2c-hexagonal-api
spec:
  selector:
    matchLabels:
      app: l2c-hexagonal-api
  endpoints:
  - port: http
    path: /metrics
    interval: 30s
    scrapeTimeout: 10s

---
apiVersion: v1
kind: Service
metadata:
  name: l2c-hexagonal-api-metrics
  namespace: l2c-system
  labels:
    app: l2c-hexagonal-api
    metrics: "true"
spec:
  selector:
    app: l2c-hexagonal-api
  ports:
  - name: metrics
    port: 3000
    targetPort: 3000
    protocol: TCP
  type: ClusterIP
```

---

## ğŸ“Š æ€»ç»“

è¿™ä¸ªå…­è¾¹å½¢æ¶æ„è®¾è®¡æ–¹æ¡ˆæä¾›äº†å®Œæ•´çš„ç«¯å£é€‚é…å™¨æ¶æ„ï¼Œå…·æœ‰ä»¥ä¸‹æ ¸å¿ƒä¼˜åŠ¿ï¼š

### ğŸ¯ æ¶æ„ä¼˜åŠ¿
- **ä¸šåŠ¡é€»è¾‘éš”ç¦»**ï¼šæ ¸å¿ƒä¸šåŠ¡é€»è¾‘å®Œå…¨ç‹¬ç«‹äºå¤–éƒ¨æŠ€æœ¯
- **é«˜åº¦å¯æµ‹è¯•**ï¼šé€šè¿‡ç«¯å£æŠ½è±¡å®ç°å…¨é¢çš„å•å…ƒæµ‹è¯•è¦†ç›–
- **æŠ€æœ¯æ— å…³æ€§**ï¼šæ”¯æŒçµæ´»åˆ‡æ¢ä¸åŒçš„æŠ€æœ¯æ ˆå’Œå¤–éƒ¨ç³»ç»Ÿ
- **æ¸…æ™°è¾¹ç•Œ**ï¼šæ˜ç¡®å®šä¹‰å†…éƒ¨å’Œå¤–éƒ¨ç³»ç»Ÿçš„äº¤äº’å¥‘çº¦

### ğŸ”§ å®ç°ç‰¹ç‚¹
- **å®Œæ•´çš„ç«¯å£å®šä¹‰**ï¼šæ¶µç›–è¾“å…¥ç«¯å£å’Œè¾“å‡ºç«¯å£çš„å…¨é¢è®¾è®¡
- **å¤šæ ·åŒ–é€‚é…å™¨**ï¼šæ”¯æŒWebã€GraphQLã€æ¶ˆæ¯é˜Ÿåˆ—ç­‰å¤šç§è¾“å…¥æ–¹å¼
- **çµæ´»çš„ä¾èµ–æ³¨å…¥**ï¼šæ”¯æŒIoCå®¹å™¨å’ŒNestJSæ¨¡å—åŒ–é…ç½®
- **å…¨é¢çš„æµ‹è¯•ç­–ç•¥**ï¼šåŒ…å«å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•å’Œç«¯åˆ°ç«¯æµ‹è¯•

### ğŸš€ éƒ¨ç½²æ”¯æŒ
- **å®¹å™¨åŒ–éƒ¨ç½²**ï¼šæä¾›å®Œæ•´çš„Dockerå’ŒKubernetesé…ç½®
- **ç¯å¢ƒé…ç½®ç®¡ç†**ï¼šæ”¯æŒé…ç½®æ˜ å°„å’Œå¯†é’¥ç®¡ç†
- **ç›‘æ§é›†æˆ**ï¼šå†…ç½®Prometheusç›‘æ§å’Œå¥åº·æ£€æŸ¥
- **æ‰©å±•æ€§è®¾è®¡**ï¼šæ”¯æŒæ°´å¹³æ‰©å±•å’Œè´Ÿè½½å‡è¡¡

è¿™ä¸ªæ¶æ„è®¾è®¡ç¡®ä¿äº†ç½—è±L2Cé”€å”®ç®¡ç†ç³»ç»Ÿå…·æœ‰é«˜åº¦çš„å¯ç»´æŠ¤æ€§ã€å¯æ‰©å±•æ€§å’Œå¯æµ‹è¯•æ€§ï¼Œä¸ºç³»ç»Ÿçš„é•¿æœŸå‘å±•å¥ å®šäº†åšå®çš„åŸºç¡€ã€‚
