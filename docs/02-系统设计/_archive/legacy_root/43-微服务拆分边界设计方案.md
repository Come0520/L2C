# æœåŠ¡æ‹†åˆ†è¾¹ç•Œè®¾è®¡æ–¹æ¡ˆ

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†é˜è¿°äº†ç½—è±L2Cé”€å”®ç®¡ç†ç³»ç»Ÿçš„æ¨¡å—åŒ–æ¶æ„æ‹†åˆ†è¾¹ç•Œè®¾è®¡æ–¹æ¡ˆï¼ŒåŸºäºé¢†åŸŸé©±åŠ¨è®¾è®¡ï¼ˆDDDï¼‰åŸåˆ™ï¼Œæ˜ç¡®å„ä¸ªæ¨¡å—çš„èŒè´£è¾¹ç•Œã€æ•°æ®è¾¹ç•Œå’Œäº¤äº’æ–¹å¼ï¼Œç¡®ä¿ç³»ç»Ÿçš„é«˜å†…èšã€ä½è€¦åˆã€‚

---

## ğŸ¯ è®¾è®¡ç›®æ ‡ä¸ä»·å€¼

### 1. æ ¸å¿ƒç›®æ ‡
- **ä¸šåŠ¡è¾¹ç•Œæ¸…æ™°**ï¼šåŸºäºä¸šåŠ¡é¢†åŸŸåˆ’åˆ†æœåŠ¡è¾¹ç•Œ
- **æ•°æ®è‡ªæ²»**ï¼šæ¯ä¸ªæœåŠ¡æ‹¥æœ‰ç‹¬ç«‹çš„æ•°æ®å­˜å‚¨
- **æŠ€æœ¯ç‹¬ç«‹**ï¼šæ”¯æŒä¸åŒæŠ€æœ¯æ ˆçš„é€‰æ‹©
- **å›¢é˜Ÿè‡ªæ²»**ï¼šæ”¯æŒç‹¬ç«‹å¼€å‘å’Œéƒ¨ç½²
- **æ‰©å±•çµæ´»**ï¼šæ”¯æŒæŒ‰éœ€æ‰©å±•ç‰¹å®šæœåŠ¡

### 2. ä¸šåŠ¡ä»·å€¼
- **å¼€å‘æ•ˆç‡æå‡**ï¼šå›¢é˜Ÿå¯ä»¥å¹¶è¡Œå¼€å‘ä¸åŒæœåŠ¡
- **ç³»ç»Ÿå¯é æ€§å¢å¼º**ï¼šæœåŠ¡æ•…éšœéš”ç¦»ï¼Œé¿å…çº§è”å¤±è´¥
- **æŠ€æœ¯æ¼”è¿›æ”¯æŒ**ï¼šæ”¯æŒæ¸è¿›å¼æŠ€æœ¯å‡çº§
- **ä¸šåŠ¡æ•æ·æ€§**ï¼šå¿«é€Ÿå“åº”ä¸šåŠ¡å˜åŒ–éœ€æ±‚

---

## ğŸ—ï¸ æœåŠ¡æ‹†åˆ†æ¶æ„

### 1. æ•´ä½“æ¶æ„å›¾

```mermaid
graph TB
    subgraph "å®¢æˆ·ç«¯å±‚"
        WebApp[Webåº”ç”¨]
        MobileApp[ç§»åŠ¨åº”ç”¨]
        AdminPanel[ç®¡ç†åå°]
    end

    subgraph "APIç½‘å…³å±‚"
        Gateway[APIç½‘å…³]
    end

    subgraph "ä¸šåŠ¡æœåŠ¡å±‚"
        subgraph "æ ¸å¿ƒä¸šåŠ¡æœåŠ¡"
            LeadService[çº¿ç´¢ç®¡ç†æœåŠ¡]
            CustomerService[å®¢æˆ·ç®¡ç†æœåŠ¡]
            OrderService[è®¢å•ç®¡ç†æœåŠ¡]
            ProductService[äº§å“ç®¡ç†æœåŠ¡]
        end

        subgraph "æ”¯æ’‘ä¸šåŠ¡æœåŠ¡"
            UserService[ç”¨æˆ·ç®¡ç†æœåŠ¡]
            NotificationService[é€šçŸ¥æœåŠ¡]
            ReportService[æŠ¥è¡¨åˆ†ææœåŠ¡]
            FileService[æ–‡ä»¶ç®¡ç†æœåŠ¡]
        end

        subgraph "åŸºç¡€è®¾æ–½æœåŠ¡"
            AuthService[è®¤è¯æˆæƒæœåŠ¡]
            ConfigService[é…ç½®ç®¡ç†æœåŠ¡]
            LogService[æ—¥å¿—æœåŠ¡]
            MonitorService[ç›‘æ§æœåŠ¡]
        end
    end

    subgraph "æ•°æ®å±‚"
        LeadDB[(çº¿ç´¢æ•°æ®åº“)]
        CustomerDB[(å®¢æˆ·æ•°æ®åº“)]
        OrderDB[(è®¢å•æ•°æ®åº“)]
        ProductDB[(äº§å“æ•°æ®åº“)]
        UserDB[(ç”¨æˆ·æ•°æ®åº“)]
        SharedCache[(å…±äº«ç¼“å­˜)]
    end

    subgraph "æ¶ˆæ¯ä¸­é—´ä»¶"
        EventBus[äº‹ä»¶æ€»çº¿]
        MessageQueue[æ¶ˆæ¯é˜Ÿåˆ—]
    end

    WebApp --> Gateway
    MobileApp --> Gateway
    AdminPanel --> Gateway

    Gateway --> LeadService
    Gateway --> CustomerService
    Gateway --> OrderService
    Gateway --> ProductService
    Gateway --> UserService
    Gateway --> NotificationService
    Gateway --> ReportService
    Gateway --> FileService

    LeadService --> LeadDB
    CustomerService --> CustomerDB
    OrderService --> OrderDB
    ProductService --> ProductDB
    UserService --> UserDB

    LeadService --> EventBus
    CustomerService --> EventBus
    OrderService --> EventBus
    ProductService --> EventBus

    NotificationService --> MessageQueue
    ReportService --> SharedCache

    AuthService --> UserDB
    ConfigService --> SharedCache
```

### 2. æœåŠ¡åˆ†å±‚æ¶æ„

```mermaid
graph LR
    subgraph "è¡¨ç°å±‚"
        API[REST API]
        GraphQL[GraphQL API]
        gRPC[gRPC API]
    end

    subgraph "åº”ç”¨å±‚"
        UseCase[ç”¨ä¾‹æœåŠ¡]
        Command[å‘½ä»¤å¤„ç†]
        Query[æŸ¥è¯¢å¤„ç†]
    end

    subgraph "é¢†åŸŸå±‚"
        Entity[å®ä½“]
        ValueObject[å€¼å¯¹è±¡]
        DomainService[é¢†åŸŸæœåŠ¡]
        Repository[ä»“å‚¨æ¥å£]
    end

    subgraph "åŸºç¡€è®¾æ–½å±‚"
        Database[æ•°æ®åº“]
        Cache[ç¼“å­˜]
        MessageBroker[æ¶ˆæ¯ä»£ç†]
        ExternalAPI[å¤–éƒ¨API]
    end

    API --> UseCase
    GraphQL --> UseCase
    gRPC --> UseCase

    UseCase --> Command
    UseCase --> Query

    Command --> Entity
    Query --> Entity
    Entity --> ValueObject
    Entity --> DomainService
    DomainService --> Repository

    Repository --> Database
    Repository --> Cache
    UseCase --> MessageBroker
    UseCase --> ExternalAPI
```

---

## ğŸ¯ æ ¸å¿ƒä¸šåŠ¡æœåŠ¡è®¾è®¡

### 1. çº¿ç´¢ç®¡ç†æœåŠ¡ (Lead Management Service)

#### æœåŠ¡è¾¹ç•Œå®šä¹‰
```typescript
// çº¿ç´¢ç®¡ç†æœåŠ¡è¾¹ç•Œå®šä¹‰
// src/services/lead-management/domain/boundaries/lead-service.boundary.ts

export interface LeadServiceBoundary {
  // æ ¸å¿ƒèŒè´£
  responsibilities: {
    leadLifecycleManagement: string;    // çº¿ç´¢ç”Ÿå‘½å‘¨æœŸç®¡ç†
    leadAssignment: string;             // çº¿ç´¢åˆ†é…
    leadConversion: string;             // çº¿ç´¢è½¬åŒ–
    leadScoring: string;                // çº¿ç´¢è¯„åˆ†
    leadNurturing: string;              // çº¿ç´¢åŸ¹è‚²
  };

  // æ•°æ®è¾¹ç•Œ
  dataOwnership: {
    entities: ['Lead', 'LeadActivity', 'LeadScore', 'LeadAssignment'];
    aggregates: ['LeadAggregate'];
    valueObjects: ['LeadPriority', 'LeadSource', 'LeadStatus'];
  };

  // ä¸šåŠ¡èƒ½åŠ›
  capabilities: {
    createLead: LeadCreationCapability;
    assignLead: LeadAssignmentCapability;
    updateLeadStatus: LeadStatusUpdateCapability;
    convertLead: LeadConversionCapability;
    scoreLead: LeadScoringCapability;
  };

  // å¤–éƒ¨ä¾èµ–
  dependencies: {
    customerService: CustomerServiceContract;
    userService: UserServiceContract;
    notificationService: NotificationServiceContract;
  };

  // å‘å¸ƒçš„äº‹ä»¶
  publishedEvents: [
    'LeadCreated',
    'LeadAssigned',
    'LeadStatusChanged',
    'LeadConverted',
    'LeadScoreUpdated'
  ];

  // è®¢é˜…çš„äº‹ä»¶
  subscribedEvents: [
    'CustomerCreated',
    'UserAssigned',
    'OrderCreated'
  ];
}

// çº¿ç´¢èšåˆæ ¹
export class LeadAggregate {
  private constructor(
    private readonly id: LeadId,
    private readonly customerId: CustomerId,
    private status: LeadStatus,
    private priority: LeadPriority,
    private source: LeadSource,
    private estimatedValue: Money,
    private assignedTo: UserId,
    private activities: LeadActivity[],
    private score: LeadScore,
    private createdAt: Date,
    private updatedAt: Date
  ) {}

  // åˆ›å»ºçº¿ç´¢
  public static create(
    customerId: CustomerId,
    priority: LeadPriority,
    source: LeadSource,
    estimatedValue: Money,
    assignedTo: UserId,
    createdBy: UserId
  ): LeadAggregate {
    const leadId = LeadId.generate();
    const lead = new LeadAggregate(
      leadId,
      customerId,
      LeadStatus.NEW,
      priority,
      source,
      estimatedValue,
      assignedTo,
      [],
      LeadScore.initial(),
      new Date(),
      new Date()
    );

    // å‘å¸ƒé¢†åŸŸäº‹ä»¶
    lead.addDomainEvent(new LeadCreatedEvent(
      leadId,
      customerId,
      priority,
      source,
      estimatedValue,
      assignedTo,
      createdBy
    ));

    return lead;
  }

  // åˆ†é…çº¿ç´¢
  public assign(newAssignee: UserId, assignedBy: UserId, reason?: string): void {
    if (this.assignedTo.equals(newAssignee)) {
      throw new DomainError('çº¿ç´¢å·²åˆ†é…ç»™è¯¥ç”¨æˆ·');
    }

    const oldAssignee = this.assignedTo;
    this.assignedTo = newAssignee;
    this.updatedAt = new Date();

    // è®°å½•æ´»åŠ¨
    this.activities.push(LeadActivity.createAssignment(
      this.id,
      oldAssignee,
      newAssignee,
      assignedBy,
      reason
    ));

    // å‘å¸ƒé¢†åŸŸäº‹ä»¶
    this.addDomainEvent(new LeadAssignedEvent(
      this.id,
      oldAssignee,
      newAssignee,
      assignedBy,
      reason
    ));
  }

  // æ›´æ–°çŠ¶æ€
  public updateStatus(newStatus: LeadStatus, updatedBy: UserId, notes?: string): void {
    if (this.status.equals(newStatus)) {
      return;
    }

    // éªŒè¯çŠ¶æ€è½¬æ¢
    if (!this.status.canTransitionTo(newStatus)) {
      throw new DomainError(`æ— æ³•ä»${this.status.value}è½¬æ¢åˆ°${newStatus.value}`);
    }

    const oldStatus = this.status;
    this.status = newStatus;
    this.updatedAt = new Date();

    // è®°å½•æ´»åŠ¨
    this.activities.push(LeadActivity.createStatusChange(
      this.id,
      oldStatus,
      newStatus,
      updatedBy,
      notes
    ));

    // å‘å¸ƒé¢†åŸŸäº‹ä»¶
    this.addDomainEvent(new LeadStatusChangedEvent(
      this.id,
      oldStatus,
      newStatus,
      updatedBy,
      notes
    ));
  }

  // è½¬åŒ–çº¿ç´¢
  public convert(orderId: OrderId, convertedBy: UserId): void {
    if (!this.status.canConvert()) {
      throw new DomainError('å½“å‰çŠ¶æ€ä¸å…è®¸è½¬åŒ–');
    }

    this.status = LeadStatus.CONVERTED;
    this.updatedAt = new Date();

    // è®°å½•æ´»åŠ¨
    this.activities.push(LeadActivity.createConversion(
      this.id,
      orderId,
      convertedBy
    ));

    // å‘å¸ƒé¢†åŸŸäº‹ä»¶
    this.addDomainEvent(new LeadConvertedEvent(
      this.id,
      this.customerId,
      orderId,
      this.estimatedValue,
      convertedBy
    ));
  }

  // æ›´æ–°è¯„åˆ†
  public updateScore(newScore: LeadScore, scoredBy: UserId): void {
    const oldScore = this.score;
    this.score = newScore;
    this.updatedAt = new Date();

    // è®°å½•æ´»åŠ¨
    this.activities.push(LeadActivity.createScoreUpdate(
      this.id,
      oldScore,
      newScore,
      scoredBy
    ));

    // å‘å¸ƒé¢†åŸŸäº‹ä»¶
    this.addDomainEvent(new LeadScoreUpdatedEvent(
      this.id,
      oldScore,
      newScore,
      scoredBy
    ));
  }

  // è·å–å™¨æ–¹æ³•
  public getId(): LeadId { return this.id; }
  public getCustomerId(): CustomerId { return this.customerId; }
  public getStatus(): LeadStatus { return this.status; }
  public getPriority(): LeadPriority { return this.priority; }
  public getSource(): LeadSource { return this.source; }
  public getEstimatedValue(): Money { return this.estimatedValue; }
  public getAssignedTo(): UserId { return this.assignedTo; }
  public getActivities(): LeadActivity[] { return [...this.activities]; }
  public getScore(): LeadScore { return this.score; }
  public getCreatedAt(): Date { return this.createdAt; }
  public getUpdatedAt(): Date { return this.updatedAt; }
}
```

#### æ•°æ®æ¨¡å‹è®¾è®¡
```sql
-- çº¿ç´¢ç®¡ç†æœåŠ¡æ•°æ®æ¨¡å‹
-- database/lead-service/schema.sql

-- çº¿ç´¢è¡¨
CREATE TABLE leads (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    customer_id UUID NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'NEW',
    priority VARCHAR(10) NOT NULL,
    source VARCHAR(50) NOT NULL,
    estimated_value DECIMAL(15,2),
    assigned_to UUID,
    score INTEGER DEFAULT 0,
    score_factors JSONB,
    tags TEXT[],
    notes TEXT,
    created_by UUID NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT chk_status CHECK (status IN ('NEW', 'CONTACTED', 'QUALIFIED', 'PROPOSAL', 'NEGOTIATION', 'CONVERTED', 'LOST')),
    CONSTRAINT chk_priority CHECK (priority IN ('LOW', 'MEDIUM', 'HIGH', 'URGENT')),
    CONSTRAINT chk_score CHECK (score >= 0 AND score <= 100)
);

-- çº¿ç´¢æ´»åŠ¨è¡¨
CREATE TABLE lead_activities (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES leads(id) ON DELETE CASCADE,
    activity_type VARCHAR(30) NOT NULL,
    description TEXT,
    metadata JSONB,
    performed_by UUID NOT NULL,
    performed_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT chk_activity_type CHECK (activity_type IN (
        'CREATED', 'ASSIGNED', 'STATUS_CHANGED', 'SCORE_UPDATED', 
        'CONVERTED', 'NOTE_ADDED', 'EMAIL_SENT', 'CALL_MADE', 'MEETING_SCHEDULED'
    ))
);

-- çº¿ç´¢è¯„åˆ†è§„åˆ™è¡¨
CREATE TABLE lead_scoring_rules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL,
    description TEXT,
    condition_expression TEXT NOT NULL,
    score_impact INTEGER NOT NULL,
    weight DECIMAL(3,2) DEFAULT 1.0,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT chk_score_impact CHECK (score_impact BETWEEN -50 AND 50),
    CONSTRAINT chk_weight CHECK (weight BETWEEN 0.1 AND 2.0)
);

-- çº¿ç´¢åˆ†é…è§„åˆ™è¡¨
CREATE TABLE lead_assignment_rules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL,
    description TEXT,
    condition_expression TEXT NOT NULL,
    assignment_strategy VARCHAR(20) NOT NULL,
    target_users UUID[],
    priority INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT chk_assignment_strategy CHECK (assignment_strategy IN ('ROUND_ROBIN', 'LOAD_BALANCED', 'SKILL_BASED', 'MANUAL'))
);

-- ç´¢å¼•
CREATE INDEX idx_leads_customer_id ON leads(customer_id);
CREATE INDEX idx_leads_assigned_to ON leads(assigned_to);
CREATE INDEX idx_leads_status ON leads(status);
CREATE INDEX idx_leads_priority ON leads(priority);
CREATE INDEX idx_leads_source ON leads(source);
CREATE INDEX idx_leads_created_at ON leads(created_at);
CREATE INDEX idx_leads_score ON leads(score);

CREATE INDEX idx_lead_activities_lead_id ON lead_activities(lead_id);
CREATE INDEX idx_lead_activities_type ON lead_activities(activity_type);
CREATE INDEX idx_lead_activities_performed_at ON lead_activities(performed_at);

-- è§¦å‘å™¨ï¼šæ›´æ–°æ—¶é—´æˆ³
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_leads_updated_at BEFORE UPDATE ON leads
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_lead_scoring_rules_updated_at BEFORE UPDATE ON lead_scoring_rules
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_lead_assignment_rules_updated_at BEFORE UPDATE ON lead_assignment_rules
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### 2. å®¢æˆ·ç®¡ç†æœåŠ¡ (Customer Management Service)

#### æœåŠ¡è¾¹ç•Œå®šä¹‰
```typescript
// å®¢æˆ·ç®¡ç†æœåŠ¡è¾¹ç•Œå®šä¹‰
// src/services/customer-management/domain/boundaries/customer-service.boundary.ts

export interface CustomerServiceBoundary {
  // æ ¸å¿ƒèŒè´£
  responsibilities: {
    customerLifecycleManagement: string;    // å®¢æˆ·ç”Ÿå‘½å‘¨æœŸç®¡ç†
    customerSegmentation: string;           // å®¢æˆ·åˆ†ç¾¤
    customerProfileManagement: string;      // å®¢æˆ·æ¡£æ¡ˆç®¡ç†
    customerRelationshipTracking: string;   // å®¢æˆ·å…³ç³»è·Ÿè¸ª
  };

  // æ•°æ®è¾¹ç•Œ
  dataOwnership: {
    entities: ['Customer', 'CustomerProfile', 'CustomerSegment', 'CustomerContact'];
    aggregates: ['CustomerAggregate'];
    valueObjects: ['CustomerType', 'CustomerStatus', 'ContactInfo'];
  };

  // ä¸šåŠ¡èƒ½åŠ›
  capabilities: {
    createCustomer: CustomerCreationCapability;
    updateCustomerProfile: CustomerProfileUpdateCapability;
    segmentCustomers: CustomerSegmentationCapability;
    trackCustomerInteractions: CustomerInteractionTrackingCapability;
  };

  // å¤–éƒ¨ä¾èµ–
  dependencies: {
    userService: UserServiceContract;
    notificationService: NotificationServiceContract;
    crmIntegration: CRMIntegrationContract;
  };

  // å‘å¸ƒçš„äº‹ä»¶
  publishedEvents: [
    'CustomerCreated',
    'CustomerUpdated',
    'CustomerSegmentChanged',
    'CustomerStatusChanged'
  ];

  // è®¢é˜…çš„äº‹ä»¶
  subscribedEvents: [
    'LeadConverted',
    'OrderCreated',
    'OrderCompleted'
  ];
}

// å®¢æˆ·èšåˆæ ¹
export class CustomerAggregate {
  private constructor(
    private readonly id: CustomerId,
    private profile: CustomerProfile,
    private status: CustomerStatus,
    private type: CustomerType,
    private segments: CustomerSegment[],
    private contacts: CustomerContact[],
    private preferences: CustomerPreferences,
    private createdAt: Date,
    private updatedAt: Date
  ) {}

  // åˆ›å»ºå®¢æˆ·
  public static create(
    name: string,
    email: string,
    phone: string,
    company?: string,
    createdBy: UserId
  ): CustomerAggregate {
    const customerId = CustomerId.generate();
    const profile = CustomerProfile.create(name, email, phone, company);
    
    const customer = new CustomerAggregate(
      customerId,
      profile,
      CustomerStatus.ACTIVE,
      CustomerType.PROSPECT,
      [],
      [],
      CustomerPreferences.default(),
      new Date(),
      new Date()
    );

    // å‘å¸ƒé¢†åŸŸäº‹ä»¶
    customer.addDomainEvent(new CustomerCreatedEvent(
      customerId,
      profile,
      createdBy
    ));

    return customer;
  }

  // æ›´æ–°å®¢æˆ·æ¡£æ¡ˆ
  public updateProfile(
    updates: Partial<CustomerProfileData>,
    updatedBy: UserId
  ): void {
    const oldProfile = this.profile;
    this.profile = this.profile.update(updates);
    this.updatedAt = new Date();

    // å‘å¸ƒé¢†åŸŸäº‹ä»¶
    this.addDomainEvent(new CustomerUpdatedEvent(
      this.id,
      oldProfile,
      this.profile,
      updatedBy
    ));
  }

  // æ›´æ–°å®¢æˆ·çŠ¶æ€
  public updateStatus(newStatus: CustomerStatus, updatedBy: UserId): void {
    if (this.status.equals(newStatus)) {
      return;
    }

    const oldStatus = this.status;
    this.status = newStatus;
    this.updatedAt = new Date();

    // å‘å¸ƒé¢†åŸŸäº‹ä»¶
    this.addDomainEvent(new CustomerStatusChangedEvent(
      this.id,
      oldStatus,
      newStatus,
      updatedBy
    ));
  }

  // æ·»åŠ å®¢æˆ·åˆ†ç¾¤
  public addToSegment(segment: CustomerSegment, addedBy: UserId): void {
    if (this.segments.some(s => s.equals(segment))) {
      return;
    }

    this.segments.push(segment);
    this.updatedAt = new Date();

    // å‘å¸ƒé¢†åŸŸäº‹ä»¶
    this.addDomainEvent(new CustomerSegmentChangedEvent(
      this.id,
      'ADDED',
      segment,
      addedBy
    ));
  }

  // ç§»é™¤å®¢æˆ·åˆ†ç¾¤
  public removeFromSegment(segment: CustomerSegment, removedBy: UserId): void {
    const index = this.segments.findIndex(s => s.equals(segment));
    if (index === -1) {
      return;
    }

    this.segments.splice(index, 1);
    this.updatedAt = new Date();

    // å‘å¸ƒé¢†åŸŸäº‹ä»¶
    this.addDomainEvent(new CustomerSegmentChangedEvent(
      this.id,
      'REMOVED',
      segment,
      removedBy
    ));
  }

  // æ·»åŠ è”ç³»æ–¹å¼
  public addContact(contact: CustomerContact, addedBy: UserId): void {
    this.contacts.push(contact);
    this.updatedAt = new Date();

    // å‘å¸ƒé¢†åŸŸäº‹ä»¶
    this.addDomainEvent(new CustomerContactAddedEvent(
      this.id,
      contact,
      addedBy
    ));
  }

  // è·å–å™¨æ–¹æ³•
  public getId(): CustomerId { return this.id; }
  public getProfile(): CustomerProfile { return this.profile; }
  public getStatus(): CustomerStatus { return this.status; }
  public getType(): CustomerType { return this.type; }
  public getSegments(): CustomerSegment[] { return [...this.segments]; }
  public getContacts(): CustomerContact[] { return [...this.contacts]; }
  public getPreferences(): CustomerPreferences { return this.preferences; }
  public getCreatedAt(): Date { return this.createdAt; }
  public getUpdatedAt(): Date { return this.updatedAt; }
}
```

### 3. è®¢å•ç®¡ç†æœåŠ¡ (Order Management Service)

#### æœåŠ¡è¾¹ç•Œå®šä¹‰
```typescript
// è®¢å•ç®¡ç†æœåŠ¡è¾¹ç•Œå®šä¹‰
// src/services/order-management/domain/boundaries/order-service.boundary.ts

export interface OrderServiceBoundary {
  // æ ¸å¿ƒèŒè´£
  responsibilities: {
    orderLifecycleManagement: string;       // è®¢å•ç”Ÿå‘½å‘¨æœŸç®¡ç†
    orderFulfillment: string;               // è®¢å•å±¥è¡Œ
    paymentProcessing: string;              // æ”¯ä»˜å¤„ç†
    inventoryReservation: string;           // åº“å­˜é¢„ç•™
    shippingManagement: string;             // é…é€ç®¡ç†
  };

  // æ•°æ®è¾¹ç•Œ
  dataOwnership: {
    entities: ['Order', 'OrderItem', 'Payment', 'Shipment', 'Invoice'];
    aggregates: ['OrderAggregate'];
    valueObjects: ['OrderStatus', 'PaymentStatus', 'ShippingAddress', 'Money'];
  };

  // ä¸šåŠ¡èƒ½åŠ›
  capabilities: {
    createOrder: OrderCreationCapability;
    processPayment: PaymentProcessingCapability;
    fulfillOrder: OrderFulfillmentCapability;
    shipOrder: OrderShippingCapability;
    cancelOrder: OrderCancellationCapability;
  };

  // å¤–éƒ¨ä¾èµ–
  dependencies: {
    customerService: CustomerServiceContract;
    productService: ProductServiceContract;
    paymentService: PaymentServiceContract;
    shippingService: ShippingServiceContract;
    inventoryService: InventoryServiceContract;
  };

  // å‘å¸ƒçš„äº‹ä»¶
  publishedEvents: [
    'OrderCreated',
    'OrderPaid',
    'OrderShipped',
    'OrderDelivered',
    'OrderCancelled'
  ];

  // è®¢é˜…çš„äº‹ä»¶
  subscribedEvents: [
    'PaymentCompleted',
    'PaymentFailed',
    'InventoryReserved',
    'ShipmentCreated'
  ];
}

// è®¢å•èšåˆæ ¹
export class OrderAggregate {
  private constructor(
    private readonly id: OrderId,
    private readonly customerId: CustomerId,
    private readonly leadId: LeadId,
    private items: OrderItem[],
    private status: OrderStatus,
    private totalAmount: Money,
    private discountAmount: Money,
    private taxAmount: Money,
    private finalAmount: Money,
    private shippingAddress: ShippingAddress,
    private billingAddress: BillingAddress,
    private payments: Payment[],
    private shipments: Shipment[],
    private createdAt: Date,
    private updatedAt: Date
  ) {}

  // åˆ›å»ºè®¢å•
  public static create(
    customerId: CustomerId,
    leadId: LeadId,
    items: OrderItemData[],
    shippingAddress: ShippingAddress,
    billingAddress: BillingAddress,
    createdBy: UserId
  ): OrderAggregate {
    const orderId = OrderId.generate();
    const orderItems = items.map(item => OrderItem.create(
      item.productId,
      item.quantity,
      item.unitPrice,
      item.discount
    ));

    // è®¡ç®—é‡‘é¢
    const totalAmount = orderItems.reduce((sum, item) => sum.add(item.getSubtotal()), Money.zero());
    const discountAmount = orderItems.reduce((sum, item) => sum.add(item.getDiscount()), Money.zero());
    const taxAmount = totalAmount.multiply(0.1); // å‡è®¾ç¨ç‡10%
    const finalAmount = totalAmount.subtract(discountAmount).add(taxAmount);

    const order = new OrderAggregate(
      orderId,
      customerId,
      leadId,
      orderItems,
      OrderStatus.PENDING,
      totalAmount,
      discountAmount,
      taxAmount,
      finalAmount,
      shippingAddress,
      billingAddress,
      [],
      [],
      new Date(),
      new Date()
    );

    // å‘å¸ƒé¢†åŸŸäº‹ä»¶
    order.addDomainEvent(new OrderCreatedEvent(
      orderId,
      customerId,
      leadId,
      orderItems,
      finalAmount,
      createdBy
    ));

    return order;
  }

  // æ·»åŠ è®¢å•é¡¹
  public addItem(
    productId: ProductId,
    quantity: number,
    unitPrice: Money,
    discount: Money = Money.zero(),
    addedBy: UserId
  ): void {
    const existingItem = this.items.find(item => item.getProductId().equals(productId));
    
    if (existingItem) {
      existingItem.updateQuantity(existingItem.getQuantity() + quantity);
    } else {
      const newItem = OrderItem.create(productId, quantity, unitPrice, discount);
      this.items.push(newItem);
    }

    this.recalculateAmounts();
    this.updatedAt = new Date();

    // å‘å¸ƒé¢†åŸŸäº‹ä»¶
    this.addDomainEvent(new OrderItemAddedEvent(
      this.id,
      productId,
      quantity,
      unitPrice,
      addedBy
    ));
  }

  // ç§»é™¤è®¢å•é¡¹
  public removeItem(productId: ProductId, removedBy: UserId): void {
    const index = this.items.findIndex(item => item.getProductId().equals(productId));
    if (index === -1) {
      throw new DomainError('è®¢å•é¡¹ä¸å­˜åœ¨');
    }

    const removedItem = this.items.splice(index, 1)[0];
    this.recalculateAmounts();
    this.updatedAt = new Date();

    // å‘å¸ƒé¢†åŸŸäº‹ä»¶
    this.addDomainEvent(new OrderItemRemovedEvent(
      this.id,
      productId,
      removedItem.getQuantity(),
      removedBy
    ));
  }

  // å¤„ç†æ”¯ä»˜
  public processPayment(
    paymentMethod: PaymentMethod,
    amount: Money,
    processedBy: UserId
  ): void {
    if (!this.status.canProcessPayment()) {
      throw new DomainError('å½“å‰çŠ¶æ€ä¸å…è®¸å¤„ç†æ”¯ä»˜');
    }

    const payment = Payment.create(
      this.id,
      paymentMethod,
      amount,
      processedBy
    );

    this.payments.push(payment);
    
    // æ£€æŸ¥æ˜¯å¦å·²å…¨é¢æ”¯ä»˜
    const totalPaid = this.payments
      .filter(p => p.getStatus().isPaid())
      .reduce((sum, p) => sum.add(p.getAmount()), Money.zero());

    if (totalPaid.greaterThanOrEqual(this.finalAmount)) {
      this.status = OrderStatus.PAID;
      
      // å‘å¸ƒæ”¯ä»˜å®Œæˆäº‹ä»¶
      this.addDomainEvent(new OrderPaidEvent(
        this.id,
        this.customerId,
        this.finalAmount,
        processedBy
      ));
    }

    this.updatedAt = new Date();
  }

  // å‘è´§
  public ship(
    trackingNumber: string,
    carrier: string,
    shippedBy: UserId
  ): void {
    if (!this.status.canShip()) {
      throw new DomainError('å½“å‰çŠ¶æ€ä¸å…è®¸å‘è´§');
    }

    const shipment = Shipment.create(
      this.id,
      trackingNumber,
      carrier,
      this.shippingAddress,
      shippedBy
    );

    this.shipments.push(shipment);
    this.status = OrderStatus.SHIPPED;
    this.updatedAt = new Date();

    // å‘å¸ƒå‘è´§äº‹ä»¶
    this.addDomainEvent(new OrderShippedEvent(
      this.id,
      this.customerId,
      trackingNumber,
      carrier,
      shippedBy
    ));
  }

  // å–æ¶ˆè®¢å•
  public cancel(reason: string, cancelledBy: UserId): void {
    if (!this.status.canCancel()) {
      throw new DomainError('å½“å‰çŠ¶æ€ä¸å…è®¸å–æ¶ˆ');
    }

    this.status = OrderStatus.CANCELLED;
    this.updatedAt = new Date();

    // å‘å¸ƒå–æ¶ˆäº‹ä»¶
    this.addDomainEvent(new OrderCancelledEvent(
      this.id,
      this.customerId,
      reason,
      cancelledBy
    ));
  }

  // é‡æ–°è®¡ç®—é‡‘é¢
  private recalculateAmounts(): void {
    this.totalAmount = this.items.reduce((sum, item) => sum.add(item.getSubtotal()), Money.zero());
    this.discountAmount = this.items.reduce((sum, item) => sum.add(item.getDiscount()), Money.zero());
    this.taxAmount = this.totalAmount.multiply(0.1);
    this.finalAmount = this.totalAmount.subtract(this.discountAmount).add(this.taxAmount);
  }

  // è·å–å™¨æ–¹æ³•
  public getId(): OrderId { return this.id; }
  public getCustomerId(): CustomerId { return this.customerId; }
  public getLeadId(): LeadId { return this.leadId; }
  public getItems(): OrderItem[] { return [...this.items]; }
  public getStatus(): OrderStatus { return this.status; }
  public getTotalAmount(): Money { return this.totalAmount; }
  public getDiscountAmount(): Money { return this.discountAmount; }
  public getTaxAmount(): Money { return this.taxAmount; }
  public getFinalAmount(): Money { return this.finalAmount; }
  public getShippingAddress(): ShippingAddress { return this.shippingAddress; }
  public getBillingAddress(): BillingAddress { return this.billingAddress; }
  public getPayments(): Payment[] { return [...this.payments]; }
  public getShipments(): Shipment[] { return [...this.shipments]; }
  public getCreatedAt(): Date { return this.createdAt; }
  public getUpdatedAt(): Date { return this.updatedAt; }
}
```

### 4. äº§å“ç®¡ç†æœåŠ¡ (Product Management Service)

#### æœåŠ¡è¾¹ç•Œå®šä¹‰
```typescript
// äº§å“ç®¡ç†æœåŠ¡è¾¹ç•Œå®šä¹‰
// src/services/product-management/domain/boundaries/product-service.boundary.ts

export interface ProductServiceBoundary {
  // æ ¸å¿ƒèŒè´£
  responsibilities: {
    productCatalogManagement: string;       // äº§å“ç›®å½•ç®¡ç†
    pricingManagement: string;              // å®šä»·ç®¡ç†
    inventoryTracking: string;              // åº“å­˜è·Ÿè¸ª
    productVariantManagement: string;       // äº§å“å˜ä½“ç®¡ç†
  };

  // æ•°æ®è¾¹ç•Œ
  dataOwnership: {
    entities: ['Product', 'ProductVariant', 'ProductCategory', 'PriceRule', 'Inventory'];
    aggregates: ['ProductAggregate', 'ProductCategoryAggregate'];
    valueObjects: ['ProductStatus', 'Price', 'SKU', 'ProductSpecification'];
  };

  // ä¸šåŠ¡èƒ½åŠ›
  capabilities: {
    createProduct: ProductCreationCapability;
    updateProductInfo: ProductUpdateCapability;
    managePricing: PricingManagementCapability;
    trackInventory: InventoryTrackingCapability;
    categorizeProducts: ProductCategorizationCapability;
  };

  // å¤–éƒ¨ä¾èµ–
  dependencies: {
    fileService: FileServiceContract;
    notificationService: NotificationServiceContract;
    supplierIntegration: SupplierIntegrationContract;
  };

  // å‘å¸ƒçš„äº‹ä»¶
  publishedEvents: [
    'ProductCreated',
    'ProductUpdated',
    'ProductPriceChanged',
    'InventoryUpdated',
    'ProductDiscontinued'
  ];

  // è®¢é˜…çš„äº‹ä»¶
  subscribedEvents: [
    'OrderCreated',
    'OrderCancelled',
    'SupplierInventoryUpdated'
  ];
}
```

---

## ğŸ”— æœåŠ¡é—´ä¾èµ–å…³ç³»

### 1. ä¾èµ–å…³ç³»å›¾

```mermaid
graph TD
    subgraph "æ ¸å¿ƒä¸šåŠ¡æœåŠ¡"
        LeadService[çº¿ç´¢ç®¡ç†æœåŠ¡]
        CustomerService[å®¢æˆ·ç®¡ç†æœåŠ¡]
        OrderService[è®¢å•ç®¡ç†æœåŠ¡]
        ProductService[äº§å“ç®¡ç†æœåŠ¡]
    end

    subgraph "æ”¯æ’‘æœåŠ¡"
        UserService[ç”¨æˆ·ç®¡ç†æœåŠ¡]
        NotificationService[é€šçŸ¥æœåŠ¡]
        ReportService[æŠ¥è¡¨åˆ†ææœåŠ¡]
        FileService[æ–‡ä»¶ç®¡ç†æœåŠ¡]
    end

    subgraph "åŸºç¡€è®¾æ–½æœåŠ¡"
        AuthService[è®¤è¯æˆæƒæœåŠ¡]
        ConfigService[é…ç½®ç®¡ç†æœåŠ¡]
        LogService[æ—¥å¿—æœåŠ¡]
    end

    LeadService --> CustomerService
    LeadService --> UserService
    LeadService --> NotificationService

    OrderService --> CustomerService
    OrderService --> ProductService
    OrderService --> NotificationService

    CustomerService --> UserService
    CustomerService --> NotificationService

    ProductService --> FileService
    ProductService --> NotificationService

    ReportService --> LeadService
    ReportService --> CustomerService
    ReportService --> OrderService
    ReportService --> ProductService

    UserService --> AuthService
    NotificationService --> ConfigService
    
    LeadService --> LogService
    CustomerService --> LogService
    OrderService --> LogService
    ProductService --> LogService
```

### 2. æœåŠ¡å¥‘çº¦å®šä¹‰

```typescript
// æœåŠ¡é—´å¥‘çº¦å®šä¹‰
// src/shared/contracts/service-contracts.ts

// å®¢æˆ·æœåŠ¡å¥‘çº¦
export interface CustomerServiceContract {
  // æŸ¥è¯¢å®¢æˆ·ä¿¡æ¯
  getCustomer(customerId: CustomerId): Promise<CustomerDto | null>;
  
  // éªŒè¯å®¢æˆ·å­˜åœ¨
  customerExists(customerId: CustomerId): Promise<boolean>;
  
  // è·å–å®¢æˆ·åŸºæœ¬ä¿¡æ¯
  getCustomerBasicInfo(customerId: CustomerId): Promise<CustomerBasicInfoDto>;
  
  // æ‰¹é‡è·å–å®¢æˆ·ä¿¡æ¯
  getCustomersBatch(customerIds: CustomerId[]): Promise<CustomerDto[]>;
}

// ç”¨æˆ·æœåŠ¡å¥‘çº¦
export interface UserServiceContract {
  // è·å–ç”¨æˆ·ä¿¡æ¯
  getUser(userId: UserId): Promise<UserDto | null>;
  
  // éªŒè¯ç”¨æˆ·å­˜åœ¨
  userExists(userId: UserId): Promise<boolean>;
  
  // è·å–ç”¨æˆ·åŸºæœ¬ä¿¡æ¯
  getUserBasicInfo(userId: UserId): Promise<UserBasicInfoDto>;
  
  // è·å–ç”¨æˆ·æƒé™
  getUserPermissions(userId: UserId): Promise<string[]>;
}

// äº§å“æœåŠ¡å¥‘çº¦
export interface ProductServiceContract {
  // è·å–äº§å“ä¿¡æ¯
  getProduct(productId: ProductId): Promise<ProductDto | null>;
  
  // éªŒè¯äº§å“å­˜åœ¨
  productExists(productId: ProductId): Promise<boolean>;
  
  // è·å–äº§å“ä»·æ ¼
  getProductPrice(productId: ProductId, quantity: number): Promise<PriceDto>;
  
  // æ£€æŸ¥åº“å­˜
  checkInventory(productId: ProductId, quantity: number): Promise<boolean>;
  
  // é¢„ç•™åº“å­˜
  reserveInventory(productId: ProductId, quantity: number, orderId: OrderId): Promise<void>;
}

// é€šçŸ¥æœåŠ¡å¥‘çº¦
export interface NotificationServiceContract {
  // å‘é€é‚®ä»¶é€šçŸ¥
  sendEmail(to: string, subject: string, content: string, templateId?: string): Promise<void>;
  
  // å‘é€çŸ­ä¿¡é€šçŸ¥
  sendSMS(to: string, message: string): Promise<void>;
  
  // å‘é€æ¨é€é€šçŸ¥
  sendPushNotification(userId: UserId, title: string, message: string): Promise<void>;
  
  // å‘é€ç³»ç»Ÿé€šçŸ¥
  sendSystemNotification(userId: UserId, type: string, data: any): Promise<void>;
}

// æ”¯ä»˜æœåŠ¡å¥‘çº¦
export interface PaymentServiceContract {
  // åˆ›å»ºæ”¯ä»˜
  createPayment(orderId: OrderId, amount: Money, method: PaymentMethod): Promise<PaymentDto>;
  
  // å¤„ç†æ”¯ä»˜
  processPayment(paymentId: PaymentId): Promise<PaymentResultDto>;
  
  // é€€æ¬¾
  refundPayment(paymentId: PaymentId, amount: Money, reason: string): Promise<RefundDto>;
  
  // æŸ¥è¯¢æ”¯ä»˜çŠ¶æ€
  getPaymentStatus(paymentId: PaymentId): Promise<PaymentStatusDto>;
}
```

---

## ğŸ“Š æ•°æ®ä¸€è‡´æ€§ç­–ç•¥

### 1. æ•°æ®ä¸€è‡´æ€§æ¨¡å¼

```typescript
// æ•°æ®ä¸€è‡´æ€§ç­–ç•¥
// src/shared/consistency/consistency-patterns.ts

// æœ€ç»ˆä¸€è‡´æ€§æ¨¡å¼
export class EventualConsistencyPattern {
  constructor(
    private readonly eventBus: EventBus,
    private readonly retryPolicy: RetryPolicy
  ) {}

  // å‘å¸ƒé¢†åŸŸäº‹ä»¶
  async publishDomainEvent(event: DomainEvent): Promise<void> {
    try {
      await this.eventBus.publish(event);
    } catch (error) {
      // é‡è¯•æœºåˆ¶
      await this.retryPolicy.execute(() => this.eventBus.publish(event));
    }
  }

  // å¤„ç†äº‹ä»¶å¤±è´¥çš„è¡¥å¿æœºåˆ¶
  async handleEventFailure(event: DomainEvent, error: Error): Promise<void> {
    // è®°å½•å¤±è´¥äº‹ä»¶
    await this.logFailedEvent(event, error);
    
    // è§¦å‘è¡¥å¿æµç¨‹
    await this.triggerCompensation(event);
  }

  private async logFailedEvent(event: DomainEvent, error: Error): Promise<void> {
    // è®°å½•åˆ°å¤±è´¥äº‹ä»¶è¡¨
    await this.failedEventRepository.save({
      eventId: event.id,
      eventType: event.type,
      eventData: event.data,
      error: error.message,
      timestamp: new Date(),
      retryCount: 0
    });
  }

  private async triggerCompensation(event: DomainEvent): Promise<void> {
    // æ ¹æ®äº‹ä»¶ç±»å‹è§¦å‘ç›¸åº”çš„è¡¥å¿æ“ä½œ
    const compensationEvent = this.createCompensationEvent(event);
    await this.eventBus.publish(compensationEvent);
  }
}

// Sagaæ¨¡å¼å®ç°
export class SagaPattern {
  constructor(
    private readonly sagaRepository: SagaRepository,
    private readonly eventBus: EventBus
  ) {}

  // å¼€å§‹Saga
  async startSaga(sagaType: string, data: any): Promise<SagaId> {
    const saga = Saga.create(sagaType, data);
    await this.sagaRepository.save(saga);
    
    // æ‰§è¡Œç¬¬ä¸€æ­¥
    await this.executeNextStep(saga);
    
    return saga.getId();
  }

  // æ‰§è¡Œä¸‹ä¸€æ­¥
  async executeNextStep(saga: Saga): Promise<void> {
    const nextStep = saga.getNextStep();
    if (!nextStep) {
      // Sagaå®Œæˆ
      saga.complete();
      await this.sagaRepository.save(saga);
      return;
    }

    try {
      // æ‰§è¡Œæ­¥éª¤
      await this.executeStep(nextStep);
      saga.markStepCompleted(nextStep.id);
      await this.sagaRepository.save(saga);
      
      // ç»§ç»­ä¸‹ä¸€æ­¥
      await this.executeNextStep(saga);
    } catch (error) {
      // æ­¥éª¤å¤±è´¥ï¼Œå¼€å§‹è¡¥å¿
      await this.startCompensation(saga, nextStep);
    }
  }

  // å¼€å§‹è¡¥å¿
  async startCompensation(saga: Saga, failedStep: SagaStep): Promise<void> {
    saga.markFailed(failedStep.id);
    
    // æ‰§è¡Œè¡¥å¿æ“ä½œ
    const completedSteps = saga.getCompletedSteps().reverse();
    for (const step of completedSteps) {
      await this.compensateStep(step);
    }
    
    saga.markCompensated();
    await this.sagaRepository.save(saga);
  }

  private async executeStep(step: SagaStep): Promise<void> {
    const command = step.createCommand();
    await this.eventBus.publish(command);
  }

  private async compensateStep(step: SagaStep): Promise<void> {
    const compensationCommand = step.createCompensationCommand();
    await this.eventBus.publish(compensationCommand);
  }
}
```

### 2. åˆ†å¸ƒå¼äº‹åŠ¡å¤„ç†

```typescript
// åˆ†å¸ƒå¼äº‹åŠ¡å¤„ç†
// src/shared/transactions/distributed-transaction.ts

// è®¢å•åˆ›å»ºSaga
export class OrderCreationSaga extends Saga {
  constructor(
    private readonly orderService: OrderServiceContract,
    private readonly customerService: CustomerServiceContract,
    private readonly productService: ProductServiceContract,
    private readonly paymentService: PaymentServiceContract,
    private readonly inventoryService: InventoryServiceContract
  ) {
    super('OrderCreation');
  }

  // å®šä¹‰Sagaæ­¥éª¤
  protected defineSteps(): SagaStep[] {
    return [
      new ValidateCustomerStep(this.customerService),
      new ValidateProductsStep(this.productService),
      new ReserveInventoryStep(this.inventoryService),
      new CreateOrderStep(this.orderService),
      new ProcessPaymentStep(this.paymentService),
      new ConfirmOrderStep(this.orderService)
    ];
  }
}

// éªŒè¯å®¢æˆ·æ­¥éª¤
export class ValidateCustomerStep extends SagaStep {
  constructor(private readonly customerService: CustomerServiceContract) {
    super('ValidateCustomer');
  }

  async execute(data: OrderCreationData): Promise<void> {
    const customerExists = await this.customerService.customerExists(data.customerId);
    if (!customerExists) {
      throw new SagaStepError('å®¢æˆ·ä¸å­˜åœ¨');
    }
  }

  async compensate(data: OrderCreationData): Promise<void> {
    // éªŒè¯æ­¥éª¤æ— éœ€è¡¥å¿
  }
}

// é¢„ç•™åº“å­˜æ­¥éª¤
export class ReserveInventoryStep extends SagaStep {
  constructor(private readonly inventoryService: InventoryServiceContract) {
    super('ReserveInventory');
  }

  async execute(data: OrderCreationData): Promise<void> {
    for (const item of data.items) {
      await this.inventoryService.reserveInventory(
        item.productId,
        item.quantity,
        data.orderId
      );
    }
  }

  async compensate(data: OrderCreationData): Promise<void> {
    // é‡Šæ”¾é¢„ç•™çš„åº“å­˜
    for (const item of data.items) {
      await this.inventoryService.releaseReservation(
        item.productId,
        item.quantity,
        data.orderId
      );
    }
  }
}

// å¤„ç†æ”¯ä»˜æ­¥éª¤
export class ProcessPaymentStep extends SagaStep {
  constructor(private readonly paymentService: PaymentServiceContract) {
    super('ProcessPayment');
  }

  async execute(data: OrderCreationData): Promise<void> {
    const payment = await this.paymentService.createPayment(
      data.orderId,
      data.totalAmount,
      data.paymentMethod
    );

    const result = await this.paymentService.processPayment(payment.id);
    if (!result.success) {
      throw new SagaStepError('æ”¯ä»˜å¤„ç†å¤±è´¥');
    }

    // ä¿å­˜æ”¯ä»˜IDç”¨äºè¡¥å¿
    data.paymentId = payment.id;
  }

  async compensate(data: OrderCreationData): Promise<void> {
    if (data.paymentId) {
      // é€€æ¬¾
      await this.paymentService.refundPayment(
        data.paymentId,
        data.totalAmount,
        'è®¢å•åˆ›å»ºå¤±è´¥'
      );
    }
  }
}
```

---

## ğŸ”„ æœåŠ¡é€šä¿¡æ¨¡å¼

### 1. åŒæ­¥é€šä¿¡

```typescript
// åŒæ­¥é€šä¿¡å®ç°
// src/shared/communication/sync-communication.ts

// HTTPå®¢æˆ·ç«¯
export class HttpServiceClient {
  constructor(
    private readonly httpClient: HttpClient,
    private readonly circuitBreaker: CircuitBreaker,
    private readonly retryPolicy: RetryPolicy
  ) {}

  async get<T>(url: string, headers?: Record<string, string>): Promise<T> {
    return this.circuitBreaker.execute(async () => {
      return this.retryPolicy.execute(async () => {
        const response = await this.httpClient.get(url, { headers });
        return response.data;
      });
    });
  }

  async post<T>(url: string, data: any, headers?: Record<string, string>): Promise<T> {
    return this.circuitBreaker.execute(async () => {
      return this.retryPolicy.execute(async () => {
        const response = await this.httpClient.post(url, data, { headers });
        return response.data;
      });
    });
  }
}

// gRPCå®¢æˆ·ç«¯
export class GrpcServiceClient {
  constructor(
    private readonly client: GrpcClient,
    private readonly loadBalancer: LoadBalancer
  ) {}

  async call<TRequest, TResponse>(
    method: string,
    request: TRequest
  ): Promise<TResponse> {
    const endpoint = await this.loadBalancer.getEndpoint();
    return this.client.call(endpoint, method, request);
  }
}
```

### 2. å¼‚æ­¥é€šä¿¡

```typescript
// å¼‚æ­¥é€šä¿¡å®ç°
// src/shared/communication/async-communication.ts

// äº‹ä»¶å‘å¸ƒå™¨
export class EventPublisher {
  constructor(
    private readonly messageBroker: MessageBroker,
    private readonly eventStore: EventStore
  ) {}

  async publishDomainEvent(event: DomainEvent): Promise<void> {
    // ä¿å­˜äº‹ä»¶åˆ°äº‹ä»¶å­˜å‚¨
    await this.eventStore.save(event);
    
    // å‘å¸ƒåˆ°æ¶ˆæ¯ä»£ç†
    await this.messageBroker.publish(event.type, event);
  }

  async publishIntegrationEvent(event: IntegrationEvent): Promise<void> {
    await this.messageBroker.publish(event.type, event);
  }
}

// äº‹ä»¶è®¢é˜…å™¨
export class EventSubscriber {
  constructor(
    private readonly messageBroker: MessageBroker,
    private readonly eventHandlers: Map<string, EventHandler[]>
  ) {}

  async subscribe(eventType: string, handler: EventHandler): Promise<void> {
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, []);
    }
    
    this.eventHandlers.get(eventType)!.push(handler);
    
    await this.messageBroker.subscribe(eventType, async (event) => {
      const handlers = this.eventHandlers.get(eventType) || [];
      
      // å¹¶è¡Œå¤„ç†æ‰€æœ‰å¤„ç†å™¨
      await Promise.all(handlers.map(h => h.handle(event)));
    });
  }
}
```

---

## ğŸ“Š æ€»ç»“

è¿™ä¸ªå¾®æœåŠ¡æ‹†åˆ†è¾¹ç•Œè®¾è®¡æ–¹æ¡ˆåŸºäºé¢†åŸŸé©±åŠ¨è®¾è®¡åŸåˆ™ï¼Œä¸ºç½—è±L2Cé”€å”®ç®¡ç†ç³»ç»Ÿæä¾›äº†æ¸…æ™°çš„æœåŠ¡è¾¹ç•Œå®šä¹‰ï¼Œå…·æœ‰ä»¥ä¸‹æ ¸å¿ƒä¼˜åŠ¿ï¼š

### ğŸ¯ è®¾è®¡ä¼˜åŠ¿
- **ä¸šåŠ¡è¾¹ç•Œæ¸…æ™°**ï¼šåŸºäºä¸šåŠ¡é¢†åŸŸå’Œèšåˆæ ¹åˆ’åˆ†æœåŠ¡è¾¹ç•Œ
- **æ•°æ®è‡ªæ²»**ï¼šæ¯ä¸ªæœåŠ¡æ‹¥æœ‰ç‹¬ç«‹çš„æ•°æ®å­˜å‚¨å’Œç®¡ç†
- **æŠ€æœ¯ç‹¬ç«‹**ï¼šæ”¯æŒä¸åŒæœåŠ¡é‡‡ç”¨ä¸åŒæŠ€æœ¯æ ˆ
- **å›¢é˜Ÿè‡ªæ²»**ï¼šæ”¯æŒå›¢é˜Ÿç‹¬ç«‹å¼€å‘ã€æµ‹è¯•å’Œéƒ¨ç½²

### ğŸ”§ å®ç°ç‰¹ç‚¹
- **å®Œæ•´çš„èšåˆæ ¹è®¾è®¡**ï¼šæ¯ä¸ªæœåŠ¡éƒ½æœ‰æ˜ç¡®çš„èšåˆæ ¹å’Œä¸šåŠ¡é€»è¾‘
- **æ¸…æ™°çš„æœåŠ¡å¥‘çº¦**ï¼šå®šä¹‰äº†æœåŠ¡é—´çš„äº¤äº’æ¥å£å’Œæ•°æ®ä¼ è¾“å¯¹è±¡
- **çµæ´»çš„é€šä¿¡æ¨¡å¼**ï¼šæ”¯æŒåŒæ­¥å’Œå¼‚æ­¥é€šä¿¡æ–¹å¼
- **å¼ºå¤§çš„ä¸€è‡´æ€§ä¿è¯**ï¼šé€šè¿‡Sagaæ¨¡å¼å’Œäº‹ä»¶é©±åŠ¨ç¡®ä¿æ•°æ®ä¸€è‡´æ€§

### ğŸš€ æ¶æ„ä»·å€¼
- **é«˜å†…èšä½è€¦åˆ**ï¼šæœåŠ¡å†…éƒ¨é«˜åº¦å†…èšï¼ŒæœåŠ¡é—´æ¾æ•£è€¦åˆ
- **å¯æ‰©å±•æ€§**ï¼šæ”¯æŒç‹¬ç«‹æ‰©å±•ç‰¹å®šä¸šåŠ¡æœåŠ¡
- **å¯ç»´æŠ¤æ€§**ï¼šæ¸…æ™°çš„è¾¹ç•Œä¾¿äºä»£ç ç»´æŠ¤å’ŒåŠŸèƒ½æ‰©å±•
- **å¯æµ‹è¯•æ€§**ï¼šç‹¬ç«‹çš„æœåŠ¡è¾¹ç•Œä¾¿äºå•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•

è¿™ä¸ªè®¾è®¡æ–¹æ¡ˆä¸ºç³»ç»Ÿçš„å¾®æœåŠ¡åŒ–æ”¹é€ æä¾›äº†åšå®çš„ç†è®ºåŸºç¡€å’Œå®è·µæŒ‡å¯¼ï¼Œç¡®ä¿äº†ç³»ç»Ÿçš„é•¿æœŸå¯ç»´æŠ¤æ€§å’Œä¸šåŠ¡æ•æ·æ€§ã€‚
