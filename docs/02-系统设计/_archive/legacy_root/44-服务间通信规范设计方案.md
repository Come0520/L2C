# æœåŠ¡é—´é€šä¿¡è§„èŒƒè®¾è®¡æ–¹æ¡ˆ

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†é˜è¿°äº†ç½—è±L2Cé”€å”®ç®¡ç†ç³»ç»Ÿçš„æœåŠ¡é—´é€šä¿¡è§„èŒƒè®¾è®¡æ–¹æ¡ˆï¼Œå®šä¹‰äº†å¾®æœåŠ¡æ¶æ„ä¸­å„æœåŠ¡é—´çš„é€šä¿¡åè®®ã€æ•°æ®æ ¼å¼ã€é”™è¯¯å¤„ç†ã€å®‰å…¨æœºåˆ¶å’Œç›‘æ§ç­–ç•¥ï¼Œç¡®ä¿æœåŠ¡é—´é«˜æ•ˆã€å¯é ã€å®‰å…¨çš„é€šä¿¡ã€‚

---

## ğŸ¯ è®¾è®¡ç›®æ ‡ä¸ä»·å€¼

### 1. æ ¸å¿ƒç›®æ ‡
- **é€šä¿¡æ ‡å‡†åŒ–**ï¼šå»ºç«‹ç»Ÿä¸€çš„æœåŠ¡é—´é€šä¿¡æ ‡å‡†å’Œè§„èŒƒ
- **é«˜å¯ç”¨æ€§**ï¼šç¡®ä¿æœåŠ¡é—´é€šä¿¡çš„ç¨³å®šæ€§å’Œå¯é æ€§
- **æ€§èƒ½ä¼˜åŒ–**ï¼šæä¾›é«˜æ•ˆçš„é€šä¿¡æœºåˆ¶å’Œæ•°æ®ä¼ è¾“
- **å®‰å…¨ä¿éšœ**ï¼šç¡®ä¿æœåŠ¡é—´é€šä¿¡çš„å®‰å…¨æ€§å’Œæ•°æ®ä¿æŠ¤
- **å¯è§‚æµ‹æ€§**ï¼šæä¾›å®Œæ•´çš„é€šä¿¡ç›‘æ§å’Œè¿½è¸ªèƒ½åŠ›

### 2. ä¸šåŠ¡ä»·å€¼
- **å¼€å‘æ•ˆç‡æå‡**ï¼šç»Ÿä¸€çš„é€šä¿¡è§„èŒƒé™ä½å¼€å‘å¤æ‚åº¦
- **ç³»ç»Ÿç¨³å®šæ€§å¢å¼º**ï¼šå¯é çš„é€šä¿¡æœºåˆ¶ä¿éšœç³»ç»Ÿç¨³å®šè¿è¡Œ
- **è¿ç»´ä¾¿åˆ©æ€§**ï¼šæ ‡å‡†åŒ–çš„ç›‘æ§å’Œæ—¥å¿—ä¾¿äºè¿ç»´ç®¡ç†
- **æ‰©å±•æ€§æ”¯æŒ**ï¼šçµæ´»çš„é€šä¿¡æ¶æ„æ”¯æŒç³»ç»Ÿæ‰©å±•

---

## ğŸ—ï¸ é€šä¿¡æ¶æ„è®¾è®¡

### 1. æ•´ä½“é€šä¿¡æ¶æ„

```mermaid
graph TB
    subgraph "å®¢æˆ·ç«¯å±‚"
        WebClient[Webå®¢æˆ·ç«¯]
        MobileClient[ç§»åŠ¨å®¢æˆ·ç«¯]
        AdminClient[ç®¡ç†å®¢æˆ·ç«¯]
    end

    subgraph "APIç½‘å…³å±‚"
        APIGateway[APIç½‘å…³]
        LoadBalancer[è´Ÿè½½å‡è¡¡å™¨]
        RateLimiter[é™æµå™¨]
        AuthProxy[è®¤è¯ä»£ç†]
    end

    subgraph "æœåŠ¡ç½‘æ ¼å±‚"
        ServiceMesh[æœåŠ¡ç½‘æ ¼]
        Proxy[ä»£ç†]
        CircuitBreaker[ç†”æ–­å™¨]
        Retry[é‡è¯•æœºåˆ¶]
    end

    subgraph "ä¸šåŠ¡æœåŠ¡å±‚"
        LeadService[çº¿ç´¢æœåŠ¡]
        CustomerService[å®¢æˆ·æœåŠ¡]
        OrderService[è®¢å•æœåŠ¡]
        ProductService[äº§å“æœåŠ¡]
        UserService[ç”¨æˆ·æœåŠ¡]
        NotificationService[é€šçŸ¥æœåŠ¡]
    end

    subgraph "æ¶ˆæ¯ä¸­é—´ä»¶å±‚"
        EventBus[äº‹ä»¶æ€»çº¿]
        MessageQueue[æ¶ˆæ¯é˜Ÿåˆ—]
        StreamProcessor[æµå¤„ç†å™¨]
    end

    subgraph "åŸºç¡€è®¾æ–½å±‚"
        ServiceRegistry[æœåŠ¡æ³¨å†Œä¸­å¿ƒ]
        ConfigCenter[é…ç½®ä¸­å¿ƒ]
        LogCenter[æ—¥å¿—ä¸­å¿ƒ]
        MonitorCenter[ç›‘æ§ä¸­å¿ƒ]
    end

    WebClient --> APIGateway
    MobileClient --> APIGateway
    AdminClient --> APIGateway

    APIGateway --> LoadBalancer
    LoadBalancer --> RateLimiter
    RateLimiter --> AuthProxy

    AuthProxy --> ServiceMesh
    ServiceMesh --> Proxy
    Proxy --> CircuitBreaker
    CircuitBreaker --> Retry

    Retry --> LeadService
    Retry --> CustomerService
    Retry --> OrderService
    Retry --> ProductService
    Retry --> UserService
    Retry --> NotificationService

    LeadService --> EventBus
    CustomerService --> EventBus
    OrderService --> EventBus
    ProductService --> EventBus

    EventBus --> MessageQueue
    MessageQueue --> StreamProcessor

    LeadService --> ServiceRegistry
    CustomerService --> ServiceRegistry
    OrderService --> ServiceRegistry
    ProductService --> ServiceRegistry

    ServiceMesh --> ConfigCenter
    ServiceMesh --> LogCenter
    ServiceMesh --> MonitorCenter
```

### 2. é€šä¿¡æ¨¡å¼åˆ†ç±»

```mermaid
graph LR
    subgraph "åŒæ­¥é€šä¿¡"
        HTTP[HTTP/REST]
        gRPC[gRPC]
        GraphQL[GraphQL]
    end

    subgraph "å¼‚æ­¥é€šä¿¡"
        EventDriven[äº‹ä»¶é©±åŠ¨]
        MessageQueue[æ¶ˆæ¯é˜Ÿåˆ—]
        StreamProcessing[æµå¤„ç†]
    end

    subgraph "æ··åˆé€šä¿¡"
        RequestResponse[è¯·æ±‚-å“åº”]
        PublishSubscribe[å‘å¸ƒ-è®¢é˜…]
        CommandQuery[å‘½ä»¤-æŸ¥è¯¢]
    end

    HTTP --> RequestResponse
    gRPC --> RequestResponse
    GraphQL --> RequestResponse

    EventDriven --> PublishSubscribe
    MessageQueue --> PublishSubscribe
    StreamProcessing --> PublishSubscribe

    RequestResponse --> CommandQuery
    PublishSubscribe --> CommandQuery
```

---

## ğŸ”„ åŒæ­¥é€šä¿¡è§„èŒƒ

### 1. HTTP/RESTé€šä¿¡è§„èŒƒ

#### APIè®¾è®¡è§„èŒƒ
```typescript
// HTTP/REST APIè®¾è®¡è§„èŒƒ
// src/shared/communication/http/rest-api.standards.ts

// APIç‰ˆæœ¬æ§åˆ¶
export enum APIVersion {
  V1 = 'v1',
  V2 = 'v2'
}

// HTTPæ–¹æ³•è§„èŒƒ
export enum HTTPMethod {
  GET = 'GET',       // æŸ¥è¯¢èµ„æº
  POST = 'POST',     // åˆ›å»ºèµ„æº
  PUT = 'PUT',       // æ›´æ–°èµ„æºï¼ˆå®Œæ•´æ›´æ–°ï¼‰
  PATCH = 'PATCH',   // æ›´æ–°èµ„æºï¼ˆéƒ¨åˆ†æ›´æ–°ï¼‰
  DELETE = 'DELETE'  // åˆ é™¤èµ„æº
}

// HTTPçŠ¶æ€ç è§„èŒƒ
export enum HTTPStatusCode {
  // æˆåŠŸå“åº”
  OK = 200,                    // è¯·æ±‚æˆåŠŸ
  CREATED = 201,               // èµ„æºåˆ›å»ºæˆåŠŸ
  ACCEPTED = 202,              // è¯·æ±‚å·²æ¥å—ï¼Œå¼‚æ­¥å¤„ç†
  NO_CONTENT = 204,            // è¯·æ±‚æˆåŠŸï¼Œæ— è¿”å›å†…å®¹

  // å®¢æˆ·ç«¯é”™è¯¯
  BAD_REQUEST = 400,           // è¯·æ±‚å‚æ•°é”™è¯¯
  UNAUTHORIZED = 401,          // æœªæˆæƒ
  FORBIDDEN = 403,             // ç¦æ­¢è®¿é—®
  NOT_FOUND = 404,             // èµ„æºä¸å­˜åœ¨
  METHOD_NOT_ALLOWED = 405,    // æ–¹æ³•ä¸å…è®¸
  CONFLICT = 409,              // èµ„æºå†²çª
  UNPROCESSABLE_ENTITY = 422,  // è¯·æ±‚æ ¼å¼æ­£ç¡®ä½†è¯­ä¹‰é”™è¯¯

  // æœåŠ¡å™¨é”™è¯¯
  INTERNAL_SERVER_ERROR = 500, // æœåŠ¡å™¨å†…éƒ¨é”™è¯¯
  BAD_GATEWAY = 502,           // ç½‘å…³é”™è¯¯
  SERVICE_UNAVAILABLE = 503,   // æœåŠ¡ä¸å¯ç”¨
  GATEWAY_TIMEOUT = 504        // ç½‘å…³è¶…æ—¶
}

// æ ‡å‡†APIå“åº”æ ¼å¼
export interface APIResponse<T = any> {
  success: boolean;
  data?: T;
  error?: APIError;
  metadata?: APIMetadata;
}

export interface APIError {
  code: string;
  message: string;
  details?: any;
  timestamp: string;
  traceId: string;
}

export interface APIMetadata {
  version: string;
  timestamp: string;
  requestId: string;
  pagination?: PaginationMetadata;
}

export interface PaginationMetadata {
  page: number;
  pageSize: number;
  total: number;
  totalPages: number;
  hasNext: boolean;
  hasPrevious: boolean;
}

// REST APIå®¢æˆ·ç«¯
export class RestAPIClient {
  constructor(
    private readonly baseURL: string,
    private readonly version: APIVersion,
    private readonly httpClient: HttpClient,
    private readonly authProvider: AuthProvider,
    private readonly retryPolicy: RetryPolicy,
    private readonly circuitBreaker: CircuitBreaker
  ) {}

  // GETè¯·æ±‚
  async get<T>(
    endpoint: string,
    params?: Record<string, any>,
    options?: RequestOptions
  ): Promise<APIResponse<T>> {
    const url = this.buildURL(endpoint, params);
    const headers = await this.buildHeaders(options?.headers);

    return this.circuitBreaker.execute(async () => {
      return this.retryPolicy.execute(async () => {
        const response = await this.httpClient.get<APIResponse<T>>(url, {
          headers,
          timeout: options?.timeout || 30000
        });
        
        this.validateResponse(response);
        return response.data;
      });
    });
  }

  // POSTè¯·æ±‚
  async post<T>(
    endpoint: string,
    data: any,
    options?: RequestOptions
  ): Promise<APIResponse<T>> {
    const url = this.buildURL(endpoint);
    const headers = await this.buildHeaders(options?.headers);

    return this.circuitBreaker.execute(async () => {
      return this.retryPolicy.execute(async () => {
        const response = await this.httpClient.post<APIResponse<T>>(url, data, {
          headers,
          timeout: options?.timeout || 30000
        });
        
        this.validateResponse(response);
        return response.data;
      });
    });
  }

  // PUTè¯·æ±‚
  async put<T>(
    endpoint: string,
    data: any,
    options?: RequestOptions
  ): Promise<APIResponse<T>> {
    const url = this.buildURL(endpoint);
    const headers = await this.buildHeaders(options?.headers);

    return this.circuitBreaker.execute(async () => {
      return this.retryPolicy.execute(async () => {
        const response = await this.httpClient.put<APIResponse<T>>(url, data, {
          headers,
          timeout: options?.timeout || 30000
        });
        
        this.validateResponse(response);
        return response.data;
      });
    });
  }

  // PATCHè¯·æ±‚
  async patch<T>(
    endpoint: string,
    data: any,
    options?: RequestOptions
  ): Promise<APIResponse<T>> {
    const url = this.buildURL(endpoint);
    const headers = await this.buildHeaders(options?.headers);

    return this.circuitBreaker.execute(async () => {
      return this.retryPolicy.execute(async () => {
        const response = await this.httpClient.patch<APIResponse<T>>(url, data, {
          headers,
          timeout: options?.timeout || 30000
        });
        
        this.validateResponse(response);
        return response.data;
      });
    });
  }

  // DELETEè¯·æ±‚
  async delete<T>(
    endpoint: string,
    options?: RequestOptions
  ): Promise<APIResponse<T>> {
    const url = this.buildURL(endpoint);
    const headers = await this.buildHeaders(options?.headers);

    return this.circuitBreaker.execute(async () => {
      return this.retryPolicy.execute(async () => {
        const response = await this.httpClient.delete<APIResponse<T>>(url, {
          headers,
          timeout: options?.timeout || 30000
        });
        
        this.validateResponse(response);
        return response.data;
      });
    });
  }

  private buildURL(endpoint: string, params?: Record<string, any>): string {
    let url = `${this.baseURL}/api/${this.version}${endpoint}`;
    
    if (params) {
      const searchParams = new URLSearchParams();
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          searchParams.append(key, String(value));
        }
      });
      
      if (searchParams.toString()) {
        url += `?${searchParams.toString()}`;
      }
    }
    
    return url;
  }

  private async buildHeaders(customHeaders?: Record<string, string>): Promise<Record<string, string>> {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
      'X-API-Version': this.version,
      'X-Request-ID': this.generateRequestId(),
      ...customHeaders
    };

    // æ·»åŠ è®¤è¯å¤´
    const authToken = await this.authProvider.getToken();
    if (authToken) {
      headers['Authorization'] = `Bearer ${authToken}`;
    }

    return headers;
  }

  private validateResponse(response: any): void {
    if (response.status >= 400) {
      throw new APIError(
        response.data?.error?.code || 'UNKNOWN_ERROR',
        response.data?.error?.message || 'Unknown error occurred',
        response.data?.error?.details
      );
    }
  }

  private generateRequestId(): string {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

// APIé”™è¯¯ç±»
export class APIError extends Error {
  constructor(
    public readonly code: string,
    message: string,
    public readonly details?: any
  ) {
    super(message);
    this.name = 'APIError';
  }
}

// è¯·æ±‚é€‰é¡¹
export interface RequestOptions {
  headers?: Record<string, string>;
  timeout?: number;
  retries?: number;
}
```

#### æœåŠ¡é—´RESTè°ƒç”¨ç¤ºä¾‹
```typescript
// æœåŠ¡é—´RESTè°ƒç”¨ç¤ºä¾‹
// src/services/lead-management/infrastructure/clients/customer-api.client.ts

export class CustomerAPIClient {
  constructor(private readonly restClient: RestAPIClient) {}

  // è·å–å®¢æˆ·ä¿¡æ¯
  async getCustomer(customerId: string): Promise<CustomerDto | null> {
    try {
      const response = await this.restClient.get<CustomerDto>(
        `/customers/${customerId}`
      );
      return response.data || null;
    } catch (error) {
      if (error instanceof APIError && error.code === 'CUSTOMER_NOT_FOUND') {
        return null;
      }
      throw error;
    }
  }

  // éªŒè¯å®¢æˆ·å­˜åœ¨
  async customerExists(customerId: string): Promise<boolean> {
    try {
      await this.restClient.get(`/customers/${customerId}/exists`);
      return true;
    } catch (error) {
      if (error instanceof APIError && error.code === 'CUSTOMER_NOT_FOUND') {
        return false;
      }
      throw error;
    }
  }

  // è·å–å®¢æˆ·åŸºæœ¬ä¿¡æ¯
  async getCustomerBasicInfo(customerId: string): Promise<CustomerBasicInfoDto> {
    const response = await this.restClient.get<CustomerBasicInfoDto>(
      `/customers/${customerId}/basic-info`
    );
    return response.data!;
  }

  // æ‰¹é‡è·å–å®¢æˆ·ä¿¡æ¯
  async getCustomersBatch(customerIds: string[]): Promise<CustomerDto[]> {
    const response = await this.restClient.post<CustomerDto[]>(
      '/customers/batch',
      { customerIds }
    );
    return response.data || [];
  }
}
```

### 2. gRPCé€šä¿¡è§„èŒƒ

#### Protocol Bufferså®šä¹‰
```protobuf
// gRPCæœåŠ¡å®šä¹‰
// proto/customer/customer.proto

syntax = "proto3";

package customer.v1;

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";

// å®¢æˆ·æœåŠ¡
service CustomerService {
  // è·å–å®¢æˆ·ä¿¡æ¯
  rpc GetCustomer(GetCustomerRequest) returns (GetCustomerResponse);
  
  // éªŒè¯å®¢æˆ·å­˜åœ¨
  rpc CustomerExists(CustomerExistsRequest) returns (CustomerExistsResponse);
  
  // è·å–å®¢æˆ·åŸºæœ¬ä¿¡æ¯
  rpc GetCustomerBasicInfo(GetCustomerBasicInfoRequest) returns (GetCustomerBasicInfoResponse);
  
  // æ‰¹é‡è·å–å®¢æˆ·ä¿¡æ¯
  rpc GetCustomersBatch(GetCustomersBatchRequest) returns (GetCustomersBatchResponse);
  
  // åˆ›å»ºå®¢æˆ·
  rpc CreateCustomer(CreateCustomerRequest) returns (CreateCustomerResponse);
  
  // æ›´æ–°å®¢æˆ·ä¿¡æ¯
  rpc UpdateCustomer(UpdateCustomerRequest) returns (UpdateCustomerResponse);
}

// è¯·æ±‚æ¶ˆæ¯
message GetCustomerRequest {
  string customer_id = 1;
}

message CustomerExistsRequest {
  string customer_id = 1;
}

message GetCustomerBasicInfoRequest {
  string customer_id = 1;
}

message GetCustomersBatchRequest {
  repeated string customer_ids = 1;
}

message CreateCustomerRequest {
  string name = 1;
  string email = 2;
  string phone = 3;
  string company = 4;
  string created_by = 5;
}

message UpdateCustomerRequest {
  string customer_id = 1;
  CustomerUpdateData update_data = 2;
  string updated_by = 3;
}

// å“åº”æ¶ˆæ¯
message GetCustomerResponse {
  Customer customer = 1;
}

message CustomerExistsResponse {
  bool exists = 1;
}

message GetCustomerBasicInfoResponse {
  CustomerBasicInfo basic_info = 1;
}

message GetCustomersBatchResponse {
  repeated Customer customers = 1;
}

message CreateCustomerResponse {
  Customer customer = 1;
}

message UpdateCustomerResponse {
  Customer customer = 1;
}

// æ•°æ®æ¨¡å‹
message Customer {
  string id = 1;
  string name = 2;
  string email = 3;
  string phone = 4;
  string company = 5;
  CustomerStatus status = 6;
  CustomerType type = 7;
  repeated string segments = 8;
  google.protobuf.Timestamp created_at = 9;
  google.protobuf.Timestamp updated_at = 10;
}

message CustomerBasicInfo {
  string id = 1;
  string name = 2;
  string email = 3;
  string phone = 4;
}

message CustomerUpdateData {
  optional string name = 1;
  optional string email = 2;
  optional string phone = 3;
  optional string company = 4;
}

// æšä¸¾
enum CustomerStatus {
  CUSTOMER_STATUS_UNSPECIFIED = 0;
  CUSTOMER_STATUS_ACTIVE = 1;
  CUSTOMER_STATUS_INACTIVE = 2;
  CUSTOMER_STATUS_SUSPENDED = 3;
}

enum CustomerType {
  CUSTOMER_TYPE_UNSPECIFIED = 0;
  CUSTOMER_TYPE_PROSPECT = 1;
  CUSTOMER_TYPE_LEAD = 2;
  CUSTOMER_TYPE_CUSTOMER = 3;
  CUSTOMER_TYPE_VIP = 4;
}
```

#### gRPCå®¢æˆ·ç«¯å®ç°
```typescript
// gRPCå®¢æˆ·ç«¯å®ç°
// src/shared/communication/grpc/grpc-client.ts

import * as grpc from '@grpc/grpc-js';
import { CustomerServiceClient } from '../../../proto/customer/customer_grpc_pb';
import { 
  GetCustomerRequest, 
  GetCustomerResponse,
  CustomerExistsRequest,
  CustomerExistsResponse 
} from '../../../proto/customer/customer_pb';

export class GrpcCustomerClient {
  private client: CustomerServiceClient;

  constructor(
    private readonly serviceUrl: string,
    private readonly credentials: grpc.ChannelCredentials,
    private readonly options: grpc.ClientOptions
  ) {
    this.client = new CustomerServiceClient(serviceUrl, credentials, options);
  }

  // è·å–å®¢æˆ·ä¿¡æ¯
  async getCustomer(customerId: string): Promise<Customer | null> {
    return new Promise((resolve, reject) => {
      const request = new GetCustomerRequest();
      request.setCustomerId(customerId);

      this.client.getCustomer(request, (error, response) => {
        if (error) {
          if (error.code === grpc.status.NOT_FOUND) {
            resolve(null);
          } else {
            reject(new GrpcError(error));
          }
          return;
        }

        const customer = response?.getCustomer();
        resolve(customer ? this.mapToCustomer(customer) : null);
      });
    });
  }

  // éªŒè¯å®¢æˆ·å­˜åœ¨
  async customerExists(customerId: string): Promise<boolean> {
    return new Promise((resolve, reject) => {
      const request = new CustomerExistsRequest();
      request.setCustomerId(customerId);

      this.client.customerExists(request, (error, response) => {
        if (error) {
          reject(new GrpcError(error));
          return;
        }

        resolve(response?.getExists() || false);
      });
    });
  }

  // æ‰¹é‡è·å–å®¢æˆ·ä¿¡æ¯
  async getCustomersBatch(customerIds: string[]): Promise<Customer[]> {
    return new Promise((resolve, reject) => {
      const request = new GetCustomersBatchRequest();
      request.setCustomerIdsList(customerIds);

      this.client.getCustomersBatch(request, (error, response) => {
        if (error) {
          reject(new GrpcError(error));
          return;
        }

        const customers = response?.getCustomersList() || [];
        resolve(customers.map(c => this.mapToCustomer(c)));
      });
    });
  }

  private mapToCustomer(grpcCustomer: any): Customer {
    return {
      id: grpcCustomer.getId(),
      name: grpcCustomer.getName(),
      email: grpcCustomer.getEmail(),
      phone: grpcCustomer.getPhone(),
      company: grpcCustomer.getCompany(),
      status: this.mapCustomerStatus(grpcCustomer.getStatus()),
      type: this.mapCustomerType(grpcCustomer.getType()),
      segments: grpcCustomer.getSegmentsList(),
      createdAt: grpcCustomer.getCreatedAt()?.toDate(),
      updatedAt: grpcCustomer.getUpdatedAt()?.toDate()
    };
  }

  private mapCustomerStatus(status: number): CustomerStatus {
    // æ˜ å°„gRPCæšä¸¾åˆ°é¢†åŸŸæšä¸¾
    switch (status) {
      case 1: return CustomerStatus.ACTIVE;
      case 2: return CustomerStatus.INACTIVE;
      case 3: return CustomerStatus.SUSPENDED;
      default: return CustomerStatus.ACTIVE;
    }
  }

  private mapCustomerType(type: number): CustomerType {
    // æ˜ å°„gRPCæšä¸¾åˆ°é¢†åŸŸæšä¸¾
    switch (type) {
      case 1: return CustomerType.PROSPECT;
      case 2: return CustomerType.LEAD;
      case 3: return CustomerType.CUSTOMER;
      case 4: return CustomerType.VIP;
      default: return CustomerType.PROSPECT;
    }
  }
}

// gRPCé”™è¯¯å¤„ç†
export class GrpcError extends Error {
  constructor(public readonly grpcError: grpc.ServiceError) {
    super(grpcError.message);
    this.name = 'GrpcError';
  }

  get code(): grpc.status {
    return this.grpcError.code;
  }

  get details(): string {
    return this.grpcError.details;
  }
}
```

### 3. GraphQLé€šä¿¡è§„èŒƒ

#### GraphQL Schemaå®šä¹‰
```graphql
# GraphQL Schemaå®šä¹‰
# schema/customer.graphql

type Query {
  # è·å–å®¢æˆ·ä¿¡æ¯
  customer(id: ID!): Customer
  
  # è·å–å®¢æˆ·åˆ—è¡¨
  customers(
    filter: CustomerFilter
    pagination: PaginationInput
    sort: CustomerSort
  ): CustomerConnection!
  
  # æœç´¢å®¢æˆ·
  searchCustomers(
    query: String!
    pagination: PaginationInput
  ): CustomerConnection!
}

type Mutation {
  # åˆ›å»ºå®¢æˆ·
  createCustomer(input: CreateCustomerInput!): CreateCustomerPayload!
  
  # æ›´æ–°å®¢æˆ·
  updateCustomer(input: UpdateCustomerInput!): UpdateCustomerPayload!
  
  # åˆ é™¤å®¢æˆ·
  deleteCustomer(id: ID!): DeleteCustomerPayload!
}

type Subscription {
  # å®¢æˆ·çŠ¶æ€å˜æ›´
  customerStatusChanged(customerId: ID): CustomerStatusChangedPayload!
  
  # å®¢æˆ·ä¿¡æ¯æ›´æ–°
  customerUpdated(customerId: ID): CustomerUpdatedPayload!
}

# å®¢æˆ·ç±»å‹
type Customer {
  id: ID!
  name: String!
  email: String!
  phone: String
  company: String
  status: CustomerStatus!
  type: CustomerType!
  segments: [String!]!
  profile: CustomerProfile
  contacts: [CustomerContact!]!
  orders: [Order!]!
  leads: [Lead!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CustomerProfile {
  avatar: String
  bio: String
  preferences: CustomerPreferences
  address: Address
}

type CustomerContact {
  id: ID!
  type: ContactType!
  value: String!
  isPrimary: Boolean!
}

type CustomerPreferences {
  language: String
  timezone: String
  notifications: NotificationPreferences
}

# æšä¸¾ç±»å‹
enum CustomerStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum CustomerType {
  PROSPECT
  LEAD
  CUSTOMER
  VIP
}

enum ContactType {
  EMAIL
  PHONE
  WECHAT
  QQ
}

# è¾“å…¥ç±»å‹
input CustomerFilter {
  status: CustomerStatus
  type: CustomerType
  segments: [String!]
  createdAfter: DateTime
  createdBefore: DateTime
}

input CustomerSort {
  field: CustomerSortField!
  direction: SortDirection!
}

enum CustomerSortField {
  NAME
  EMAIL
  CREATED_AT
  UPDATED_AT
}

enum SortDirection {
  ASC
  DESC
}

input CreateCustomerInput {
  name: String!
  email: String!
  phone: String
  company: String
  type: CustomerType = PROSPECT
}

input UpdateCustomerInput {
  id: ID!
  name: String
  email: String
  phone: String
  company: String
  status: CustomerStatus
  type: CustomerType
}

# è¿æ¥ç±»å‹ï¼ˆåˆ†é¡µï¼‰
type CustomerConnection {
  edges: [CustomerEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CustomerEdge {
  node: Customer!
  cursor: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

# è½½è·ç±»å‹
type CreateCustomerPayload {
  customer: Customer
  errors: [Error!]!
}

type UpdateCustomerPayload {
  customer: Customer
  errors: [Error!]!
}

type DeleteCustomerPayload {
  deletedCustomerId: ID
  errors: [Error!]!
}

type CustomerStatusChangedPayload {
  customer: Customer!
  oldStatus: CustomerStatus!
  newStatus: CustomerStatus!
}

type CustomerUpdatedPayload {
  customer: Customer!
  updatedFields: [String!]!
}

# é€šç”¨ç±»å‹
type Error {
  code: String!
  message: String!
  field: String
}

input PaginationInput {
  first: Int
  after: String
  last: Int
  before: String
}

scalar DateTime
```

#### GraphQLå®¢æˆ·ç«¯å®ç°
```typescript
// GraphQLå®¢æˆ·ç«¯å®ç°
// src/shared/communication/graphql/graphql-client.ts

import { GraphQLClient, gql } from 'graphql-request';

export class GraphQLCustomerClient {
  constructor(
    private readonly client: GraphQLClient,
    private readonly authProvider: AuthProvider
  ) {}

  // è·å–å®¢æˆ·ä¿¡æ¯
  async getCustomer(customerId: string): Promise<Customer | null> {
    const query = gql`
      query GetCustomer($id: ID!) {
        customer(id: $id) {
          id
          name
          email
          phone
          company
          status
          type
          segments
          profile {
            avatar
            bio
            preferences {
              language
              timezone
            }
            address {
              street
              city
              state
              country
              zipCode
            }
          }
          contacts {
            id
            type
            value
            isPrimary
          }
          createdAt
          updatedAt
        }
      }
    `;

    try {
      const headers = await this.getAuthHeaders();
      const response = await this.client.request<{ customer: Customer }>(
        query,
        { id: customerId },
        headers
      );
      return response.customer;
    } catch (error) {
      if (this.isNotFoundError(error)) {
        return null;
      }
      throw new GraphQLError(error);
    }
  }

  // è·å–å®¢æˆ·åˆ—è¡¨
  async getCustomers(
    filter?: CustomerFilter,
    pagination?: PaginationInput,
    sort?: CustomerSort
  ): Promise<CustomerConnection> {
    const query = gql`
      query GetCustomers(
        $filter: CustomerFilter
        $pagination: PaginationInput
        $sort: CustomerSort
      ) {
        customers(filter: $filter, pagination: $pagination, sort: $sort) {
          edges {
            node {
              id
              name
              email
              phone
              company
              status
              type
              segments
              createdAt
              updatedAt
            }
            cursor
          }
          pageInfo {
            hasNextPage
            hasPreviousPage
            startCursor
            endCursor
          }
          totalCount
        }
      }
    `;

    const headers = await this.getAuthHeaders();
    const response = await this.client.request<{ customers: CustomerConnection }>(
      query,
      { filter, pagination, sort },
      headers
    );
    return response.customers;
  }

  // åˆ›å»ºå®¢æˆ·
  async createCustomer(input: CreateCustomerInput): Promise<Customer> {
    const mutation = gql`
      mutation CreateCustomer($input: CreateCustomerInput!) {
        createCustomer(input: $input) {
          customer {
            id
            name
            email
            phone
            company
            status
            type
            segments
            createdAt
            updatedAt
          }
          errors {
            code
            message
            field
          }
        }
      }
    `;

    const headers = await this.getAuthHeaders();
    const response = await this.client.request<{ createCustomer: CreateCustomerPayload }>(
      mutation,
      { input },
      headers
    );

    if (response.createCustomer.errors.length > 0) {
      throw new GraphQLValidationError(response.createCustomer.errors);
    }

    return response.createCustomer.customer!;
  }

  // æ›´æ–°å®¢æˆ·
  async updateCustomer(input: UpdateCustomerInput): Promise<Customer> {
    const mutation = gql`
      mutation UpdateCustomer($input: UpdateCustomerInput!) {
        updateCustomer(input: $input) {
          customer {
            id
            name
            email
            phone
            company
            status
            type
            segments
            createdAt
            updatedAt
          }
          errors {
            code
            message
            field
          }
        }
      }
    `;

    const headers = await this.getAuthHeaders();
    const response = await this.client.request<{ updateCustomer: UpdateCustomerPayload }>(
      mutation,
      { input },
      headers
    );

    if (response.updateCustomer.errors.length > 0) {
      throw new GraphQLValidationError(response.updateCustomer.errors);
    }

    return response.updateCustomer.customer!;
  }

  // è®¢é˜…å®¢æˆ·çŠ¶æ€å˜æ›´
  subscribeToCustomerStatusChanges(customerId?: string): Observable<CustomerStatusChangedPayload> {
    const subscription = gql`
      subscription CustomerStatusChanged($customerId: ID) {
        customerStatusChanged(customerId: $customerId) {
          customer {
            id
            name
            status
          }
          oldStatus
          newStatus
        }
      }
    `;

    return this.client.subscribe<{ customerStatusChanged: CustomerStatusChangedPayload }>(
      subscription,
      { customerId }
    ).pipe(
      map(response => response.customerStatusChanged)
    );
  }

  private async getAuthHeaders(): Promise<Record<string, string>> {
    const token = await this.authProvider.getToken();
    return token ? { Authorization: `Bearer ${token}` } : {};
  }

  private isNotFoundError(error: any): boolean {
    return error?.response?.errors?.some((e: any) => 
      e.extensions?.code === 'NOT_FOUND'
    );
  }
}

// GraphQLé”™è¯¯å¤„ç†
export class GraphQLError extends Error {
  constructor(public readonly originalError: any) {
    super(originalError.message || 'GraphQL request failed');
    this.name = 'GraphQLError';
  }
}

export class GraphQLValidationError extends Error {
  constructor(public readonly errors: Array<{ code: string; message: string; field?: string }>) {
    super(`Validation failed: ${errors.map(e => e.message).join(', ')}`);
    this.name = 'GraphQLValidationError';
  }
}
```

---

## ğŸ“¨ å¼‚æ­¥é€šä¿¡è§„èŒƒ

### 1. äº‹ä»¶é©±åŠ¨é€šä¿¡

#### äº‹ä»¶å®šä¹‰è§„èŒƒ
```typescript
// äº‹ä»¶å®šä¹‰è§„èŒƒ
// src/shared/events/event.standards.ts

// åŸºç¡€äº‹ä»¶æ¥å£
export interface DomainEvent {
  id: string;
  type: string;
  aggregateId: string;
  aggregateType: string;
  version: number;
  data: any;
  metadata: EventMetadata;
  timestamp: Date;
}

export interface IntegrationEvent {
  id: string;
  type: string;
  source: string;
  data: any;
  metadata: EventMetadata;
  timestamp: Date;
}

export interface EventMetadata {
  correlationId: string;
  causationId?: string;
  userId?: string;
  traceId: string;
  version: string;
}

// äº‹ä»¶å‘½åè§„èŒƒ
export enum EventNamingPattern {
  // é¢†åŸŸäº‹ä»¶ï¼š{AggregateType}.{Action}
  LEAD_CREATED = 'Lead.Created',
  LEAD_ASSIGNED = 'Lead.Assigned',
  LEAD_STATUS_CHANGED = 'Lead.StatusChanged',
  LEAD_CONVERTED = 'Lead.Converted',

  // é›†æˆäº‹ä»¶ï¼š{Service}.{AggregateType}.{Action}
  CUSTOMER_SERVICE_CUSTOMER_CREATED = 'CustomerService.Customer.Created',
  ORDER_SERVICE_ORDER_PAID = 'OrderService.Order.Paid',
  NOTIFICATION_SERVICE_EMAIL_SENT = 'NotificationService.Email.Sent'
}

// äº‹ä»¶ç‰ˆæœ¬æ§åˆ¶
export interface EventSchema {
  version: string;
  type: string;
  schema: any; // JSON Schema
  compatibleVersions: string[];
}

// äº‹ä»¶æ³¨å†Œè¡¨
export class EventRegistry {
  private schemas = new Map<string, EventSchema>();

  registerEvent(schema: EventSchema): void {
    const key = `${schema.type}:${schema.version}`;
    this.schemas.set(key, schema);
  }

  getSchema(type: string, version: string): EventSchema | undefined {
    const key = `${type}:${version}`;
    return this.schemas.get(key);
  }

  validateEvent(event: DomainEvent | IntegrationEvent): boolean {
    const schema = this.getSchema(event.type, event.metadata.version);
    if (!schema) {
      throw new Error(`Unknown event type: ${event.type}:${event.metadata.version}`);
    }

    // ä½¿ç”¨JSON SchemaéªŒè¯äº‹ä»¶æ•°æ®
    return this.validateAgainstSchema(event.data, schema.schema);
  }

  private validateAgainstSchema(data: any, schema: any): boolean {
    // JSON SchemaéªŒè¯é€»è¾‘
    return true; // ç®€åŒ–å®ç°
  }
}

// å…·ä½“äº‹ä»¶å®šä¹‰
export class LeadCreatedEvent implements DomainEvent {
  public readonly id: string;
  public readonly type = EventNamingPattern.LEAD_CREATED;
  public readonly timestamp: Date;

  constructor(
    public readonly aggregateId: string,
    public readonly aggregateType: string = 'Lead',
    public readonly version: number,
    public readonly data: LeadCreatedEventData,
    public readonly metadata: EventMetadata
  ) {
    this.id = this.generateEventId();
    this.timestamp = new Date();
  }

  private generateEventId(): string {
    return `evt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

export interface LeadCreatedEventData {
  leadId: string;
  customerId: string;
  priority: string;
  source: string;
  estimatedValue: number;
  assignedTo: string;
  createdBy: string;
}
```

#### äº‹ä»¶å‘å¸ƒè®¢é˜…æœºåˆ¶
```typescript
// äº‹ä»¶å‘å¸ƒè®¢é˜…æœºåˆ¶
// src/shared/events/event-bus.ts

export interface EventBus {
  publish(event: DomainEvent | IntegrationEvent): Promise<void>;
  subscribe<T extends DomainEvent | IntegrationEvent>(
    eventType: string,
    handler: EventHandler<T>
  ): Promise<void>;
  unsubscribe(eventType: string, handler: EventHandler): Promise<void>;
}

export interface EventHandler<T = any> {
  handle(event: T): Promise<void>;
  canHandle(event: any): boolean;
  getEventType(): string;
}

// Redisäº‹ä»¶æ€»çº¿å®ç°
export class RedisEventBus implements EventBus {
  constructor(
    private readonly redis: Redis,
    private readonly eventRegistry: EventRegistry,
    private readonly serializer: EventSerializer,
    private readonly logger: Logger
  ) {}

  async publish(event: DomainEvent | IntegrationEvent): Promise<void> {
    try {
      // éªŒè¯äº‹ä»¶
      this.eventRegistry.validateEvent(event);

      // åºåˆ—åŒ–äº‹ä»¶
      const serializedEvent = this.serializer.serialize(event);

      // å‘å¸ƒåˆ°Redis
      await this.redis.publish(event.type, serializedEvent);

      this.logger.info('Event published', {
        eventId: event.id,
        eventType: event.type,
        aggregateId: 'aggregateId' in event ? event.aggregateId : undefined
      });
    } catch (error) {
      this.logger.error('Failed to publish event', {
        eventId: event.id,
        eventType: event.type,
        error: error.message
      });
      throw error;
    }
  }

  async subscribe<T extends DomainEvent | IntegrationEvent>(
    eventType: string,
    handler: EventHandler<T>
  ): Promise<void> {
    await this.redis.subscribe(eventType);

    this.redis.on('message', async (channel, message) => {
      if (channel === eventType) {
        try {
          const event = this.serializer.deserialize<T>(message);
          
          if (handler.canHandle(event)) {
            await handler.handle(event);
            
            this.logger.info('Event handled successfully', {
              eventId: event.id,
              eventType: event.type,
              handlerName: handler.constructor.name
            });
          }
        } catch (error) {
          this.logger.error('Failed to handle event', {
            eventType,
            handlerName: handler.constructor.name,
            error: error.message
          });
          
          // å‘é€åˆ°æ­»ä¿¡é˜Ÿåˆ—
          await this.sendToDeadLetterQueue(message, error);
        }
      }
    });
  }

  async unsubscribe(eventType: string, handler: EventHandler): Promise<void> {
    await this.redis.unsubscribe(eventType);
  }

  private async sendToDeadLetterQueue(message: string, error: Error): Promise<void> {
    const deadLetterEvent = {
      originalMessage: message,
      error: error.message,
      timestamp: new Date(),
      retryCount: 0
    };

    await this.redis.lpush('dead-letter-queue', JSON.stringify(deadLetterEvent));
  }
}

// äº‹ä»¶åºåˆ—åŒ–å™¨
export class EventSerializer {
  serialize(event: DomainEvent | IntegrationEvent): string {
    return JSON.stringify({
      ...event,
      timestamp: event.timestamp.toISOString()
    });
  }

  deserialize<T extends DomainEvent | IntegrationEvent>(data: string): T {
    const parsed = JSON.parse(data);
    return {
      ...parsed,
      timestamp: new Date(parsed.timestamp)
    } as T;
  }
}

// äº‹ä»¶å¤„ç†å™¨åŸºç±»
export abstract class BaseEventHandler<T extends DomainEvent | IntegrationEvent> 
  implements EventHandler<T> {
  
  abstract handle(event: T): Promise<void>;
  abstract getEventType(): string;

  canHandle(event: any): boolean {
    return event.type === this.getEventType();
  }

  protected async withRetry<R>(
    operation: () => Promise<R>,
    maxRetries: number = 3,
    delay: number = 1000
  ): Promise<R> {
    let lastError: Error;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;
        
        if (attempt < maxRetries) {
          await this.sleep(delay * attempt);
        }
      }
    }

    throw lastError!;
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// å…·ä½“äº‹ä»¶å¤„ç†å™¨ç¤ºä¾‹
export class LeadCreatedEventHandler extends BaseEventHandler<LeadCreatedEvent> {
  constructor(
    private readonly notificationService: NotificationServiceContract,
    private readonly customerService: CustomerServiceContract
  ) {
    super();
  }

  getEventType(): string {
    return EventNamingPattern.LEAD_CREATED;
  }

  async handle(event: LeadCreatedEvent): Promise<void> {
    await this.withRetry(async () => {
      // è·å–å®¢æˆ·ä¿¡æ¯
      const customer = await this.customerService.getCustomer(event.data.customerId);
      if (!customer) {
        throw new Error(`Customer not found: ${event.data.customerId}`);
      }

      // å‘é€é€šçŸ¥ç»™åˆ†é…çš„é”€å”®äººå‘˜
      await this.notificationService.sendSystemNotification(
        event.data.assignedTo,
        'NEW_LEAD_ASSIGNED',
        {
          leadId: event.data.leadId,
          customerName: customer.name,
          priority: event.data.priority,
          estimatedValue: event.data.estimatedValue
        }
      );

      // å‘é€é‚®ä»¶é€šçŸ¥
      await this.notificationService.sendEmail(
        customer.email,
        'æ„Ÿè°¢æ‚¨çš„å’¨è¯¢',
        'æˆ‘ä»¬å·²æ”¶åˆ°æ‚¨çš„å’¨è¯¢ï¼Œé”€å”®é¡¾é—®å°†å°½å¿«ä¸æ‚¨è”ç³»ã€‚'
      );
    });
  }
}
```

### 2. æ¶ˆæ¯é˜Ÿåˆ—é€šä¿¡

#### æ¶ˆæ¯é˜Ÿåˆ—è§„èŒƒ
```typescript
// æ¶ˆæ¯é˜Ÿåˆ—è§„èŒƒ
// src/shared/messaging/message-queue.ts

export interface MessageQueue {
  send(queueName: string, message: Message): Promise<void>;
  receive(queueName: string, handler: MessageHandler): Promise<void>;
  createQueue(queueName: string, options?: QueueOptions): Promise<void>;
  deleteQueue(queueName: string): Promise<void>;
}

export interface Message {
  id: string;
  type: string;
  data: any;
  metadata: MessageMetadata;
  timestamp: Date;
}

export interface MessageMetadata {
  correlationId: string;
  replyTo?: string;
  expiration?: number;
  priority?: number;
  retryCount?: number;
  maxRetries?: number;
}

export interface MessageHandler {
  handle(message: Message): Promise<void>;
  canHandle(message: Message): boolean;
}

export interface QueueOptions {
  durable?: boolean;
  exclusive?: boolean;
  autoDelete?: boolean;
  maxLength?: number;
  messageTTL?: number;
  deadLetterExchange?: string;
}

// RabbitMQæ¶ˆæ¯é˜Ÿåˆ—å®ç°
export class RabbitMQMessageQueue implements MessageQueue {
  constructor(
    private readonly connection: amqp.Connection,
    private readonly channel: amqp.Channel,
    private readonly serializer: MessageSerializer,
    private readonly logger: Logger
  ) {}

  async send(queueName: string, message: Message): Promise<void> {
    try {
      const serializedMessage = this.serializer.serialize(message);
      
      const options: amqp.Options.Publish = {
        persistent: true,
        correlationId: message.metadata.correlationId,
        replyTo: message.metadata.replyTo,
        expiration: message.metadata.expiration,
        priority: message.metadata.priority || 0,
        timestamp: message.timestamp.getTime()
      };

      const sent = this.channel.sendToQueue(
        queueName,
        Buffer.from(serializedMessage),
        options
      );

      if (!sent) {
        throw new Error('Failed to send message to queue');
      }

      this.logger.info('Message sent to queue', {
        messageId: message.id,
        queueName,
        messageType: message.type
      });
    } catch (error) {
      this.logger.error('Failed to send message', {
        messageId: message.id,
        queueName,
        error: error.message
      });
      throw error;
    }
  }

  async receive(queueName: string, handler: MessageHandler): Promise<void> {
    await this.channel.consume(queueName, async (msg) => {
      if (!msg) return;

      try {
        const message = this.serializer.deserialize(msg.content.toString());
        
        if (handler.canHandle(message)) {
          await handler.handle(message);
          this.channel.ack(msg);
          
          this.logger.info('Message processed successfully', {
            messageId: message.id,
            queueName,
            handlerName: handler.constructor.name
          });
        } else {
          this.channel.nack(msg, false, false);
          this.logger.warn('Message rejected by handler', {
            messageId: message.id,
            queueName,
            handlerName: handler.constructor.name
          });
        }
      } catch (error) {
        this.logger.error('Failed to process message', {
          queueName,
          handlerName: handler.constructor.name,
          error: error.message
        });

        // æ£€æŸ¥é‡è¯•æ¬¡æ•°
        const retryCount = this.getRetryCount(msg);
        const maxRetries = this.getMaxRetries(msg);

        if (retryCount < maxRetries) {
          // é‡æ–°å…¥é˜Ÿï¼Œå¢åŠ é‡è¯•æ¬¡æ•°
          await this.requeueWithRetry(msg, retryCount + 1);
          this.channel.ack(msg);
        } else {
          // å‘é€åˆ°æ­»ä¿¡é˜Ÿåˆ—
          this.channel.nack(msg, false, false);
        }
      }
    });
  }

  async createQueue(queueName: string, options: QueueOptions = {}): Promise<void> {
    const queueOptions: amqp.Options.AssertQueue = {
      durable: options.durable !== false,
      exclusive: options.exclusive || false,
      autoDelete: options.autoDelete || false,
      arguments: {}
    };

    if (options.maxLength) {
      queueOptions.arguments!['x-max-length'] = options.maxLength;
    }

    if (options.messageTTL) {
      queueOptions.arguments!['x-message-ttl'] = options.messageTTL;
    }

    if (options.deadLetterExchange) {
      queueOptions.arguments!['x-dead-letter-exchange'] = options.deadLetterExchange;
    }

    await this.channel.assertQueue(queueName, queueOptions);
  }

  async deleteQueue(queueName: string): Promise<void> {
    await this.channel.deleteQueue(queueName);
  }

  private getRetryCount(msg: amqp.ConsumeMessage): number {
    const headers = msg.properties.headers || {};
    return headers['x-retry-count'] || 0;
  }

  private getMaxRetries(msg: amqp.ConsumeMessage): number {
    const headers = msg.properties.headers || {};
    return headers['x-max-retries'] || 3;
  }

  private async requeueWithRetry(msg: amqp.ConsumeMessage, retryCount: number): Promise<void> {
    const headers = { ...msg.properties.headers, 'x-retry-count': retryCount };
    const options: amqp.Options.Publish = {
      ...msg.properties,
      headers
    };

    this.channel.sendToQueue(
      msg.fields.routingKey,
      msg.content,
      options
    );
  }
}

// æ¶ˆæ¯åºåˆ—åŒ–å™¨
export class MessageSerializer {
  serialize(message: Message): string {
    return JSON.stringify({
      ...message,
      timestamp: message.timestamp.toISOString()
    });
  }

  deserialize(data: string): Message {
    const parsed = JSON.parse(data);
    return {
      ...parsed,
      timestamp: new Date(parsed.timestamp)
    };
  }
}
```

---

## ğŸ”’ å®‰å…¨é€šä¿¡è§„èŒƒ

### 1. è®¤è¯æˆæƒæœºåˆ¶

```typescript
// è®¤è¯æˆæƒæœºåˆ¶
// src/shared/security/auth.ts

export interface AuthProvider {
  getToken(): Promise<string | null>;
  refreshToken(): Promise<string>;
  validateToken(token: string): Promise<boolean>;
  getTokenClaims(token: string): Promise<TokenClaims>;
}

export interface TokenClaims {
  sub: string;        // ç”¨æˆ·ID
  iss: string;        // å‘è¡Œè€…
  aud: string;        // å—ä¼—
  exp: number;        // è¿‡æœŸæ—¶é—´
  iat: number;        // ç­¾å‘æ—¶é—´
  scope: string[];    // æƒé™èŒƒå›´
  roles: string[];    // ç”¨æˆ·è§’è‰²
}

// JWTè®¤è¯æä¾›è€…
export class JWTAuthProvider implements AuthProvider {
  constructor(
    private readonly jwtSecret: string,
    private readonly tokenStorage: TokenStorage,
    private readonly authService: AuthServiceClient
  ) {}

  async getToken(): Promise<string | null> {
    let token = await this.tokenStorage.getAccessToken();
    
    if (!token) {
      return null;
    }

    // æ£€æŸ¥tokenæ˜¯å¦å³å°†è¿‡æœŸ
    if (await this.isTokenExpiringSoon(token)) {
      try {
        token = await this.refreshToken();
      } catch (error) {
        // åˆ·æ–°å¤±è´¥ï¼Œè¿”å›null
        return null;
      }
    }

    return token;
  }

  async refreshToken(): Promise<string> {
    const refreshToken = await this.tokenStorage.getRefreshToken();
    if (!refreshToken) {
      throw new Error('No refresh token available');
    }

    const response = await this.authService.refreshToken(refreshToken);
    
    await this.tokenStorage.setAccessToken(response.accessToken);
    await this.tokenStorage.setRefreshToken(response.refreshToken);

    return response.accessToken;
  }

  async validateToken(token: string): Promise<boolean> {
    try {
      jwt.verify(token, this.jwtSecret);
      return true;
    } catch (error) {
      return false;
    }
  }

  async getTokenClaims(token: string): Promise<TokenClaims> {
    const decoded = jwt.verify(token, this.jwtSecret) as any;
    return {
      sub: decoded.sub,
      iss: decoded.iss,
      aud: decoded.aud,
      exp: decoded.exp,
      iat: decoded.iat,
      scope: decoded.scope || [],
      roles: decoded.roles || []
    };
  }

  private async isTokenExpiringSoon(token: string): Promise<boolean> {
    try {
      const claims = await this.getTokenClaims(token);
      const expirationTime = claims.exp * 1000; // è½¬æ¢ä¸ºæ¯«ç§’
      const currentTime = Date.now();
      const timeUntilExpiration = expirationTime - currentTime;
      
      // å¦‚æœtokenåœ¨5åˆ†é’Ÿå†…è¿‡æœŸï¼Œåˆ™è®¤ä¸ºå³å°†è¿‡æœŸ
      return timeUntilExpiration < 5 * 60 * 1000;
    } catch (error) {
      return true; // å¦‚æœæ— æ³•è§£ætokenï¼Œè®¤ä¸ºå·²è¿‡æœŸ
    }
  }
}

// æœåŠ¡é—´è®¤è¯ä¸­é—´ä»¶
export class ServiceAuthMiddleware {
  constructor(
    private readonly authProvider: AuthProvider,
    private readonly permissionChecker: PermissionChecker
  ) {}

  // HTTPä¸­é—´ä»¶
  httpMiddleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
      try {
        const token = this.extractTokenFromRequest(req);
        if (!token) {
          return res.status(401).json({ error: 'Missing authentication token' });
        }

        const isValid = await this.authProvider.validateToken(token);
        if (!isValid) {
          return res.status(401).json({ error: 'Invalid authentication token' });
        }

        const claims = await this.authProvider.getTokenClaims(token);
        
        // æ£€æŸ¥æƒé™
        const hasPermission = await this.permissionChecker.checkPermission(
          claims.sub,
          req.method,
          req.path
        );

        if (!hasPermission) {
          return res.status(403).json({ error: 'Insufficient permissions' });
        }

        // å°†ç”¨æˆ·ä¿¡æ¯æ·»åŠ åˆ°è¯·æ±‚ä¸Šä¸‹æ–‡
        req.user = {
          id: claims.sub,
          roles: claims.roles,
          scope: claims.scope
        };

        next();
      } catch (error) {
        return res.status(500).json({ error: 'Authentication error' });
      }
    };
  }

  // gRPCä¸­é—´ä»¶
  grpcMiddleware() {
    return async (call: any, callback: any, next: any) => {
      try {
        const metadata = call.metadata;
        const token = metadata.get('authorization')[0]?.replace('Bearer ', '');

        if (!token) {
          return callback({
            code: grpc.status.UNAUTHENTICATED,
            message: 'Missing authentication token'
          });
        }

        const isValid = await this.authProvider.validateToken(token);
        if (!isValid) {
          return callback({
            code: grpc.status.UNAUTHENTICATED,
            message: 'Invalid authentication token'
          });
        }

        const claims = await this.authProvider.getTokenClaims(token);
        
        // å°†ç”¨æˆ·ä¿¡æ¯æ·»åŠ åˆ°è°ƒç”¨ä¸Šä¸‹æ–‡
        call.user = {
          id: claims.sub,
          roles: claims.roles,
          scope: claims.scope
        };

        next();
      } catch (error) {
        return callback({
          code: grpc.status.INTERNAL,
          message: 'Authentication error'
        });
      }
    };
  }

  private extractTokenFromRequest(req: Request): string | null {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return null;
    }
    return authHeader.substring(7);
  }
}
```

### 2. æ•°æ®åŠ å¯†ä¼ è¾“

```typescript
// æ•°æ®åŠ å¯†ä¼ è¾“
// src/shared/security/encryption.ts

export interface EncryptionService {
  encrypt(data: string): Promise<string>;
  decrypt(encryptedData: string): Promise<string>;
  hash(data: string): Promise<string>;
  verifyHash(data: string, hash: string): Promise<boolean>;
}

// AESåŠ å¯†æœåŠ¡
export class AESEncryptionService implements EncryptionService {
  constructor(
    private readonly secretKey: string,
    private readonly algorithm: string = 'aes-256-gcm'
  ) {}

  async encrypt(data: string): Promise<string> {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.algorithm, this.secretKey);
    cipher.setAAD(Buffer.from('additional-data'));

    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    const authTag = cipher.getAuthTag();

    return JSON.stringify({
      iv: iv.toString('hex'),
      encrypted,
      authTag: authTag.toString('hex')
    });
  }

  async decrypt(encryptedData: string): Promise<string> {
    const { iv, encrypted, authTag } = JSON.parse(encryptedData);

    const decipher = crypto.createDecipher(this.algorithm, this.secretKey);
    decipher.setAAD(Buffer.from('additional-data'));
    decipher.setAuthTag(Buffer.from(authTag, 'hex'));

    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }

  async hash(data: string): Promise<string> {
    return crypto.createHash('sha256').update(data).digest('hex');
  }

  async verifyHash(data: string, hash: string): Promise<boolean> {
    const computedHash = await this.hash(data);
    return computedHash === hash;
  }
}

// TLSé…ç½®
export class TLSConfig {
  static getHTTPSOptions(): https.ServerOptions {
    return {
      key: fs.readFileSync(process.env.TLS_PRIVATE_KEY_PATH!),
      cert: fs.readFileSync(process.env.TLS_CERTIFICATE_PATH!),
      ca: fs.readFileSync(process.env.TLS_CA_PATH!),
      requestCert: true,
      rejectUnauthorized: true,
      secureProtocol: 'TLSv1_2_method',
      ciphers: [
        'ECDHE-RSA-AES128-GCM-SHA256',
        'ECDHE-RSA-AES256-GCM-SHA384',
        'ECDHE-RSA-AES128-SHA256',
        'ECDHE-RSA-AES256-SHA384'
      ].join(':'),
      honorCipherOrder: true
    };
  }

  static getGRPCCredentials(): grpc.ServerCredentials {
    const privateKey = fs.readFileSync(process.env.TLS_PRIVATE_KEY_PATH!);
    const certChain = fs.readFileSync(process.env.TLS_CERTIFICATE_PATH!);
    const rootCerts = fs.readFileSync(process.env.TLS_CA_PATH!);

    return grpc.ServerCredentials.createSsl(
      rootCerts,
      [{ private_key: privateKey, cert_chain: certChain }],
      true
    );
  }
}
```

---

## ğŸ“Š ç›‘æ§ä¸å¯è§‚æµ‹æ€§

### 1. åˆ†å¸ƒå¼è¿½è¸ª

```typescript
// åˆ†å¸ƒå¼è¿½è¸ª
// src/shared/observability/tracing.ts

export interface TracingService {
  startSpan(operationName: string, parentSpan?: Span): Span;
  finishSpan(span: Span): void;
  injectHeaders(span: Span): Record<string, string>;
  extractSpan(headers: Record<string, string>): Span | null;
}

export interface Span {
  id: string;
  traceId: string;
  parentId?: string;
  operationName: string;
  startTime: Date;
  endTime?: Date;
  tags: Record<string, any>;
  logs: SpanLog[];
}

export interface SpanLog {
  timestamp: Date;
  level: string;
  message: string;
  fields?: Record<string, any>;
}

// Jaegerè¿½è¸ªæœåŠ¡
export class JaegerTracingService implements TracingService {
  constructor(
    private readonly tracer: opentracing.Tracer,
    private readonly serviceName: string
  ) {}

  startSpan(operationName: string, parentSpan?: Span): Span {
    const spanOptions: opentracing.SpanOptions = {
      tags: {
        [opentracing.Tags.COMPONENT]: this.serviceName,
        [opentracing.Tags.SPAN_KIND]: opentracing.Tags.SPAN_KIND_RPC_SERVER
      }
    };

    if (parentSpan) {
      spanOptions.childOf = parentSpan as any;
    }

    const span = this.tracer.startSpan(operationName, spanOptions);
    
    return {
      id: span.context().toSpanId(),
      traceId: span.context().toTraceId(),
      parentId: parentSpan?.id,
      operationName,
      startTime: new Date(),
      tags: {},
      logs: []
    } as Span;
  }

  finishSpan(span: Span): void {
    span.endTime = new Date();
    (span as any).finish();
  }

  injectHeaders(span: Span): Record<string, string> {
    const headers: Record<string, string> = {};
    this.tracer.inject(span as any, opentracing.FORMAT_HTTP_HEADERS, headers);
    return headers;
  }

  extractSpan(headers: Record<string, string>): Span | null {
    const spanContext = this.tracer.extract(opentracing.FORMAT_HTTP_HEADERS, headers);
    if (!spanContext) {
      return null;
    }

    return spanContext as any;
  }
}

// è¿½è¸ªä¸­é—´ä»¶
export class TracingMiddleware {
  constructor(private readonly tracingService: TracingService) {}

  // HTTPè¿½è¸ªä¸­é—´ä»¶
  httpMiddleware() {
    return (req: Request, res: Response, next: NextFunction) => {
      const parentSpan = this.tracingService.extractSpan(req.headers as any);
      const span = this.tracingService.startSpan(
        `${req.method} ${req.path}`,
        parentSpan || undefined
      );

      // æ·»åŠ æ ‡ç­¾
      span.tags = {
        'http.method': req.method,
        'http.url': req.url,
        'http.user_agent': req.headers['user-agent'],
        'user.id': req.user?.id
      };

      // å°†spanæ·»åŠ åˆ°è¯·æ±‚ä¸Šä¸‹æ–‡
      req.span = span;

      // å“åº”å®Œæˆæ—¶ç»“æŸspan
      res.on('finish', () => {
        span.tags['http.status_code'] = res.statusCode;
        if (res.statusCode >= 400) {
          span.tags['error'] = true;
        }
        this.tracingService.finishSpan(span);
      });

      next();
    };
  }

  // gRPCè¿½è¸ªä¸­é—´ä»¶
  grpcMiddleware() {
    return (call: any, callback: any, next: any) => {
      const metadata = call.metadata;
      const headers: Record<string, string> = {};
      
      metadata.forEach((value: string, key: string) => {
        headers[key] = value;
      });

      const parentSpan = this.tracingService.extractSpan(headers);
      const span = this.tracingService.startSpan(
        call.getPath(),
        parentSpan || undefined
      );

      // æ·»åŠ æ ‡ç­¾
      span.tags = {
        'rpc.service': call.getPath().split('/')[1],
        'rpc.method': call.getPath().split('/')[2],
        'user.id': call.user?.id
      };

      call.span = span;

      // åŒ…è£…å›è°ƒä»¥ç»“æŸspan
      const originalCallback = callback;
      callback = (error: any, response: any) => {
        if (error) {
          span.tags['error'] = true;
          span.tags['error.message'] = error.message;
        }
        this.tracingService.finishSpan(span);
        originalCallback(error, response);
      };

      next();
    };
  }
}
```

### 2. æ€§èƒ½ç›‘æ§

```typescript
// æ€§èƒ½ç›‘æ§
// src/shared/observability/metrics.ts

export interface MetricsCollector {
  incrementCounter(name: string, labels?: Record<string, string>): void;
  recordHistogram(name: string, value: number, labels?: Record<string, string>): void;
  setGauge(name: string, value: number, labels?: Record<string, string>): void;
  recordTimer(name: string, duration: number, labels?: Record<string, string>): void;
}

// PrometheusæŒ‡æ ‡æ”¶é›†å™¨
export class PrometheusMetricsCollector implements MetricsCollector {
  private readonly registry: prometheus.Registry;
  private readonly counters = new Map<string, prometheus.Counter>();
  private readonly histograms = new Map<string, prometheus.Histogram>();
  private readonly gauges = new Map<string, prometheus.Gauge>();

  constructor() {
    this.registry = new prometheus.Registry();
    prometheus.collectDefaultMetrics({ register: this.registry });
  }

  incrementCounter(name: string, labels: Record<string, string> = {}): void {
    let counter = this.counters.get(name);
    if (!counter) {
      counter = new prometheus.Counter({
        name,
        help: `Counter for ${name}`,
        labelNames: Object.keys(labels),
        registers: [this.registry]
      });
      this.counters.set(name, counter);
    }

    counter.inc(labels);
  }

  recordHistogram(name: string, value: number, labels: Record<string, string> = {}): void {
    let histogram = this.histograms.get(name);
    if (!histogram) {
      histogram = new prometheus.Histogram({
        name,
        help: `Histogram for ${name}`,
        labelNames: Object.keys(labels),
        buckets: [0.1, 0.5, 1, 2, 5, 10, 30, 60],
        registers: [this.registry]
      });
      this.histograms.set(name, histogram);
    }

    histogram.observe(labels, value);
  }

  setGauge(name: string, value: number, labels: Record<string, string> = {}): void {
    let gauge = this.gauges.get(name);
    if (!gauge) {
      gauge = new prometheus.Gauge({
        name,
        help: `Gauge for ${name}`,
        labelNames: Object.keys(labels),
        registers: [this.registry]
      });
      this.gauges.set(name, gauge);
    }

    gauge.set(labels, value);
  }

  recordTimer(name: string, duration: number, labels: Record<string, string> = {}): void {
    this.recordHistogram(`${name}_duration_seconds`, duration / 1000, labels);
  }

  getMetrics(): string {
    return this.registry.metrics();
  }
}

// æ€§èƒ½ç›‘æ§ä¸­é—´ä»¶
export class PerformanceMonitoringMiddleware {
  constructor(private readonly metricsCollector: MetricsCollector) {}

  // HTTPæ€§èƒ½ç›‘æ§
  httpMiddleware() {
    return (req: Request, res: Response, next: NextFunction) => {
      const startTime = Date.now();
      
      // è®°å½•è¯·æ±‚è®¡æ•°
      this.metricsCollector.incrementCounter('http_requests_total', {
        method: req.method,
        endpoint: req.route?.path || req.path
      });

      res.on('finish', () => {
        const duration = Date.now() - startTime;
        
        // è®°å½•å“åº”æ—¶é—´
        this.metricsCollector.recordTimer('http_request_duration', duration, {
          method: req.method,
          endpoint: req.route?.path || req.path,
          status_code: res.statusCode.toString()
        });

        // è®°å½•å“åº”çŠ¶æ€
        this.metricsCollector.incrementCounter('http_responses_total', {
          method: req.method,
          endpoint: req.route?.path || req.path,
          status_code: res.statusCode.toString()
        });
      });

      next();
    };
  }

  // gRPCæ€§èƒ½ç›‘æ§
  grpcMiddleware() {
    return (call: any, callback: any, next: any) => {
      const startTime = Date.now();
      const serviceName = call.getPath().split('/')[1];
      const methodName = call.getPath().split('/')[2];

      // è®°å½•è¯·æ±‚è®¡æ•°
      this.metricsCollector.incrementCounter('grpc_requests_total', {
        service: serviceName,
        method: methodName
      });

      const originalCallback = callback;
      callback = (error: any, response: any) => {
        const duration = Date.now() - startTime;
        
        // è®°å½•å“åº”æ—¶é—´
        this.metricsCollector.recordTimer('grpc_request_duration', duration, {
          service: serviceName,
          method: methodName,
          status: error ? 'error' : 'success'
        });

        // è®°å½•å“åº”çŠ¶æ€
        this.metricsCollector.incrementCounter('grpc_responses_total', {
          service: serviceName,
          method: methodName,
          status: error ? 'error' : 'success'
        });

        originalCallback(error, response);
      };

      next();
    };
  }
}
```

---

## ğŸ”§ é”™è¯¯å¤„ç†ä¸é‡è¯•æœºåˆ¶

### 1. ç»Ÿä¸€é”™è¯¯å¤„ç†

```typescript
// ç»Ÿä¸€é”™è¯¯å¤„ç†
// src/shared/errors/error-handling.ts

export enum ErrorCode {
  // é€šç”¨é”™è¯¯
  UNKNOWN_ERROR = 'UNKNOWN_ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  AUTHENTICATION_ERROR = 'AUTHENTICATION_ERROR',
  AUTHORIZATION_ERROR = 'AUTHORIZATION_ERROR',
  
  // ä¸šåŠ¡é”™è¯¯
  RESOURCE_NOT_FOUND = 'RESOURCE_NOT_FOUND',
  RESOURCE_CONFLICT = 'RESOURCE_CONFLICT',
  BUSINESS_RULE_VIOLATION = 'BUSINESS_RULE_VIOLATION',
  
  // ç³»ç»Ÿé”™è¯¯
  SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',
  TIMEOUT_ERROR = 'TIMEOUT_ERROR',
  NETWORK_ERROR = 'NETWORK_ERROR',
  DATABASE_ERROR = 'DATABASE_ERROR'
}

export class ServiceError extends Error {
  constructor(
    public readonly code: ErrorCode,
    message: string,
    public readonly details?: any,
    public readonly cause?: Error
  ) {
    super(message);
    this.name = 'ServiceError';
  }

  toJSON() {
    return {
      code: this.code,
      message: this.message,
      details: this.details,
      timestamp: new Date().toISOString()
    };
  }
}

// é”™è¯¯å¤„ç†ä¸­é—´ä»¶
export class ErrorHandlingMiddleware {
  constructor(private readonly logger: Logger) {}

  // HTTPé”™è¯¯å¤„ç†
  httpErrorHandler() {
    return (error: Error, req: Request, res: Response, next: NextFunction) => {
      this.logger.error('HTTP request error', {
        error: error.message,
        stack: error.stack,
        url: req.url,
        method: req.method,
        userAgent: req.headers['user-agent']
      });

      if (error instanceof ServiceError) {
        const statusCode = this.mapErrorCodeToHttpStatus(error.code);
        res.status(statusCode).json({
          success: false,
          error: error.toJSON()
        });
      } else {
        res.status(500).json({
          success: false,
          error: {
            code: ErrorCode.UNKNOWN_ERROR,
            message: 'Internal server error',
            timestamp: new Date().toISOString()
          }
        });
      }
    };
  }

  // gRPCé”™è¯¯å¤„ç†
  grpcErrorHandler() {
    return (error: Error, call: any, callback: any) => {
      this.logger.error('gRPC request error', {
        error: error.message,
        stack: error.stack,
        service: call.getPath()
      });

      if (error instanceof ServiceError) {
        const grpcStatus = this.mapErrorCodeToGrpcStatus(error.code);
        callback({
          code: grpcStatus,
          message: error.message,
          details: error.details
        });
      } else {
        callback({
          code: grpc.status.INTERNAL,
          message: 'Internal server error'
        });
      }
    };
  }

  private mapErrorCodeToHttpStatus(errorCode: ErrorCode): number {
    switch (errorCode) {
      case ErrorCode.VALIDATION_ERROR:
        return 400;
      case ErrorCode.AUTHENTICATION_ERROR:
        return 401;
      case ErrorCode.AUTHORIZATION_ERROR:
        return 403;
      case ErrorCode.RESOURCE_NOT_FOUND:
        return 404;
      case ErrorCode.RESOURCE_CONFLICT:
        return 409;
      case ErrorCode.BUSINESS_RULE_VIOLATION:
        return 422;
      case ErrorCode.SERVICE_UNAVAILABLE:
        return 503;
      case ErrorCode.TIMEOUT_ERROR:
        return 504;
      default:
        return 500;
    }
  }

  private mapErrorCodeToGrpcStatus(errorCode: ErrorCode): grpc.status {
    switch (errorCode) {
      case ErrorCode.VALIDATION_ERROR:
        return grpc.status.INVALID_ARGUMENT;
      case ErrorCode.AUTHENTICATION_ERROR:
        return grpc.status.UNAUTHENTICATED;
      case ErrorCode.AUTHORIZATION_ERROR:
        return grpc.status.PERMISSION_DENIED;
      case ErrorCode.RESOURCE_NOT_FOUND:
        return grpc.status.NOT_FOUND;
      case ErrorCode.RESOURCE_CONFLICT:
        return grpc.status.ALREADY_EXISTS;
      case ErrorCode.SERVICE_UNAVAILABLE:
        return grpc.status.UNAVAILABLE;
      case ErrorCode.TIMEOUT_ERROR:
        return grpc.status.DEADLINE_EXCEEDED;
      default:
        return grpc.status.INTERNAL;
    }
  }
}
```

### 2. é‡è¯•æœºåˆ¶

```typescript
// é‡è¯•æœºåˆ¶
// src/shared/resilience/retry.ts

export interface RetryPolicy {
  execute<T>(operation: () => Promise<T>): Promise<T>;
}

export interface RetryOptions {
  maxRetries: number;
  baseDelay: number;
  maxDelay: number;
  backoffMultiplier: number;
  retryableErrors: ErrorCode[];
}

// æŒ‡æ•°é€€é¿é‡è¯•ç­–ç•¥
export class ExponentialBackoffRetryPolicy implements RetryPolicy {
  constructor(private readonly options: RetryOptions) {}

  async execute<T>(operation: () => Promise<T>): Promise<T> {
    let lastError: Error;
    
    for (let attempt = 0; attempt <= this.options.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºå¯é‡è¯•é”™è¯¯
        if (!this.isRetryableError(error as Error)) {
          throw error;
        }
        
        // å¦‚æœå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼ŒæŠ›å‡ºé”™è¯¯
        if (attempt === this.options.maxRetries) {
          throw error;
        }
        
        // è®¡ç®—å»¶è¿Ÿæ—¶é—´
        const delay = this.calculateDelay(attempt);
        await this.sleep(delay);
      }
    }
    
    throw lastError!;
  }

  private isRetryableError(error: Error): boolean {
    if (error instanceof ServiceError) {
      return this.options.retryableErrors.includes(error.code);
    }
    
    // ç½‘ç»œé”™è¯¯é€šå¸¸å¯é‡è¯•
    return error.message.includes('ECONNRESET') ||
           error.message.includes('ETIMEDOUT') ||
           error.message.includes('ENOTFOUND');
  }

  private calculateDelay(attempt: number): number {
    const delay = this.options.baseDelay * Math.pow(this.options.backoffMultiplier, attempt);
    return Math.min(delay, this.options.maxDelay);
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// ç†”æ–­å™¨
export interface CircuitBreaker {
  execute<T>(operation: () => Promise<T>): Promise<T>;
  getState(): CircuitBreakerState;
}

export enum CircuitBreakerState {
  CLOSED = 'CLOSED',
  OPEN = 'OPEN',
  HALF_OPEN = 'HALF_OPEN'
}

export interface CircuitBreakerOptions {
  failureThreshold: number;
  recoveryTimeout: number;
  monitoringPeriod: number;
}

export class SimpleCircuitBreaker implements CircuitBreaker {
  private state = CircuitBreakerState.CLOSED;
  private failureCount = 0;
  private lastFailureTime = 0;
  private successCount = 0;

  constructor(private readonly options: CircuitBreakerOptions) {}

  async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === CircuitBreakerState.OPEN) {
      if (this.shouldAttemptReset()) {
        this.state = CircuitBreakerState.HALF_OPEN;
      } else {
        throw new ServiceError(
          ErrorCode.SERVICE_UNAVAILABLE,
          'Circuit breaker is open'
        );
      }
    }

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  getState(): CircuitBreakerState {
    return this.state;
  }

  private onSuccess(): void {
    this.failureCount = 0;
    
    if (this.state === CircuitBreakerState.HALF_OPEN) {
      this.successCount++;
      if (this.successCount >= 3) { // è¿ç»­3æ¬¡æˆåŠŸåå…³é—­ç†”æ–­å™¨
        this.state = CircuitBreakerState.CLOSED;
        this.successCount = 0;
      }
    }
  }

  private onFailure(): void {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.failureCount >= this.options.failureThreshold) {
      this.state = CircuitBreakerState.OPEN;
    }
    
    if (this.state === CircuitBreakerState.HALF_OPEN) {
      this.state = CircuitBreakerState.OPEN;
      this.successCount = 0;
    }
  }

  private shouldAttemptReset(): boolean {
    return Date.now() - this.lastFailureTime >= this.options.recoveryTimeout;
  }
}
```

---

## ğŸ“ˆ æ€»ç»“

æœ¬æœåŠ¡é—´é€šä¿¡è§„èŒƒè®¾è®¡æ–¹æ¡ˆä¸ºç½—è±L2Cé”€å”®ç®¡ç†ç³»ç»Ÿæä¾›äº†å®Œæ•´çš„å¾®æœåŠ¡é€šä¿¡è§£å†³æ–¹æ¡ˆï¼š

### ğŸ¯ æ ¸å¿ƒä»·å€¼
- **æ ‡å‡†åŒ–é€šä¿¡**ï¼šå»ºç«‹äº†ç»Ÿä¸€çš„HTTP/RESTã€gRPCã€GraphQLé€šä¿¡è§„èŒƒ
- **å¼‚æ­¥è§£è€¦**ï¼šé€šè¿‡äº‹ä»¶é©±åŠ¨å’Œæ¶ˆæ¯é˜Ÿåˆ—å®ç°æœåŠ¡é—´å¼‚æ­¥é€šä¿¡
- **å®‰å…¨ä¿éšœ**ï¼šæä¾›å®Œæ•´çš„è®¤è¯æˆæƒå’Œæ•°æ®åŠ å¯†æœºåˆ¶
- **å¯è§‚æµ‹æ€§**ï¼šé›†æˆåˆ†å¸ƒå¼è¿½è¸ªå’Œæ€§èƒ½ç›‘æ§èƒ½åŠ›
- **é«˜å¯ç”¨æ€§**ï¼šé€šè¿‡é‡è¯•æœºåˆ¶å’Œç†”æ–­å™¨ä¿éšœç³»ç»Ÿç¨³å®šæ€§

### ğŸ—ï¸ æ¶æ„ç‰¹ç‚¹
- **å¤šåè®®æ”¯æŒ**ï¼šæ”¯æŒåŒæ­¥å’Œå¼‚æ­¥å¤šç§é€šä¿¡åè®®
- **å®‰å…¨ç¬¬ä¸€**ï¼šç«¯åˆ°ç«¯çš„å®‰å…¨é€šä¿¡ä¿éšœ
- **ç›‘æ§å®Œå¤‡**ï¼šå…¨é“¾è·¯è¿½è¸ªå’Œæ€§èƒ½ç›‘æ§
- **å®¹é”™è®¾è®¡**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶
- **æ‰©å±•çµæ´»**ï¼šæ”¯æŒæœåŠ¡çš„ç‹¬ç«‹æ‰©å±•å’Œéƒ¨ç½²

### ğŸš€ å®æ–½ä¼˜åŠ¿
- **å¼€å‘æ•ˆç‡**ï¼šç»Ÿä¸€çš„é€šä¿¡æ ‡å‡†é™ä½å¼€å‘å¤æ‚åº¦
- **è¿ç»´ä¾¿åˆ©**ï¼šæ ‡å‡†åŒ–çš„ç›‘æ§å’Œæ—¥å¿—ä¾¿äºè¿ç»´ç®¡ç†
- **ç³»ç»Ÿç¨³å®š**ï¼šå¤šå±‚æ¬¡çš„å®¹é”™æœºåˆ¶ä¿éšœç³»ç»Ÿç¨³å®šè¿è¡Œ
- **æ€§èƒ½ä¼˜åŒ–**ï¼šé«˜æ•ˆçš„é€šä¿¡åè®®å’Œç¼“å­˜æœºåˆ¶
- **å®‰å…¨å¯é **ï¼šä¼ä¸šçº§çš„å®‰å…¨é€šä¿¡ä¿éšœ
