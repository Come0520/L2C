# 罗莱L2C销售管理系统 - 安全规范与最佳实践

## 1. 规范目标

### 1.1 核心目标
- **数据保护**：确保客户数据、销售数据、财务数据的安全性
- **访问控制**：实现细粒度的权限管理和身份验证
- **漏洞防护**：预防常见的Web安全漏洞
- **合规要求**：满足数据保护法规要求
- **安全监控**：建立完善的安全监控和审计机制

### 1.2 安全原则
- **最小权限原则**：用户只能访问完成工作所需的最小权限
- **深度防御**：多层安全防护机制
- **零信任架构**：不信任任何内部或外部的网络流量
- **数据分类**：根据敏感程度对数据进行分类保护
- **安全左移**：在开发阶段就考虑安全问题

## 2. 身份认证与授权

### 2.1 JWT Token 管理
```javascript
// JWT配置
const JWT_CONFIG = {
  accessTokenExpiry: '15m',      // 访问令牌15分钟过期
  refreshTokenExpiry: '7d',      // 刷新令牌7天过期
  algorithm: 'HS256',
  issuer: 'l2c-system',
  audience: 'l2c-users'
};

// Token生成
function generateTokens(user) {
  const payload = {
    userId: user.id,
    username: user.username,
    roles: user.roles,
    permissions: user.permissions
  };
  
  const accessToken = jwt.sign(payload, process.env.JWT_SECRET, {
    expiresIn: JWT_CONFIG.accessTokenExpiry,
    issuer: JWT_CONFIG.issuer,
    audience: JWT_CONFIG.audience
  });
  
  const refreshToken = jwt.sign(
    { userId: user.id, tokenType: 'refresh' },
    process.env.JWT_REFRESH_SECRET,
    { expiresIn: JWT_CONFIG.refreshTokenExpiry }
  );
  
  return { accessToken, refreshToken };
}
```

### 2.2 密码安全策略
```javascript
// 密码复杂度要求
const PASSWORD_POLICY = {
  minLength: 8,
  maxLength: 128,
  requireUppercase: true,
  requireLowercase: true,
  requireNumbers: true,
  requireSpecialChars: true,
  preventCommonPasswords: true,
  preventUserInfoInPassword: true
};

// 密码加密
const bcrypt = require('bcrypt');
const SALT_ROUNDS = 12;

async function hashPassword(password) {
  return await bcrypt.hash(password, SALT_ROUNDS);
}

async function verifyPassword(password, hash) {
  return await bcrypt.compare(password, hash);
}
```

### 2.3 多因素认证 (MFA)
```javascript
// MFA配置
const MFA_CONFIG = {
  enabled: true,
  methods: ['totp', 'sms', 'email'],
  backupCodes: 10,
  totpWindow: 1,
  smsCodeExpiry: 300, // 5分钟
  emailCodeExpiry: 600 // 10分钟
};
```

## 3. 数据保护与加密

### 3.1 敏感数据分类
```javascript
// 数据敏感级别
const DATA_CLASSIFICATION = {
  PUBLIC: 'public',           // 公开数据
  INTERNAL: 'internal',       // 内部数据
  CONFIDENTIAL: 'confidential', // 机密数据
  RESTRICTED: 'restricted'    // 限制数据
};

// 敏感字段标识
const SENSITIVE_FIELDS = {
  // 个人信息
  personalInfo: ['phone', 'email', 'idCard', 'address'],
  // 财务信息
  financial: ['bankAccount', 'creditCard', 'salary', 'commission'],
  // 业务机密
  business: ['customerList', 'priceStrategy', 'salesTarget']
};
```

### 3.2 数据加密策略
```javascript
const crypto = require('crypto');

// AES加密配置
const ENCRYPTION_CONFIG = {
  algorithm: 'aes-256-gcm',
  keyLength: 32,
  ivLength: 16,
  tagLength: 16
};

// 字段级加密
class FieldEncryption {
  static encrypt(data, key) {
    const iv = crypto.randomBytes(ENCRYPTION_CONFIG.ivLength);
    const cipher = crypto.createCipher(ENCRYPTION_CONFIG.algorithm, key, iv);
    
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const tag = cipher.getAuthTag();
    
    return {
      encrypted,
      iv: iv.toString('hex'),
      tag: tag.toString('hex')
    };
  }
  
  static decrypt(encryptedData, key) {
    const decipher = crypto.createDecipher(
      ENCRYPTION_CONFIG.algorithm,
      key,
      Buffer.from(encryptedData.iv, 'hex')
    );
    
    decipher.setAuthTag(Buffer.from(encryptedData.tag, 'hex'));
    
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}
```

### 3.3 数据脱敏
```javascript
// 数据脱敏工具
class DataMasking {
  static maskPhone(phone) {
    return phone.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
  }
  
  static maskEmail(email) {
    const [username, domain] = email.split('@');
    const maskedUsername = username.length > 2 
      ? username.substring(0, 2) + '*'.repeat(username.length - 2)
      : username;
    return `${maskedUsername}@${domain}`;
  }
  
  static maskIdCard(idCard) {
    return idCard.replace(/(\d{6})\d{8}(\d{4})/, '$1********$2');
  }
  
  static maskBankAccount(account) {
    return account.replace(/(\d{4})\d+(\d{4})/, '$1****$2');
  }
}
```

## 4. API安全防护

### 4.1 输入验证与清理
```javascript
const Joi = require('joi');
const DOMPurify = require('isomorphic-dompurify');

// 输入验证模式
const INPUT_SCHEMAS = {
  // 用户注册
  userRegistration: Joi.object({
    username: Joi.string().alphanum().min(3).max(30).required(),
    email: Joi.string().email().required(),
    password: Joi.string().min(8).pattern(PASSWORD_REGEX).required(),
    phone: Joi.string().pattern(/^1[3-9]\d{9}$/).required()
  }),
  
  // 销售数据
  salesData: Joi.object({
    amount: Joi.number().positive().precision(2).required(),
    customerId: Joi.string().uuid().required(),
    productIds: Joi.array().items(Joi.string().uuid()).min(1).required(),
    discount: Joi.number().min(0).max(1).default(0)
  })
};

// XSS防护
function sanitizeInput(input) {
  if (typeof input === 'string') {
    return DOMPurify.sanitize(input);
  }
  return input;
}
```

### 4.2 SQL注入防护
```javascript
// 使用参数化查询
class DatabaseSecurity {
  static async getUserById(userId) {
    // ✅ 正确：使用参数化查询
    const query = 'SELECT * FROM users WHERE id = ?';
    return await db.query(query, [userId]);
  }
  
  static async searchUsers(keyword) {
    // ❌ 错误：直接拼接SQL
    // const query = `SELECT * FROM users WHERE name LIKE '%${keyword}%'`;
    
    // ✅ 正确：使用参数化查询
    const query = 'SELECT * FROM users WHERE name LIKE ?';
    return await db.query(query, [`%${keyword}%`]);
  }
}
```

### 4.3 API限流与防护
```javascript
const rateLimit = require('express-rate-limit');
const slowDown = require('express-slow-down');

// 通用限流配置
const RATE_LIMIT_CONFIG = {
  // 登录接口限流
  login: rateLimit({
    windowMs: 15 * 60 * 1000, // 15分钟
    max: 5, // 最多5次尝试
    message: '登录尝试次数过多，请15分钟后再试',
    standardHeaders: true,
    legacyHeaders: false
  }),
  
  // API接口限流
  api: rateLimit({
    windowMs: 1 * 60 * 1000, // 1分钟
    max: 100, // 最多100次请求
    message: 'API请求频率过高，请稍后再试'
  }),
  
  // 慢速响应
  slowDown: slowDown({
    windowMs: 15 * 60 * 1000, // 15分钟
    delayAfter: 50, // 50次请求后开始延迟
    delayMs: 500 // 每次增加500ms延迟
  })
};
```

## 5. 前端安全防护

### 5.1 CSP内容安全策略
```javascript
// CSP配置
const CSP_POLICY = {
  'default-src': ["'self'"],
  'script-src': ["'self'", "'unsafe-inline'", 'https://cdn.jsdelivr.net'],
  'style-src': ["'self'", "'unsafe-inline'", 'https://fonts.googleapis.com'],
  'img-src': ["'self'", 'data:', 'https:'],
  'font-src': ["'self'", 'https://fonts.gstatic.com'],
  'connect-src': ["'self'", 'https://api.l2c.com'],
  'frame-ancestors': ["'none'"],
  'base-uri': ["'self'"],
  'form-action': ["'self'"]
};

// Express中间件
app.use((req, res, next) => {
  const cspString = Object.entries(CSP_POLICY)
    .map(([key, values]) => `${key} ${values.join(' ')}`)
    .join('; ');
  
  res.setHeader('Content-Security-Policy', cspString);
  next();
});
```

### 5.2 XSS防护
```javascript
// React组件中的XSS防护
import DOMPurify from 'dompurify';

// 安全渲染HTML内容
function SafeHtmlRenderer({ htmlContent }) {
  const sanitizedHtml = DOMPurify.sanitize(htmlContent, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li'],
    ALLOWED_ATTR: ['class']
  });
  
  return (
    <div dangerouslySetInnerHTML={{ __html: sanitizedHtml }} />
  );
}

// 输入框XSS防护
function SecureInput({ value, onChange }) {
  const handleChange = (e) => {
    const sanitizedValue = DOMPurify.sanitize(e.target.value);
    onChange(sanitizedValue);
  };
  
  return (
    <input
      type="text"
      value={value}
      onChange={handleChange}
      maxLength={255}
    />
  );
}
```

### 5.3 CSRF防护
```javascript
const csrf = require('csurf');

// CSRF中间件配置
const csrfProtection = csrf({
  cookie: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict'
  }
});

// 前端CSRF Token处理
class CSRFManager {
  static getToken() {
    return document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
  }
  
  static addTokenToRequest(config) {
    const token = this.getToken();
    if (token) {
      config.headers['X-CSRF-Token'] = token;
    }
    return config;
  }
}

// Axios拦截器
axios.interceptors.request.use(CSRFManager.addTokenToRequest);
```

## 6. 会话安全管理

### 6.1 Session配置
```javascript
const session = require('express-session');
const RedisStore = require('connect-redis')(session);

const SESSION_CONFIG = {
  store: new RedisStore({ client: redisClient }),
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === 'production', // HTTPS only in production
    httpOnly: true, // 防止XSS
    maxAge: 30 * 60 * 1000, // 30分钟
    sameSite: 'strict' // CSRF防护
  },
  name: 'l2c.sid' // 自定义session名称
};
```

### 6.2 会话超时管理
```javascript
// 会话超时中间件
function sessionTimeout(req, res, next) {
  if (req.session) {
    const now = Date.now();
    const lastActivity = req.session.lastActivity || now;
    const timeout = 30 * 60 * 1000; // 30分钟
    
    if (now - lastActivity > timeout) {
      req.session.destroy((err) => {
        if (err) {
          console.error('Session destroy error:', err);
        }
        res.status(401).json({ error: '会话已超时，请重新登录' });
      });
      return;
    }
    
    req.session.lastActivity = now;
  }
  next();
}
```

## 7. 文件上传安全

### 7.1 文件类型验证
```javascript
const multer = require('multer');
const path = require('path');

// 允许的文件类型
const ALLOWED_FILE_TYPES = {
  images: ['.jpg', '.jpeg', '.png', '.gif', '.webp'],
  documents: ['.pdf', '.doc', '.docx', '.xls', '.xlsx'],
  archives: ['.zip', '.rar']
};

// 文件上传配置
const upload = multer({
  storage: multer.diskStorage({
    destination: (req, file, cb) => {
      cb(null, 'uploads/');
    },
    filename: (req, file, cb) => {
      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
      cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
    }
  }),
  fileFilter: (req, file, cb) => {
    const ext = path.extname(file.originalname).toLowerCase();
    const allowedExts = Object.values(ALLOWED_FILE_TYPES).flat();
    
    if (allowedExts.includes(ext)) {
      cb(null, true);
    } else {
      cb(new Error('不支持的文件类型'), false);
    }
  },
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB
    files: 5 // 最多5个文件
  }
});
```

### 7.2 文件内容验证
```javascript
const fileType = require('file-type');

// 文件内容验证
async function validateFileContent(filePath) {
  try {
    const type = await fileType.fromFile(filePath);
    
    if (!type) {
      throw new Error('无法识别文件类型');
    }
    
    const allowedMimeTypes = [
      'image/jpeg', 'image/png', 'image/gif', 'image/webp',
      'application/pdf', 'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    ];
    
    if (!allowedMimeTypes.includes(type.mime)) {
      throw new Error('不允许的文件类型');
    }
    
    return true;
  } catch (error) {
    throw new Error(`文件验证失败: ${error.message}`);
  }
}
```

## 8. 安全监控与审计

### 8.1 安全事件记录
```javascript
// 安全事件类型
const SECURITY_EVENTS = {
  LOGIN_SUCCESS: 'login_success',
  LOGIN_FAILURE: 'login_failure',
  PASSWORD_CHANGE: 'password_change',
  PERMISSION_DENIED: 'permission_denied',
  SUSPICIOUS_ACTIVITY: 'suspicious_activity',
  DATA_ACCESS: 'data_access',
  DATA_MODIFICATION: 'data_modification'
};

// 安全审计日志
class SecurityAudit {
  static async logEvent(eventType, userId, details = {}) {
    const auditLog = {
      eventType,
      userId,
      timestamp: new Date(),
      ip: details.ip,
      userAgent: details.userAgent,
      resource: details.resource,
      action: details.action,
      result: details.result,
      riskLevel: this.calculateRiskLevel(eventType, details)
    };
    
    await db.auditLogs.create(auditLog);
    
    // 高风险事件立即告警
    if (auditLog.riskLevel === 'HIGH') {
      await this.sendSecurityAlert(auditLog);
    }
  }
  
  static calculateRiskLevel(eventType, details) {
    // 风险评估逻辑
    if (eventType === SECURITY_EVENTS.LOGIN_FAILURE && details.attemptCount > 3) {
      return 'HIGH';
    }
    if (eventType === SECURITY_EVENTS.PERMISSION_DENIED) {
      return 'MEDIUM';
    }
    return 'LOW';
  }
}
```

### 8.2 异常行为检测
```javascript
// 异常行为检测
class AnomalyDetection {
  static async detectSuspiciousLogin(userId, loginData) {
    const recentLogins = await db.auditLogs.findAll({
      where: {
        userId,
        eventType: SECURITY_EVENTS.LOGIN_SUCCESS,
        timestamp: {
          [Op.gte]: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // 7天内
        }
      }
    });
    
    // 检测异常登录位置
    const locations = recentLogins.map(log => log.ip);
    if (!locations.includes(loginData.ip) && locations.length > 0) {
      await SecurityAudit.logEvent(
        SECURITY_EVENTS.SUSPICIOUS_ACTIVITY,
        userId,
        { ...loginData, reason: 'unusual_location' }
      );
    }
    
    // 检测异常登录时间
    const hour = new Date().getHours();
    if (hour < 6 || hour > 22) {
      await SecurityAudit.logEvent(
        SECURITY_EVENTS.SUSPICIOUS_ACTIVITY,
        userId,
        { ...loginData, reason: 'unusual_time' }
      );
    }
  }
}
```

## 9. 安全配置检查清单

### 9.1 服务器安全配置
- [ ] 禁用不必要的HTTP方法（TRACE, OPTIONS等）
- [ ] 设置安全响应头（HSTS, X-Frame-Options等）
- [ ] 配置HTTPS和TLS 1.2+
- [ ] 隐藏服务器版本信息
- [ ] 配置防火墙规则
- [ ] 定期更新系统和依赖包

### 9.2 应用安全配置
- [ ] 环境变量中的敏感信息加密存储
- [ ] 数据库连接使用SSL
- [ ] API接口实现认证和授权
- [ ] 输入验证和输出编码
- [ ] 错误信息不泄露敏感信息
- [ ] 日志记录不包含敏感数据

### 9.3 前端安全配置
- [ ] 实施内容安全策略（CSP）
- [ ] 防止XSS攻击
- [ ] 实施CSRF防护
- [ ] 敏感数据不存储在localStorage
- [ ] 使用HTTPS传输
- [ ] 定期更新前端依赖

## 10. 安全最佳实践

### 10.1 开发阶段
1. **安全编码培训**：定期进行安全编码培训
2. **代码审查**：所有代码必须经过安全审查
3. **静态代码分析**：使用工具进行安全漏洞扫描
4. **依赖管理**：定期检查和更新第三方依赖
5. **安全测试**：集成安全测试到CI/CD流程

### 10.2 部署阶段
1. **环境隔离**：开发、测试、生产环境严格隔离
2. **最小权限**：应用运行使用最小必要权限
3. **网络分段**：实施网络分段和访问控制
4. **监控告警**：部署安全监控和告警系统
5. **备份恢复**：建立完善的备份和恢复机制

### 10.3 运维阶段
1. **定期巡检**：定期进行安全巡检和漏洞扫描
2. **应急响应**：建立安全事件应急响应流程
3. **安全培训**：定期进行安全意识培训
4. **合规审计**：定期进行安全合规审计
5. **持续改进**：根据安全事件和威胁情报持续改进

## 11. 应急响应流程

### 11.1 安全事件分级
- **P0 - 紧急**：系统被攻击，数据泄露
- **P1 - 高危**：发现严重安全漏洞
- **P2 - 中危**：发现一般安全问题
- **P3 - 低危**：安全配置问题

### 11.2 响应流程
1. **事件发现**：监控系统或人工发现安全事件
2. **事件确认**：确认事件真实性和影响范围
3. **应急处置**：立即采取措施阻止攻击或修复漏洞
4. **影响评估**：评估事件对业务和数据的影响
5. **恢复服务**：恢复正常业务服务
6. **事后分析**：分析事件原因，制定改进措施

---

**注意事项：**
1. 本规范应定期更新，跟上最新的安全威胁和防护技术
2. 所有开发人员必须熟悉并遵守本安全规范
3. 安全配置和代码实现应定期进行安全审计
4. 发现安全问题应立即报告并及时修复
5. 敏感信息处理必须严格按照数据分类标准执行
\n+## 附录：安全功能实现报告（整合）
\n+# 安全功能实现报告（整合）
\n+### 已实现安全能力概览
- 安全中间件：输入验证、XSS/SQL注入防护、限流、CSRF、安全头、IP白/黑名单
- 权限控制：JWT 验证、RBAC、细粒度权限、资源所有权
- 安全监控：威胁检测、异常拦截、自动响应与黑名单
- 加密工具：AES-256-GCM、密码哈希、签名、令牌、脱敏与完整性校验
- 审计日志：操作记录、安全事件追踪、结构化日志与分级
- 集中安全配置：环境变量、动态更新、配置校验
\n+### 关键实现位置
- `backend/src/middleware/security.ts`
- `backend/src/middleware/authorization.ts`
- `backend/src/middleware/securityMonitoring.ts`
- `backend/src/utils/encryption.ts`
- `backend/src/utils/auditLogger.ts`
- `backend/src/config/security.ts`
\n+### 路由保护与测试覆盖
- 用户、线索、订单路由的认证授权与权限校验；单元测试覆盖权限、角色、配置、加密、审计与监控等。
\n+### 部署与配置建议
- JWT/加密/数据库/限流/CORS 等生产安全变量；上线前安全检查清单与合规项。
\n+### 总结
- 完整的多层防护体系与落地实现，具备企业级安全能力与审计追踪。
