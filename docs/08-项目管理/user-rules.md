# Trae 6A规则工作流规范

本文档定义了基于6A规则的标准化AI辅助开发工作流，结合VibeCoding敏捷5S原则和强制命名规范标准。该流程旨在通过明确的阶段划分和质量门控，将模糊需求转化为高质量的可交付成果，提高开发效率与代码命中率。

## 🚨 强制命名规范警告

**所有代码必须严格遵守以下命名规范，违反者将被拒绝合并！**

### 强制命名规则
- **变量命名**：必须使用 `camelCase` 格式
- **常量命名**：必须使用 `SCREAMING_SNAKE_CASE` 格式  
- **函数命名**：必须使用 `camelCase` 格式，并清晰表达功能
- **类命名**：必须使用 `PascalCase` 格式
- **数据库表名和字段名**：必须使用 `snake_case` 格式
- **API路径**：必须使用 `kebab-case` 格式
- **文件命名**：组件文件使用 `PascalCase`，其他文件使用 `kebab-case`
- **CSS类名**：必须遵循 `BEM` 规范

### 禁止使用的命名
```javascript
// ❌ 禁止使用的命名（将被拒绝合并）
const data = {};           // 过于泛化
const info = {};           // 含义不明确  
const temp = {};           // 临时变量应有具体含义
const obj = {};            // 对象类型不明确
const arr = [];            // 数组内容不明确
const str = '';            // 字符串用途不明确
const num = 0;             // 数字含义不明确
const flag = true;         // 标志位用途不明确
```

### 完整命名规范参考
详细命名规范请参考：`/Users/laichangcheng/Documents/文稿 - 来长城的MacBook Air/trae/L2C/需求/03-开发实施/09-命名规范标准.md`

---

## 阶段一: Align (对齐) - 需求精确化
**目标：** 将模糊、不完整的需求转化为清晰、无歧义、可执行的规范文档，并确保命名规范在项目初期就得到明确。

**AI执行指令：**
1.  **分析上下文：** 分析所有输入信息（如用户需求、业务目标、技术约束等）。
2.  **识别与澄清：** 主动识别需求中的模糊点、歧义和缺失信息，并通过提问与用户确认。
3.  **强制命名规范检查：** 在需求分析阶段就明确所有实体的命名规范，确保后续开发一致性。
4.  **生成规范文档：** 生成一份包含以下要素的共识文档：
    *   **功能范围：** 明确包含与不包含的功能。
    *   **技术方案：** 推荐或确认的技术栈与实现思路。
    *   **命名规范清单：** 所有业务实体的标准命名（英文）。
    *   **验收标准 (Acceptance Criteria)：** 具体、可测试的验收条件（Given-When-Then格式为佳）。

**✅ 质量门控 (必须满足才能进入下一阶段)：**
*   [ ] 需求边界已清晰定义。
*   [ ] 技术方案与整体架构方向一致。
*   [ ] 所有业务实体命名已标准化（符合命名规范）。
*   [ ] 验收标准具体、可验证。

**输入：** 模糊需求、想法、业务目标。
**输出：** 经确认的《需求规范文档》（含命名规范清单）。

---

## 阶段二: Architect (架构) - 系统设计
**目标：** 基于共识的《需求规范文档》，设计系统高层架构与模块接口。

**AI执行指令：**
1.  **设计系统结构：** 提出系统分层、模块划分、服务拆解（如适用）方案。
2.  **定义接口：** 明确模块/服务之间的接口契约（API定义、数据格式、通信协议）。
3.  **生成架构文档：** 输出架构图及相关说明文档，确保与现有系统兼容。

**✅ 质量门控 (必须满足才能进入下一阶段)：**
*   [ ] 架构图清晰、准确，关键组件已标明。
*   [ ] 主要模块接口定义完整（输入、输出、行为）。
*   [ ] 已考虑非功能性需求（性能、安全、扩展性）。

**输入：** 《需求规范文档》。
**输出：** 《系统架构设计文档》（含架构图与接口定义）。

---

## 阶段三: Atomize (原子化) - 任务拆解
**目标：** 将架构设计拆解为细小、具体、可执行的开发任务。

**AI执行指令：**
1.  **分解工作：** 将《系统架构设计文档》分解为一个个原子任务（Atomic Tasks）。
2.  **生成任务清单：** 为每个任务生成清晰的描述，包括：
    *   **任务标题：** 简洁的任务名。
    *   **任务描述：** 具体要实现的功能或要编写的代码。
    *   **依赖关系：** 该任务的前置任务。
    *   **预估复杂度（可选）。**

**输入：** 《系统架构设计文档》。
**输出：** 《原子化任务清单》（To-Do List）。

---

## 阶段四: Approve (审批) - 人工确认
**目标：** 对原子化任务清单进行人工审查，确保合理性后方可执行。

**执行步骤 (由人类执行)：**
1.  **团队成员/项目经理审核**《原子化任务清单》。
2.  **确认事项：**
    *   任务拆解是否合理，有无遗漏或过度拆解？
    *   任务优先级和依赖关系是否正确？
    *   每个任务是否都具备可执行性？
3.  **做出决策：** [批准执行] 或 [退回修改]。

**✅ 质量门控：**
*   [ ] 所有任务已获明确批准。
*   [ ] 如被退回，需明确修改意见并返回至 **Atomize** 或 **Architect** 阶段调整。

**输入：** 《原子化任务清单》。
**输出：** **已批准的**《原子化任务清单》。

---

## 阶段五: Automate (自动化) - AI执行与测试
**目标：** AI根据批准的任务清单，自动进行编码并完成基础测试，严格遵守命名规范。

**AI执行指令：**
1.  **强制命名规范检查：** 在编码前必须检查并应用正确的命名规范。
2.  **按任务生成代码：** 根据任务清单的顺序和描述，逐个生成高质量、可读的代码。
3.  **命名规范验证：** 每段代码生成后立即检查命名规范符合性。
4.  **执行单元测试：** 为生成的代码自动编写并运行单元测试，确保逻辑正确。
5.  **执行集成测试（如适用）：** 检查模块间的集成是否正常。
6.  **报告问题：** 如测试失败，尝试修复或立即报告。

**命名规范检查清单：**
*   [ ] 变量名使用 `camelCase`
*   [ ] 常量名使用 `SCREAMING_SNAKE_CASE`
*   [ ] 函数名使用 `camelCase` 且语义清晰
*   [ ] 类名使用 `PascalCase`
*   [ ] 数据库表名和字段名使用 `snake_case`
*   [ ] API路径使用 `kebab-case`
*   [ ] 组件文件名使用 `PascalCase`
*   [ ] CSS类名遵循 `BEM` 规范
*   [ ] 无禁用词汇（data, info, temp等）

**输入：** **已批准的**《原子化任务清单》。
**输出：** **可运行的代码**、**单元测试代码**、**测试通过报告**、**命名规范检查报告**。

---

## 阶段六: Assess (评估) - 质量验收与复盘
**目标：** 对最终交付成果进行质量验收，重点检查命名规范符合性，并总结复盘以优化未来流程。

**执行步骤：**
1.  **命名规范最终检查：** 全面检查所有交付代码的命名规范符合性。
2.  **验收测试：** 根据 **Align** 阶段定义的《需求规范文档》和**验收标准**，对交付成果进行全面验证。
3.  **代码审查 (Code Review)：** 检查代码风格、性能、安全性等，重点审查命名规范。
4.  **生成报告：** 输出《交付评估报告》，明确是否通过验收，包含命名规范检查结果。
5.  **复盘总结：** 记录本次开发过程中的经验教训，特别是命名规范执行情况，优化未来的6A流程执行。

**✅ 质量门控 (最终出口标准)：**
*   [ ] 命名规范检查100%通过（无违规命名）。
*   [ ] 所有验收标准均已满足。
*   [ ] 代码通过审查，符合质量要求。
*   [ ] 《交付评估报告》已生成。

**输入：** 最终交付的代码、文档、《需求规范文档》。
**输出：** 《交付评估报告》（含验收结果、命名规范检查结果与复盘总结）。

---

## 📋 VibeCoding敏捷5S原则集成

本工作流规范融合了VibeCoding敏捷5S原则，确保代码质量和开发效率：

### 1. 整理（Seiri）- 代码精简
- ✅ 每日提交前运行代码检测工具
- ✅ 删除无用代码和注释掉的代码块  
- ✅ 移除重复逻辑和冗余依赖
- ✅ 每个函数/类保持单一职责原则

### 2. 整顿（Seiton）- 结构有序
- ✅ 严格按照命名规范组织代码结构
- ✅ 统一的目录和文件命名标准
- ✅ 清晰的模块划分和接口定义

### 3. 清扫（Seiso）- 环境清洁
- ✅ 编码前清理控制台日志与调试代码
- ✅ 提交前运行lint检查和单元测试
- ✅ 及时处理编译警告和类型错误

### 4. 清洁（Seiketsu）- 标准统一
- ✅ 严格执行命名规范和代码标准
- ✅ 统一的错误处理和日志规范
- ✅ 一致的API设计和响应格式

### 5. 素养（Shitsuke）- 持续改进
- ✅ 每周代码回顾和命名规范检查
- ✅ 技术债看板管理和定期清理
- ✅ 知识库维护和最佳实践更新

---

## 🎯 成功指标

| 指标 | 目标值 | 测量方法 |
|-----|--------|----------|
| 命名规范符合率 | 100% | 代码审查 + 自动化检测 |
| 代码重复率 | <3% | SonarQube分析 |
| 技术债比例 | <5% | 代码质量工具 |
| 构建时间 | <3分钟 | CI/CD流水线 |

**维护者**：L2C开发团队  
**版本**：v2.1（集成命名规范版）  
**更新日期**：2024年更新
