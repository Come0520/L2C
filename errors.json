[{"filePath":"C:\\Users\\bigey\\Documents\\Antigravity\\L2C\\src\\features\\orders\\__tests__\\halt-order.test.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-asserted-optional-chain","severity":2,"message":"Optional chain expressions can return undefined by design - using a non-null assertion is unsafe and wrong.","line":40,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNullOptionalChain","endLine":40,"endColumn":27,"suggestions":[{"messageId":"suggestRemovingNonNull","fix":{"range":[1202,1203],"text":""},"desc":"You should remove the non-null assertion."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport 'dotenv/config';\r\nimport { describe, it, expect, vi, beforeAll } from 'vitest';\r\nimport { db } from '@/shared/api/db';\r\nimport { haltOrderAction, resumeOrderAction, getHaltedOrders } from '../actions/halt';\r\nimport { orders } from '@/shared/api/schema/orders';\r\nimport { quotes } from '@/shared/api/schema/quotes';\r\nimport { customers } from '@/shared/api/schema/customers';\r\nimport { eq } from 'drizzle-orm';\r\n\r\n// Mock next/cache\r\nvi.mock('next/cache', () => ({\r\n    revalidatePath: vi.fn(),\r\n}));\r\n\r\nvi.mock('@/shared/lib/auth', () => ({\r\n    auth: vi.fn(async () => {\r\n        const tenant = await db.query.tenants.findFirst();\r\n        return {\r\n            user: {\r\n                id: 'mock-user-id',\r\n                tenantId: tenant?.id\r\n            }\r\n        };\r\n    }),\r\n}));\r\n\r\ndescribe('Order Halt Logic', () => {\r\n    let tenantId: string;\r\n    let userId: string;\r\n    let customerId: string;\r\n    let quoteId: string;\r\n\r\n    beforeAll(async () => {\r\n        const tenant = await db.query.tenants.findFirst();\r\n        if (!tenant) throw new Error(\"No Tenant\");\r\n        tenantId = tenant.id;\r\n\r\n        const user = await db.query.users.findFirst();\r\n        userId = user?.id!;\r\n\r\n        const customer = await db.query.customers.findFirst();\r\n        if (!customer) throw new Error(\"No Customer\");\r\n        customerId = customer.id;\r\n\r\n        // Create Quote\r\n        const [quote] = await db.insert(quotes).values({\r\n            tenantId,\r\n            quoteNo: `QT-HALT-${Date.now()}`,\r\n            customerId,\r\n            version: 1,\r\n            totalAmount: '1000',\r\n            createdBy: userId,\r\n            status: 'ACCEPTED'\r\n        }).returning();\r\n        quoteId = quote.id;\r\n    });\r\n\r\n    it('should halt and resume order correctly', async () => {\r\n        // 1. Create Order (SIGNED)\r\n        const [order] = await db.insert(orders).values({\r\n            tenantId,\r\n            orderNo: `ORD-HALT-${Date.now()}`,\r\n            quoteId,\r\n            quoteVersionId: quoteId,\r\n            customerId,\r\n            salesId: userId,\r\n            status: 'SIGNED',\r\n            settlementType: 'PREPAID',\r\n            createdBy: userId\r\n        }).returning();\r\n\r\n        // 2. Halt Order\r\n        const haltResult = await haltOrderAction({\r\n            orderId: order.id,\r\n            reason: 'CUSTOMER_REQUEST',\r\n            remark: 'Test Halt'\r\n        });\r\n\r\n        expect(haltResult.success).toBe(true);\r\n        const haltedOrder = await db.query.orders.findFirst({\r\n            where: eq(orders.id, order.id)\r\n        });\r\n        expect(haltedOrder?.status).toBe('HALTED');\r\n\r\n        // 3. Verify in Halted List\r\n        const listResult = await getHaltedOrders();\r\n        expect(listResult.success).toBe(true);\r\n        const inList = listResult.data.find(o => o.id === order.id);\r\n        expect(inList).toBeDefined();\r\n        expect(inList?.alertLevel).toBe('NONE'); // Just halted\r\n\r\n        // 4. Resume Order\r\n        const resumeResult = await resumeOrderAction({\r\n            orderId: order.id,\r\n            remark: 'Resuming'\r\n        });\r\n        expect(resumeResult.success).toBe(true);\r\n\r\n        const resumedOrder = await db.query.orders.findFirst({\r\n            where: eq(orders.id, order.id)\r\n        });\r\n        expect(resumedOrder?.status).toBe('SIGNED');\r\n    });\r\n\r\n    it('should trigger warning if halted for long time', async () => {\r\n        // 1. Create Order (HALTED manually to simulate time)\r\n        const eightDaysAgo = new Date();\r\n        eightDaysAgo.setDate(eightDaysAgo.getDate() - 8);\r\n\r\n        const [order] = await db.insert(orders).values({\r\n            tenantId,\r\n            orderNo: `ORD-WARN-${Date.now()}`,\r\n            quoteId,\r\n            quoteVersionId: quoteId,\r\n            customerId,\r\n            salesId: userId,\r\n            status: 'HALTED', // Manual\r\n            pausedAt: eightDaysAgo,\r\n            settlementType: 'PREPAID',\r\n            createdBy: userId\r\n        }).returning();\r\n\r\n        // 2. Check List\r\n        const listResult = await getHaltedOrders();\r\n        const inList = listResult.data.find(o => o.id === order.id);\r\n\r\n        expect(inList).toBeDefined();\r\n        expect(inList?.alertLevel).toBe('WARNING');\r\n        expect(inList?.daysHalted).toBeGreaterThanOrEqual(8);\r\n    });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\bigey\\Documents\\Antigravity\\L2C\\src\\features\\service\\installation\\actions\\create-task.test.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-asserted-optional-chain","severity":2,"message":"Optional chain expressions can return undefined by design - using a non-null assertion is unsafe and wrong.","line":42,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNullOptionalChain","endLine":42,"endColumn":27,"suggestions":[{"messageId":"suggestRemovingNonNull","fix":{"range":[1684,1685],"text":""},"desc":"You should remove the non-null assertion."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport 'dotenv/config';\r\nimport { describe, it, expect, vi, beforeAll } from 'vitest';\r\nimport { db } from '@/shared/api/db';\r\nimport { generateInstallTasksFromOrder } from './create-task';\r\nimport { checkInMeasureTask } from '../../measurement/actions/check-in'; // Import\r\nimport { rejectMeasureTask } from '../../measurement/actions/reject'; // Import\r\nimport { orders, orderItems } from '@/shared/api/schema/orders';\r\nimport { quotes, quoteItems } from '@/shared/api/schema/quotes';\r\nimport { customers } from '@/shared/api/schema/customers';\r\nimport { installTasks, installItems, measureTasks, measureSheets } from '@/shared/api/schema/service';\r\nimport { leads } from '@/shared/api/schema/leads';\r\nimport { tenants, users } from '@/shared/api/schema/infrastructure';\r\nimport { eq } from 'drizzle-orm';\r\nimport { uuid } from 'drizzle-orm/pg-core';\r\nimport { createMeasureTask } from '../../measurement/actions/create-task';\r\n\r\n// Mock next/cache\r\nvi.mock('next/cache', () => ({\r\n    revalidatePath: vi.fn(),\r\n}));\r\n\r\nvi.mock('@/shared/lib/auth', () => ({\r\n    auth: vi.fn(async () => ({ user: { id: 'mock-user-id' } })),\r\n}));\r\n\r\n// Mock createSafeAction if needed? \r\n// No, createSafeAction just validates schema. It should run fine in node if zod is presents.\r\n\r\ndescribe('Installation Tasks Logic', () => {\r\n    let tenantId: string;\r\n    let userId: string;\r\n    let customerId: string;\r\n    let productId: string;\r\n\r\n    beforeAll(async () => {\r\n        const tenant = await db.query.tenants.findFirst();\r\n        if (!tenant) throw new Error(\"No Tenant\");\r\n        tenantId = tenant.id;\r\n\r\n        const user = await db.query.users.findFirst();\r\n        userId = user?.id!;\r\n\r\n        const customer = await db.query.customers.findFirst();\r\n        if (!customer) throw new Error(\"No Customer\");\r\n        customerId = customer.id;\r\n\r\n        const product = await db.query.products.findFirst();\r\n        if (!product) throw new Error(\"No Product\");\r\n        productId = product.id;\r\n    });\r\n\r\n    it('should split order into install tasks correctly', async () => {\r\n        // 1. Create Quote\r\n        const [quote] = await db.insert(quotes).values({\r\n            tenantId,\r\n            quoteNo: `TEST-QT-${Date.now()}`,\r\n            customerId,\r\n            version: 1,\r\n            totalAmount: '360',\r\n            createdBy: userId,\r\n            status: 'ACCEPTED'\r\n        }).returning();\r\n\r\n        // 2. Create Quote Items\r\n        const [qItemCurtain] = await db.insert(quoteItems).values({\r\n            tenantId,\r\n            quoteId: quote.id,\r\n            category: 'CURTAIN',\r\n            productName: 'Test Curtain',\r\n            quantity: '1',\r\n            unitPrice: '100',\r\n            subtotal: '100',\r\n        }).returning();\r\n\r\n        const [qItemWallpaper] = await db.insert(quoteItems).values({\r\n            tenantId,\r\n            quoteId: quote.id,\r\n            category: 'WALLPAPER',\r\n            productName: 'Test Wallpaper',\r\n            quantity: '5',\r\n            unitPrice: '50',\r\n            subtotal: '250',\r\n        }).returning();\r\n\r\n        const [qItemOther] = await db.insert(quoteItems).values({\r\n            tenantId,\r\n            quoteId: quote.id,\r\n            category: 'OTHER',\r\n            productName: 'Test Other',\r\n            quantity: '1',\r\n            unitPrice: '10',\r\n            subtotal: '10',\r\n        }).returning();\r\n\r\n        // 3. Create Order\r\n        const [order] = await db.insert(orders).values({\r\n            tenantId,\r\n            orderNo: `TEST-ORD-${Date.now()}`,\r\n            quoteId: quote.id,\r\n            quoteVersionId: quote.id,\r\n            customerId,\r\n            salesId: userId,\r\n            status: 'PENDING_INSTALL',\r\n            settlementType: 'PREPAID',\r\n            createdBy: userId\r\n        }).returning();\r\n\r\n        // 4. Create Order Items\r\n        await db.insert(orderItems).values([\r\n            {\r\n                tenantId,\r\n                orderId: order.id,\r\n                quoteItemId: qItemCurtain.id,\r\n                productId,\r\n                productName: 'Test Curtain',\r\n                roomName: 'Living Room',\r\n                category: 'CURTAIN',\r\n                quantity: 1,\r\n                unitPrice: '100',\r\n                subtotal: '100',\r\n                width: 100,\r\n                height: 200,\r\n            },\r\n            {\r\n                tenantId,\r\n                orderId: order.id,\r\n                quoteItemId: qItemWallpaper.id,\r\n                productId,\r\n                productName: 'Test Wallpaper',\r\n                roomName: 'Bedroom',\r\n                category: 'WALLPAPER',\r\n                quantity: 5,\r\n                unitPrice: '50',\r\n                subtotal: '250',\r\n                width: 0,\r\n                height: 0,\r\n            },\r\n            {\r\n                tenantId,\r\n                orderId: order.id,\r\n                quoteItemId: qItemOther.id,\r\n                productId,\r\n                productName: 'Test Other',\r\n                roomName: 'Other',\r\n                category: 'OTHER',\r\n                quantity: 1,\r\n                unitPrice: '10',\r\n                subtotal: '10',\r\n                width: 0,\r\n                height: 0,\r\n            }\r\n        ]);\r\n\r\n        // 5. Execute Action\r\n        const result = await generateInstallTasksFromOrder({\r\n            orderId: order.id,\r\n            tenantId,\r\n            userId,\r\n        });\r\n\r\n        // Result is double wrapped: { success: true, data: { success: true, data: { ... } } }\r\n        // or if handler failed logic: { success: true, data: { success: false, error: ... } }\r\n\r\n        expect(result.success).toBe(true); // Wrapper success\r\n\r\n        const logicResult = result.data as any;\r\n        if (!logicResult?.success) {\r\n            console.error('Logic Failed:', logicResult?.error);\r\n        }\r\n        expect(logicResult.success).toBe(true); // Business logic success\r\n        expect(logicResult.data?.createdTaskIds).toBeDefined();\r\n\r\n        // 6. Verify Tasks\r\n        const tasks = await db.query.installTasks.findMany({\r\n            where: eq(installTasks.orderId, order.id),\r\n        });\r\n\r\n        // Expect 3 tasks: Curtain, Wallpaper, Other\r\n        expect(tasks.length).toBe(3);\r\n\r\n        const categories = tasks.map(t => t.category);\r\n        expect(categories).toContain('CURTAIN');\r\n        expect(categories).toContain('WALLPAPER');\r\n        expect(categories).toContain('OTHER');\r\n\r\n        // Verify Items in one task\r\n        const wallpaperTask = tasks.find(t => t.category === 'WALLPAPER');\r\n        const items = await db.query.installItems.findMany({\r\n            where: eq(installItems.installTaskId, wallpaperTask!.id)\r\n        });\r\n        expect(items.length).toBe(1);\r\n        expect(items[0].productName).toBe('Test Wallpaper');\r\n    });\r\n    it('should create measure task correctly', async () => {\r\n        // Reuse variables from describe scope\r\n        const testTenantId = tenantId;\r\n        const testUserId = userId;\r\n        const testCustomerId = customerId;\r\n\r\n        // 1. Create a Lead\r\n        // Ensure leads schema has all fields\r\n        const [lead] = await db.insert(leads).values({\r\n            tenantId: testTenantId,\r\n            leadNo: `L-${Date.now()}`, // LeadNo is unique not null\r\n            customerName: 'Test Customer',\r\n            customerPhone: '19999999999',\r\n            status: 'PENDING_ASSIGNMENT',\r\n            createdBy: testUserId,\r\n            // title: 'Test Lead Measure', // title does not exist in leads schema\r\n            // source: 'WALK_IN', // source might be sourceChannelId or something. \r\n            // leads schema: sourceChannelId etc. sourceDetail.\r\n        }).returning();\r\n\r\n        // 2. Execute Action\r\n        const result = await createMeasureTask({\r\n            tenantId: testTenantId,\r\n            leadId: lead.id,\r\n            customerId: testCustomerId, // existing customer\r\n            type: 'BLIND',\r\n            remark: 'Test Remark'\r\n        });\r\n\r\n        if (!result.success) {\r\n            console.error('Measure Action Wrapper Error:', result.error);\r\n        }\r\n        expect(result.success).toBe(true);\r\n\r\n        const logicResult = result.data as any; // safe action wrapper unwrapping\r\n\r\n        if (!logicResult?.success) {\r\n            console.error('Measure Action Logic Error:', logicResult?.error);\r\n        }\r\n        expect(logicResult.success).toBe(true);\r\n        expect(logicResult.data.taskId).toBeDefined();\r\n\r\n        // 3. Verify Task in DB\r\n        const task = await db.query.measureTasks.findFirst({\r\n            where: eq(measureTasks.id, logicResult.data.taskId)\r\n        });\r\n        expect(task).toBeDefined();\r\n        expect(task?.measureNo).toContain('MEA-');\r\n        expect(task?.status).toBe('PENDING');\r\n\r\n        // 4. Verify Sheet\r\n        const sheet = await db.query.measureSheets.findFirst({\r\n            where: eq(measureSheets.taskId, task!.id)\r\n        });\r\n        expect(sheet).toBeDefined();\r\n        expect(sheet?.status).toBe('DRAFT');\r\n    });\r\n    it('should set fee status to PENDING when requiresFee is true', async () => {\r\n        const testTenantId = tenantId;\r\n        const testUserId = userId;\r\n\r\n        // 1. Create Non-VIP Customer explicitly\r\n        const [nonVipCustomer] = await db.insert(customers).values({\r\n            tenantId: testTenantId,\r\n            name: 'Non VIP',\r\n            phone: `188${Date.now()}`,\r\n            createdBy: testUserId,\r\n            customerNo: `C-NV-${Date.now()}`,\r\n            level: 'D'\r\n        }).returning();\r\n\r\n        // 2. Create a Lead\r\n        const [lead] = await db.insert(leads).values({\r\n            tenantId: testTenantId,\r\n            leadNo: `L-FEE-${Date.now()}`,\r\n            customerName: 'Test Fee Customer',\r\n            customerPhone: nonVipCustomer.phone,\r\n            status: 'PENDING_ASSIGNMENT',\r\n            createdBy: testUserId,\r\n        }).returning();\r\n\r\n        // 3. Execute Action with requiresFee=true\r\n        const result = await createMeasureTask({\r\n            tenantId: testTenantId,\r\n            leadId: lead.id,\r\n            customerId: nonVipCustomer.id,\r\n            type: 'BLIND',\r\n            requiresFee: true\r\n        });\r\n\r\n        if (!result.success) console.error('Fee Test Error:', result.error);\r\n        expect(result.success).toBe(true);\r\n        const logicResult = result.data as any;\r\n        expect(logicResult.success).toBe(true);\r\n\r\n        // 4. Verify Task Logic\r\n        const task = await db.query.measureTasks.findFirst({\r\n            where: eq(measureTasks.id, logicResult.data.taskId)\r\n        });\r\n        expect(task?.isFeeExempt).toBe(false);\r\n        expect(task?.feeCheckStatus).toBe('PENDING');\r\n    });\r\n\r\n    it('should set fee status to NONE for VIP customer', async () => {\r\n        const testTenantId = tenantId;\r\n        const testUserId = userId;\r\n\r\n        // Create VIP Customer\r\n        const [vipCustomer] = await db.insert(customers).values({\r\n            tenantId: testTenantId,\r\n            name: 'VIP Customer',\r\n            phone: `177${Date.now()}`,\r\n            createdBy: testUserId,\r\n            customerNo: `C-VIP-${Date.now()}`,\r\n            level: 'A' // VIP\r\n        }).returning();\r\n\r\n        // Create Lead\r\n        const [lead] = await db.insert(leads).values({\r\n            tenantId: testTenantId,\r\n            leadNo: `L-VIP-${Date.now()}`,\r\n            customerName: 'VIP Customer',\r\n            customerPhone: vipCustomer.phone,\r\n            status: 'PENDING_ASSIGNMENT',\r\n            createdBy: testUserId,\r\n        }).returning();\r\n\r\n        // Execute Action with requiresFee=true (should be overridden by VIP)\r\n        const result = await createMeasureTask({\r\n            tenantId: testTenantId,\r\n            leadId: lead.id,\r\n            customerId: vipCustomer.id,\r\n            type: 'BLIND',\r\n            requiresFee: true\r\n        });\r\n\r\n        expect(result.success).toBe(true);\r\n        const logicResult = result.data as any;\r\n\r\n        const task = await db.query.measureTasks.findFirst({\r\n            where: eq(measureTasks.id, logicResult.data.taskId)\r\n        });\r\n\r\n        expect(task?.isFeeExempt).toBe(true);\r\n        expect(task?.feeCheckStatus).toBe('NONE');\r\n    });\r\n\r\n    it('should check in measure task successfully with GPS validation', async () => {\r\n        const testTenantId = tenantId;\r\n        const testUserId = userId;\r\n        const testCustomerId = customerId;\r\n\r\n        // 1. Create Lead & Task\r\n        const [lead] = await db.insert(leads).values({\r\n            tenantId: testTenantId,\r\n            leadNo: `L-GPS-${Date.now()}`,\r\n            customerName: 'GPS Customer',\r\n            customerPhone: `144${Date.now()}`,\r\n            status: 'PENDING_ASSIGNMENT',\r\n            createdBy: testUserId,\r\n        }).returning();\r\n\r\n        const [task] = await db.insert(measureTasks).values({\r\n            tenantId: testTenantId,\r\n            measureNo: `MEA-GPS-${Date.now()}`,\r\n            leadId: lead.id,\r\n            customerId: testCustomerId,\r\n            status: 'PENDING_VISIT',\r\n            scheduledAt: new Date(Date.now() + 3600000), // Future 1h\r\n        }).returning();\r\n\r\n        // 2. Execute Check-in Within Range\r\n        // Distance 0m (Same coords)\r\n        const result = await checkInMeasureTask({\r\n            taskId: task.id,\r\n            latitude: 31.2304,\r\n            longitude: 121.4737,\r\n            address: 'Shanghai People Square',\r\n            targetLatitude: 31.2304,\r\n            targetLongitude: 121.4737\r\n        });\r\n\r\n        expect(result.success).toBe(true);\r\n        const logicResult = result.data as any;\r\n        expect(logicResult.success).toBe(true);\r\n        expect(logicResult.data.gpsResult).toBeDefined();\r\n        expect(logicResult.data.gpsResult.isWithinRange).toBe(true);\r\n        expect(logicResult.data.lateMinutes).toBe(0);\r\n\r\n        // 3. Verify DB\r\n        const updated = await db.query.measureTasks.findFirst({\r\n            where: eq(measureTasks.id, task.id)\r\n        });\r\n        expect(updated?.checkInAt).toBeDefined();\r\n        const loc = updated?.checkInLocation as any;\r\n        expect(loc.gpsResult.isWithinRange).toBe(true);\r\n    });\r\n\r\n    it('should detect late check-in', async () => {\r\n        const testTenantId = tenantId;\r\n        const testUserId = userId;\r\n        const testCustomerId = customerId;\r\n\r\n        // 1. Create Task Scheduled in Past\r\n        const [lead] = await db.insert(leads).values({\r\n            tenantId: testTenantId,\r\n            leadNo: `L-LATE-${Date.now()}`,\r\n            customerName: 'Late Customer',\r\n            customerPhone: `133${Date.now()}`,\r\n            status: 'PENDING_ASSIGNMENT',\r\n            createdBy: testUserId,\r\n        }).returning();\r\n\r\n        const [task] = await db.insert(measureTasks).values({\r\n            tenantId: testTenantId,\r\n            measureNo: `MEA-LATE-${Date.now()}`,\r\n            leadId: lead.id,\r\n            customerId: testCustomerId,\r\n            status: 'PENDING_VISIT',\r\n            scheduledAt: new Date(Date.now() - 3600000), // 1 hour ago\r\n        }).returning();\r\n\r\n        // 2. Execute Check-in\r\n        const result = await checkInMeasureTask({\r\n            taskId: task.id,\r\n            latitude: 31.2304,\r\n            longitude: 121.4737,\r\n            address: 'Shanghai',\r\n        });\r\n\r\n        expect(result.success).toBe(true);\r\n        const logicResult = result.data as any;\r\n        expect(logicResult.success).toBe(true);\r\n        expect(logicResult.data.lateMinutes).toBeGreaterThan(0);\r\n\r\n        // 3. Verify DB\r\n        const updated = await db.query.measureTasks.findFirst({\r\n            where: eq(measureTasks.id, task.id)\r\n        });\r\n        const loc = updated?.checkInLocation as any;\r\n        expect(loc.lateMinutes).toBeGreaterThan(30); // 60 mins - 15 grace = 45 mins. >30 is safe.\r\n    });\r\n\r\n    it('should reject task and increment count', async () => {\r\n        const testTenantId = tenantId;\r\n        const testUserId = userId;\r\n        const testCustomerId = customerId;\r\n\r\n        // 0. Ensure Lead exists\r\n        const [lead] = await db.insert(leads).values({\r\n            tenantId: testTenantId,\r\n            leadNo: `L-REJ-${Date.now()}`,\r\n            customerName: 'Rej Customer',\r\n            customerPhone: `166${Date.now()}`,\r\n            status: 'PENDING_ASSIGNMENT',\r\n            createdBy: testUserId,\r\n        }).returning();\r\n\r\n        // 1. Create Task\r\n        const [task] = await db.insert(measureTasks).values({\r\n            tenantId: testTenantId,\r\n            measureNo: `MEA-REJ-${Date.now()}`,\r\n            leadId: lead.id,\r\n            customerId: testCustomerId,\r\n            status: 'PENDING_CONFIRM',\r\n            rejectCount: 0\r\n        }).returning();\r\n\r\n        // 2. Reject Task\r\n        const result = await rejectMeasureTask({\r\n            taskId: task.id,\r\n            reason: 'Quality Issue'\r\n        });\r\n\r\n        if (!result.success) console.error('Reject Test Error:', result.error);\r\n        expect(result.success).toBe(true);\r\n\r\n        // Unwrap logic result\r\n        const logicResult = result.data as any;\r\n        expect(logicResult.success).toBe(true);\r\n\r\n        // Unwrap data result\r\n        const data = logicResult.data;\r\n        expect(data.rejectCount).toBe(1);\r\n        expect(data.status).toBe('PENDING');\r\n\r\n        // 3. Verify DB\r\n        const updated = await db.query.measureTasks.findFirst({\r\n            where: eq(measureTasks.id, task.id)\r\n        });\r\n        expect(updated?.rejectCount).toBe(1);\r\n        expect(updated?.rejectReason).toBe('Quality Issue');\r\n        expect(updated?.status).toBe('PENDING');\r\n    });\r\n\r\n    it('should trigger warning on 3rd rejection', async () => {\r\n        const testTenantId = tenantId;\r\n        const testUserId = userId;\r\n        const testCustomerId = customerId;\r\n\r\n        const [lead] = await db.insert(leads).values({\r\n            tenantId: testTenantId,\r\n            leadNo: `L-WARN-${Date.now()}`,\r\n            customerName: 'Warn Customer',\r\n            customerPhone: `155${Date.now()}`,\r\n            status: 'PENDING_ASSIGNMENT',\r\n            createdBy: testUserId,\r\n        }).returning();\r\n\r\n        // 1. Create Task with 2 rejects\r\n        const [task] = await db.insert(measureTasks).values({\r\n            tenantId: testTenantId,\r\n            measureNo: `MEA-WARN-${Date.now()}`,\r\n            leadId: lead.id,\r\n            customerId: testCustomerId,\r\n            status: 'PENDING_CONFIRM',\r\n            rejectCount: 2\r\n        }).returning();\r\n\r\n        // 2. Reject 3rd time\r\n        const result = await rejectMeasureTask({\r\n            taskId: task.id,\r\n            reason: 'Quality Issue 3'\r\n        });\r\n\r\n        if (!result.success) console.error('Warning Test Error:', result.error);\r\n        expect(result.success).toBe(true);\r\n\r\n        const logicResult = result.data as any;\r\n        expect(logicResult.success).toBe(true);\r\n        expect(logicResult.message).toContain('宸查€氱煡搴楅暱'); // Expect warning message\r\n\r\n        const data = logicResult.data;\r\n        expect(data.rejectCount).toBe(3);\r\n    });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\bigey\\Documents\\Antigravity\\L2C\\src\\shared\\auth\\mobile-auth-context.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nC:\\Users\\bigey\\Documents\\Antigravity\\L2C\\src\\shared\\auth\\mobile-auth-context.tsx:92:17\n  90 |         if (storedUser && storedToken) {\n  91 |             try {\n> 92 |                 setUser(JSON.parse(storedUser));\n     |                 ^^^^^^^ Avoid calling setState() directly within an effect\n  93 |             } catch {\n  94 |                 // JSON 瑙ｆ瀽澶辫触锛屾竻鐞嗗瓨鍌╘n  95 |                 localStorage.removeItem(USER_KEY);","line":92,"column":17,"nodeType":null,"endLine":92,"endColumn":24}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\n/**\r\n * 绉诲姩绔璇佷笂涓嬫枃 (Auth Context)\r\n *\r\n * 鎻愪緵:\r\n * - JWT Token 瀛樺偍涓庣鐞哱r\n * - 鐧诲綍/鐧诲嚭閫昏緫\r\n * - Token 鍒锋柊鏈哄埗\r\n * - 鐢ㄦ埛浼氳瘽淇℃伅\r\n */\r\n\r\nimport React, { createContext, useContext, useState, useEffect, useCallback, ReactNode } from 'react';\r\nimport { useRouter } from 'next/navigation';\r\n\r\n// ============================================================\r\n// 绫诲瀷瀹氫箟\r\n// ============================================================\r\n\r\n/**\r\n * 绉诲姩绔敤鎴蜂俊鎭痋r\n */\r\nexport interface MobileUser {\r\n    id: string;\r\n    name: string | null;\r\n    phone: string | null;\r\n    role: 'WORKER' | 'SALES' | 'BOSS' | 'PURCHASER' | 'CUSTOMER';\r\n    tenantId?: string;\r\n    avatar?: string | null;\r\n}\r\n\r\n/**\r\n * 鐧诲綍鍝嶅簲\r\n */\r\ninterface LoginResponse {\r\n    success: boolean;\r\n    data?: {\r\n        accessToken: string;\r\n        refreshToken: string;\r\n        expiresIn: number;\r\n        user: MobileUser;\r\n    };\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * Auth Context 鍊糪r\n */\r\ninterface MobileAuthContextValue {\r\n    user: MobileUser | null;\r\n    isLoading: boolean;\r\n    isAuthenticated: boolean;\r\n    login: (phone: string, password: string) => Promise<{ success: boolean; message?: string }>;\r\n    logout: () => void;\r\n    getToken: () => string | null;\r\n}\r\n\r\n// ============================================================\r\n// 甯搁噺\r\n// ============================================================\r\n\r\nconst ACCESS_TOKEN_KEY = 'l2c_mobile_access_token';\r\nconst REFRESH_TOKEN_KEY = 'l2c_mobile_refresh_token';\r\nconst USER_KEY = 'l2c_mobile_user';\r\n\r\n// ============================================================\r\n// Context\r\n// ============================================================\r\n\r\nconst MobileAuthContext = createContext<MobileAuthContextValue | undefined>(undefined);\r\n\r\n// ============================================================\r\n// Provider\r\n// ============================================================\r\n\r\ninterface MobileAuthProviderProps {\r\n    children: ReactNode;\r\n}\r\n\r\nexport function MobileAuthProvider({ children }: MobileAuthProviderProps) {\r\n    const router = useRouter();\r\n    const [user, setUser] = useState<MobileUser | null>(null);\r\n    const [isLoading, setIsLoading] = useState(true);\r\n\r\n    // 鍒濆鍖? 浠?localStorage 鎭㈠浼氳瘽\r\n    useEffect(() => {\r\n        const storedUser = localStorage.getItem(USER_KEY);\r\n        const storedToken = localStorage.getItem(ACCESS_TOKEN_KEY);\r\n\r\n        if (storedUser && storedToken) {\r\n            try {\r\n                setUser(JSON.parse(storedUser));\r\n            } catch {\r\n                // JSON 瑙ｆ瀽澶辫触锛屾竻鐞嗗瓨鍌╘r\n                localStorage.removeItem(USER_KEY);\r\n                localStorage.removeItem(ACCESS_TOKEN_KEY);\r\n            }\r\n        }\r\n        setIsLoading(false);\r\n    }, []);\r\n\r\n    // 鐧诲綍\r\n    const login = useCallback(async (phone: string, password: string) => {\r\n        try {\r\n            const response = await fetch('/api/mobile/auth/login', {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' },\r\n                body: JSON.stringify({ phone, password }),\r\n            });\r\n\r\n            const data: LoginResponse = await response.json();\r\n\r\n            if (data.success && data.data) {\r\n                // 瀛樺偍 Token 鍜岀敤鎴蜂俊鎭痋r\n                localStorage.setItem(ACCESS_TOKEN_KEY, data.data.accessToken);\r\n                localStorage.setItem(REFRESH_TOKEN_KEY, data.data.refreshToken);\r\n                localStorage.setItem(USER_KEY, JSON.stringify(data.data.user));\r\n\r\n                setUser(data.data.user);\r\n                return { success: true };\r\n            } else {\r\n                return { success: false, message: data.message || '鐧诲綍澶辫触' };\r\n            }\r\n        } catch (error) {\r\n            console.error('Login error:', error);\r\n            return { success: false, message: '缃戠粶閿欒锛岃绋嶅悗閲嶈瘯' };\r\n        }\r\n    }, []);\r\n\r\n    // 鐧诲嚭\r\n    const logout = useCallback(() => {\r\n        localStorage.removeItem(ACCESS_TOKEN_KEY);\r\n        localStorage.removeItem(REFRESH_TOKEN_KEY);\r\n        localStorage.removeItem(USER_KEY);\r\n        setUser(null);\r\n        router.push('/mobile/login');\r\n    }, [router]);\r\n\r\n    // 鑾峰彇 Token\r\n    const getToken = useCallback(() => {\r\n        return localStorage.getItem(ACCESS_TOKEN_KEY);\r\n    }, []);\r\n\r\n    const value: MobileAuthContextValue = {\r\n        user,\r\n        isLoading,\r\n        isAuthenticated: !!user,\r\n        login,\r\n        logout,\r\n        getToken,\r\n    };\r\n\r\n    return (\r\n        <MobileAuthContext.Provider value={value}>\r\n            {children}\r\n        </MobileAuthContext.Provider>\r\n    );\r\n}\r\n\r\n// ============================================================\r\n// Hook\r\n// ============================================================\r\n\r\n/**\r\n * 浣跨敤绉诲姩绔璇佷笂涓嬫枃\r\n */\r\nexport function useMobileAuth() {\r\n    const context = useContext(MobileAuthContext);\r\n    if (context === undefined) {\r\n        throw new Error('useMobileAuth must be used within a MobileAuthProvider');\r\n    }\r\n    return context;\r\n}\r\n","usedDeprecatedRules":[]}]
