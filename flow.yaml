variables:
  - key: PNPM_VERSION
    value: '9.15.0'

sources:
  codeup_source:
    type: codeup
    name: "Codeup 代码源"
    endpoint: https://codeup.aliyun.com/697359d3b28d0aba0f5e4ff2/l2c.git
    branch: main
    certificate:
      type: serviceConnection
      serviceConnection: "n91ncnbpmgw4ybzk"

# 代码提交自动触发流水线
triggers:
  push_trigger:
    name: "代码推送触发"
    type: push
    enabled: true
    branches:
      include:
        - main

stages:
  quality_gate:
    name: "质量检查"
    jobs:
      lint_job:
        name: "ESLint + TypeScript 检查"
        runsOn:
          group: public/cn-beijing
          container: build-steps-public-registry.cn-beijing.cr.aliyuncs.com/build-steps/alinux3:latest
        steps:
          lint_step:
            step: Command
            name: "代码质量检查"
            with:
              run: |
                echo "=== 质量检查开始 ==="
                # 使用 npmmirror 国内镜像安装 Node.js
                curl -fsSL https://npmmirror.com/mirrors/node/v20.19.0/node-v20.19.0-linux-x64.tar.xz -o node.tar.xz
                tar -xJf node.tar.xz -C /usr/local --strip-components=1
                rm -f node.tar.xz
                npm config set registry https://registry.npmmirror.com
                npm install -g pnpm@${PNPM_VERSION}
                echo "Node $(node -v) | pnpm $(pnpm -v)"
                pnpm config set registry https://registry.npmmirror.com
                pnpm install --frozen-lockfile
                echo "运行 ESLint..."
                pnpm lint || { echo "ESLint 检查失败"; exit 1; }
                echo "运行 TypeScript 类型检查..."
                pnpm type-check || { echo "类型检查失败"; exit 1; }
                echo "=== 质量检查通过 ==="

  deploy_stage:
    name: "构建与部署"
    jobs:
      deploy_job:
        name: "CI 编译 → 产物直传 → ECS 轻量构建"
        runsOn:
          group: public/cn-beijing
          container: build-steps-public-registry.cn-beijing.cr.aliyuncs.com/build-steps/alinux3:latest
        steps:
          deploy_step:
            step: Command
            name: "编译、打包、传输并部署"
            with:
              run: |
                echo "=== 方案B：CI 编译 Next.js + 产物直传 ECS ==="

                # ========== 第一步：安装 Node.js + pnpm ==========
                echo "=== 安装 Node.js 20 ==="
                curl -fsSL https://rpm.nodesource.com/setup_20.x | bash -
                yum install -y nodejs sshpass
                npm install -g pnpm@9.15.0
                node -v && pnpm -v

                # ========== 第二步：安装项目依赖 ==========
                echo "=== 安装项目依赖 ==="
                npm config set registry https://registry.npmmirror.com
                pnpm config set registry https://registry.npmmirror.com
                pnpm install --frozen-lockfile

                # ========== 第三步：构建 Next.js ==========
                export GIT_COMMIT_SHA=$(git rev-parse --short HEAD)
                export BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
                echo "Commit: $GIT_COMMIT_SHA | Time: $BUILD_TIME"

                mkdir -p public
                echo "{\"sha\":\"$GIT_COMMIT_SHA\",\"time\":\"$BUILD_TIME\"}" > public/version.json

                echo "=== 构建 Next.js 应用 ==="
                export NEXT_PUBLIC_GIT_COMMIT_SHA="$GIT_COMMIT_SHA"
                export NEXT_PUBLIC_BUILD_TIME="$BUILD_TIME"
                export DATABASE_URL="postgresql://placeholder:placeholder@localhost:5432/placeholder"
                export AUTH_SECRET="build-time-placeholder-secret"
                pnpm run build
                echo "✅ Next.js 构建完成"

                # ========== 第四步：打包预编译产物 ==========
                echo "=== 打包部署产物 ==="

                # 解析 pnpm 符号链接（pnpm 使用 symlink 管理 node_modules，tar 无法直接打包）
                # 使用 rsync -aL 解析符号链接，自动跳过断裂的 symlink
                echo "解析 standalone 中的 pnpm 符号链接..."
                mkdir -p /tmp/standalone-resolved
                rsync -aL --ignore-errors .next/standalone/ /tmp/standalone-resolved/ || true
                rm -rf .next/standalone
                mv /tmp/standalone-resolved .next/standalone
                echo "✅ 符号链接解析完成"

                tar -czf /tmp/l2c-deploy.tar.gz \
                  .next/standalone/ \
                  .next/static/ \
                  public/ \
                  Dockerfile.prebuilt \
                  docker-compose.prod.yml \
                  nginx/ \
                  drizzle/ \
                  drizzle.config.ts \
                  src/shared/api/schema.ts \
                  src/shared/api/schema/ \
                  package.json \
                  pnpm-lock.yaml \
                  tsconfig.json

                ls -lh /tmp/l2c-deploy.tar.gz
                echo "✅ 产物打包完成"

                # ========== 第五步：检查环境变量 ==========
                if [ -z "$ECS_PASSWORD" ]; then echo "错误: ECS_PASSWORD 未设置"; exit 1; fi
                if [ -z "$ECS_HOST" ]; then echo "错误: ECS_HOST 未设置"; exit 1; fi

                # ========== 第六步：传输到 ECS ==========
                echo "=== 上传产物到 ECS ==="
                sshpass -p "$ECS_PASSWORD" scp -o StrictHostKeyChecking=no \
                  /tmp/l2c-deploy.tar.gz root@$ECS_HOST:/root/L2C/l2c-deploy.tar.gz

                echo "✅ 文件传输完成"

                # ========== 第七步：远程部署 ==========
                echo "=== SSH 到 ECS 执行部署 ==="
                sshpass -p "$ECS_PASSWORD" ssh -o StrictHostKeyChecking=no root@$ECS_HOST << 'DEPLOY_EOF'
                  set -e
                  cd /root/L2C

                  # 1. 备份 .env
                  if [ -f .env ]; then cp .env /tmp/.env.l2c_backup; fi

                  # 2. 解压预编译产物
                  echo "=== 解压部署产物 ==="
                  tar -xzf l2c-deploy.tar.gz
                  rm -f l2c-deploy.tar.gz

                  # 3. 恢复 .env
                  if [ -f /tmp/.env.l2c_backup ]; then cp /tmp/.env.l2c_backup /root/L2C/.env; fi

                  # 3.5 生成 .dockerignore（覆盖 Docker BuildKit 使用 .gitignore 的行为）
                  # 必须明确保留 .next/，否则 Docker 会把它排除在构建上下文之外
                  cat > /root/L2C/.dockerignore << 'DOCKERIGNORE_EOF'
node_modules
.git
.env
*.log
DOCKERIGNORE_EOF
                  echo "✅ .dockerignore 已生成"

                  # 验证关键文件存在
                  echo "=== 验证部署产物 ==="
                  ls -la /root/L2C/.next/ || { echo "❌ .next 目录不存在！"; exit 1; }
                  ls -la /root/L2C/.next/standalone/ || { echo "❌ .next/standalone 不存在！"; exit 1; }
                  ls -la /root/L2C/.next/static/ || { echo "❌ .next/static 不存在！"; exit 1; }
                  echo "✅ 产物验证通过"

                  # 4. 停止旧容器
                  echo "=== 停止旧容器 ==="
                  docker compose -f docker-compose.prod.yml down || true

                  # 5. 清理空间
                  echo "=== 清理 Docker 缓存 ==="
                  docker system prune -f
                  docker builder prune -f

                  # 6. 构建轻量镜像（Dockerfile.prebuilt 仅 COPY 预编译文件，不会 OOM）
                  echo "=== 构建轻量 Docker 镜像 ==="
                  docker compose -f docker-compose.prod.yml build --no-cache
                  echo "✅ 镜像构建完成"

                  # 7. 执行数据库迁移（超时 120 秒）
                  echo "=== 执行数据库迁移 ==="
                  timeout 120 docker compose -f docker-compose.prod.yml run --rm db-migrate && {
                    echo "✅ 数据库迁移完成"
                  } || {
                    echo "⚠️ 数据库迁移跳过（可能已是最新），继续部署..."
                  }

                  # 8. 启动应用和 Nginx
                  echo "=== 启动应用 ==="
                  docker compose -f docker-compose.prod.yml up -d --force-recreate app nginx
                  echo "容器已启动，等待健康检查..."

                  # 9. 健康检查（最多等 3 分钟）
                  HEALTHY=false
                  for i in $(seq 1 36); do
                    if curl -sf http://localhost:3000/api/health > /dev/null 2>&1; then
                      echo "✅ 健康检查通过 (第 ${i} 次尝试)"
                      HEALTHY=true
                      break
                    fi
                    echo "  等待中... ($i/36)"
                    sleep 5
                  done

                  if [ "$HEALTHY" = "false" ]; then
                    echo "❌ 健康检查超时！"
                    docker compose -f docker-compose.prod.yml ps
                    docker compose -f docker-compose.prod.yml logs --tail=80 app
                    exit 1
                  fi

                  # 10. 输出最终状态
                  docker compose -f docker-compose.prod.yml ps
                  docker image prune -f --filter "until=24h"
                  echo "=== L2C 部署成功完成 ==="
                DEPLOY_EOF
                echo "=== 流水线结束 ==="
