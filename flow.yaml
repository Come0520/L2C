variables:
  - key: PNPM_VERSION
    value: '9.15.0'

sources:
  codeup_source:
    type: codeup
    name: "Codeup 代码源"
    endpoint: https://codeup.aliyun.com/697359d3b28d0aba0f5e4ff2/l2c.git
    branch: main
    certificate:
      type: serviceConnection
      serviceConnection: "n91ncnbpmgw4ybzk"

# 代码提交自动触发流水线
triggers:
  push_trigger:
    name: "代码推送触发"
    type: push
    enabled: true
    branches:
      include:
        - main

stages:
  quality_gate:
    name: "质量检查"
    jobs:
      lint_job:
        name: "ESLint + TypeScript 检查"
        runsOn:
          group: public/cn-beijing
          container: build-steps-public-registry.cn-beijing.cr.aliyuncs.com/build-steps/alinux3:latest
        steps:
          lint_step:
            step: Command
            name: "代码质量检查"
            with:
              run: |
                echo "=== 质量检查开始 ==="
                # 使用 npmmirror 国内镜像安装 Node.js
                curl -fsSL https://npmmirror.com/mirrors/node/v20.19.0/node-v20.19.0-linux-x64.tar.xz -o node.tar.xz
                tar -xJf node.tar.xz -C /usr/local --strip-components=1
                rm -f node.tar.xz
                npm config set registry https://registry.npmmirror.com
                npm install -g pnpm@${PNPM_VERSION}
                echo "Node $(node -v) | pnpm $(pnpm -v)"
                pnpm config set registry https://registry.npmmirror.com
                pnpm install --frozen-lockfile
                echo "运行 ESLint..."
                pnpm lint || { echo "ESLint 检查失败"; exit 1; }
                echo "运行 TypeScript 类型检查..."
                pnpm type-check || { echo "类型检查失败"; exit 1; }
                echo "=== 质量检查通过 ==="

  deploy_stage:
    name: "打包与部署"
    jobs:
      deploy_job:
        name: "打包 → 部署 → 验证"
        runsOn:
          group: public/cn-beijing
          container: build-steps-public-registry.cn-beijing.cr.aliyuncs.com/build-steps/alinux3:latest
        steps:
          deploy_step:
            step: Command
            name: "打包、部署与健康检查"
            with:
              run: |
                echo "=== 开始打包与部署 ==="

                # ========== 第一步：打包源码 ==========
                export GIT_COMMIT_SHA=$(git rev-parse --short HEAD)
                export BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
                echo "Commit: $GIT_COMMIT_SHA | Time: $BUILD_TIME"
                mkdir -p public
                echo "{\"sha\":\"$GIT_COMMIT_SHA\",\"time\":\"$BUILD_TIME\"}" > public/version.json
                echo "GIT_COMMIT_SHA=$GIT_COMMIT_SHA" > .build-args
                echo "BUILD_TIME=$BUILD_TIME" >> .build-args
                tar -czf /tmp/release.tar.gz \
                  --exclude='node_modules' \
                  --exclude='.next' \
                  --exclude='.git' \
                  --exclude='test-results' \
                  --exclude='playwright-report' \
                  --exclude='coverage' \
                  --exclude='*.log' \
                  --exclude='release.tar.gz' \
                  .
                mv /tmp/release.tar.gz release.tar.gz
                ls -lh release.tar.gz
                echo "=== 打包完成 ==="

                # ========== 第二步：安装部署工具 ==========
                if command -v apt-get >/dev/null; then
                  apt-get update -qq && apt-get install -y -qq sshpass rsync curl
                elif command -v yum >/dev/null; then
                  yum install -y sshpass rsync curl
                elif command -v apk >/dev/null; then
                  apk add --no-cache sshpass rsync curl
                else
                  echo "无法安装 sshpass"; exit 1
                fi

                # 检查环境变量
                if [ -z "$ECS_PASSWORD" ]; then echo "错误: ECS_PASSWORD 未设置"; exit 1; fi
                if [ -z "$ECS_HOST" ]; then echo "错误: ECS_HOST 未设置"; exit 1; fi

                # ========== 第三步：上传到 ECS ==========
                echo "上传 release.tar.gz 到 ECS..."
                sshpass -p "$ECS_PASSWORD" scp -o StrictHostKeyChecking=no \
                  release.tar.gz root@$ECS_HOST:/root/L2C/release.tar.gz

                # ========== 第四步：远程部署 ==========
                sshpass -p "$ECS_PASSWORD" ssh -o StrictHostKeyChecking=no root@$ECS_HOST << 'DEPLOY_EOF'
                  set -e
                  cd /root/L2C

                  # 1. 备份 .env
                  if [ -f .env ]; then cp .env /tmp/.env.l2c_backup; fi

                  # 2. 备份当前版本（用于回滚）
                  if [ -f release.current.tar.gz ]; then cp release.current.tar.gz release.prev.tar.gz; fi

                  # 3. 原子化解压到临时目录
                  TEMP_DIR=$(mktemp -d /root/L2C_deploy_XXXXXX)
                  tar -xzf release.tar.gz -C "$TEMP_DIR"
                  if [ ! -f "$TEMP_DIR/Dockerfile" ] || [ ! -f "$TEMP_DIR/docker-compose.prod.yml" ]; then
                    echo "错误：解压后缺少关键文件，中止部署"
                    rm -rf "$TEMP_DIR"
                    exit 1
                  fi

                  # 4. rsync 同步（排除运行时数据）
                  rsync -a --delete \
                    --exclude='.env' \
                    --exclude='.git' \
                    --exclude='node_modules' \
                    --exclude='.next' \
                    --exclude='release.tar.gz' \
                    --exclude='release.*.tar.gz' \
                    --exclude='uploads' \
                    --exclude='logs' \
                    --exclude='nginx/ssl' \
                    "$TEMP_DIR/" /root/L2C/
                  rm -rf "$TEMP_DIR"

                  # 5. 恢复 .env
                  if [ -f /tmp/.env.l2c_backup ]; then cp /tmp/.env.l2c_backup /root/L2C/.env; fi
                  mv release.tar.gz release.current.tar.gz

                  # 6. 加载版本信息
                  if [ -f .build-args ]; then source .build-args; export GIT_COMMIT_SHA BUILD_TIME; fi

                  # 7. 数据库迁移已由 docker-compose.prod.yml 中的 db-migrate 服务自动执行
                  # 无需在宿主机安装 Node.js（CentOS 7 GLIBC 不兼容）
                  echo "=== 数据库迁移将由容器自动执行 ==="

                  # 8. 重建并启动容器
                  docker compose -f docker-compose.prod.yml down || true
                  docker compose -f docker-compose.prod.yml up -d --build --force-recreate
                  echo "容器已启动，等待健康检查..."

                  # 9. 健康检查（最多等 2 分钟）
                  HEALTHY=false
                  for i in $(seq 1 24); do
                    if curl -sf http://localhost:3000/api/health > /dev/null 2>&1; then
                      echo "✅ 健康检查通过 (第 ${i} 次尝试)"
                      HEALTHY=true
                      break
                    fi
                    echo "  等待中... ($i/24)"
                    sleep 5
                  done

                  if [ "$HEALTHY" = "false" ]; then
                    echo "❌ 健康检查超时！"
                    docker compose -f docker-compose.prod.yml logs --tail=80 app
                    # 自动回滚
                    if [ -f release.prev.tar.gz ]; then
                      echo "=== 自动回滚到上一版本 ==="
                      if [ -f .env ]; then cp .env /tmp/.env.l2c_backup; fi
                      tar -xzf release.prev.tar.gz
                      if [ -f /tmp/.env.l2c_backup ]; then cp /tmp/.env.l2c_backup .env; fi
                      docker compose -f docker-compose.prod.yml down || true
                      docker compose -f docker-compose.prod.yml up -d --build --force-recreate
                      sleep 30
                      if curl -sf http://localhost:3000/api/health > /dev/null 2>&1; then
                        echo "回滚后健康检查通过"
                      else
                        echo "回滚后仍不健康，需手动干预"
                      fi
                    else
                      echo "没有上一版本可回滚，需手动干预"
                    fi
                    exit 1
                  fi

                  # 10. 输出最终状态
                  docker compose -f docker-compose.prod.yml ps
                  docker image prune -f --filter "until=24h"
                  echo "=== L2C 部署成功完成 ==="
                DEPLOY_EOF
                echo "=== 流水线结束 ==="
