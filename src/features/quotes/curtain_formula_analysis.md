# 窗帘面料和成品窗帘计算公式及结果分析

## 一、 窗帘计算公式

系统的窗帘计算公式（定义在 `src/features/quotes/calc-strategies/curtain-strategy.ts` 中）如下：

### 1. 尺寸计算
- **成品宽度 (Finished Width)**: `测量宽度 × 褶皱倍数`
- **成品高度 (Finished Height)**: `测量高度 - 离地间隙`
- **裁剪宽度 (Cut Width)**: `成品宽度 + 侧边损耗`（侧边损耗默认为：双开 10cm，单开 5cm）
- **裁剪高度 (Cut Height)**: `成品高度 + 帘头损耗 + 底边损耗`（帘头损耗：包布带 20cm/贴布带 7cm，底边损耗默认 10cm）

### 2. 用料计算 (Quantity)
系统根据面料的类型分为**定高**和**定宽**两种主要计算方式：
- **定高买宽 (FIXED_HEIGHT)** (默认算法):  
  `用料 (米) = 裁剪宽度(cm) / 100`  
  *(注：该模式下会检查裁剪高度是否大于面料总幅宽，如果超出则产生预警)*
- **定宽买高 (FIXED_WIDTH)**:  
  计算所需幅数：`幅数 = Math.ceil(裁剪宽度 / 面料幅宽)`  
  `用料 (米) = (幅数 × 裁剪高度) / 100`
- **最终修正**:  
  为了保留安全余量并且符合规范，最终只保留小数点后一位并向上取整：  
  `最终用量 = Math.ceil(原始用量 * 10) / 10`

### 3. 金额计算
- **小计金额 (Subtotal)**: `最终用量(数量) × 单价 + 工费`

---

## 二、 为什么会得出截图中的结果（240x250, 数量=0.1, 小计=¥0.00）？

结合系统的前后端源码，截图中的怪异结果是由**后端的一个 JavaScript 隐式转换 Bug**和**前端 React 表单交互机制**叠加产生的。

### 1. 为什么“数量 (用料)”算出来了 `0.1`？
在后端的持久化逻辑 (`quote-item-crud.ts`) 中，当用户修改尺寸时，会触发重新计算并获取原本的“褶皱倍数”(foldRatio)。但源码中的写法是有缺陷的：
```typescript
const foldRatio = updateData.foldRatio ?? Number(existing.foldRatio) ?? 2;
```
- **问题所在**：由于您的界面可能隐藏了“褶皱倍数”的填写列导致这条记录在数据库里的 `foldRatio` 是 `null`。
- `Number(null)` 在解析时**等于 `0`**。
- 随后进行的 `0 ?? 2` 判断，因为 `0` 不是 `null` 也不是 `undefined`，所以合并操作符会直接保留 `0`，而**不会回退到默认的 `2` 倍褶皱**。
- **代入由于 Bug 产生的公式**：  
  - 成品宽度 = `240 × 0 = 0` cm  
  - 裁剪宽度 = `0 + 侧边损耗 10cm = 10` cm
  - 根据定高公式计算用料 = `10 / 100 = 0.1` 米。  
于是后端将 `0.1` 存入了数据库，并在前端刷新后强制显示为 `0.1`。

### 2. 为什么“小计”是 `¥0.00`（单价明明是 100）？
这是由于输入框的**焦点事件（onBlur）尚未触发**引起的视觉差：
- 在当前页面，计算和保存的操作是绑定在输入框的 `onBlur` 事件上的（即鼠标点击其他地方或者按下回车时才会保存数据并重新算小计）。
- 创建 `TestCurtain` 这个商品时，其数据库内记录的单价非常可能是 `0`（导致小计初始被保存为 0）。
- **重现截图场景**：用户刚好点进 `单价` 输入框，打出了 `100` 这 3 个数字。此时截图，UI 是受控/非受控的输入状态展示了 `100`，但因为还没失去焦点，没有触发网络请求让后端去计算 `0.1 × 100`。
- 这就导致了此时这行数据的 DB 内存依然是 `小计: 0`，因此通过 `¥{Number(item.subtotal)}` 渲染出来的小计就是 `¥0.00`。
- *验证方法：用户如果在该输入框按下回车，小计立即就会变成 `¥10.00`。*

## 修理建议
我随时可以为您修改后端的这处倍数判定漏洞，将其修复为：
```typescript
const foldRatio = updateData.foldRatio ?? 
                 (existing.foldRatio ? Number(existing.foldRatio) : 2);
```
这样不仅能解决异常的 0.1 的用料计算，还能彻底杜绝隐藏“倍数”列后算不出正常用量的问题。需要我立即修复吗？
